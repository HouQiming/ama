// //// JC version: 3
#include <console.jch>
#include '../ast/node.jch'
#include "../script/jsenv.jch"
#include './postfix.jch'
#include './decl.jch'

namespace ama {
	private char[|]! GetFunctionName(int! is_keyworded, ama::Node*+! nd_func) {
		char[|]! name = '';
		ama::Node*+! @nojson nd_before = nd_func.c;
		if( is_keyworded ) {
			//just take the last identifier
			//if nd_before is a single node, it must be the keyword
			if( nd_before.node_class == ama::N_RAW ) {
				//the first child is the keyword
				for(ama::Node*+! @nojson ndi = nd_before.c.s; ndi; ndi = ndi.s) {
					if( ndi.node_class == ama::N_REF || ndi.node_class == ama::N_DOT ) {
						name = ndi.data;
					}
				}
			}
		} else {
			//try to find a name
			int! found = 0;
			for(ama::Node*+! @nojson ndi = nd_before.c; ndi; ndi = ndi.s) {
				if( ndi.node_class == ama::N_REF || ndi.node_class == ama::N_DOT ) {
					name = ndi.data;
					found = 1;
				}
			}
			if( !found ) {
				//test for old C macro FOO_DECL(int,foo)(int bar){}
				ama::Node*+! @nojson nd_maybe_c_macro = nd_before.node_class == ama::N_RAW ? nd_before : nd_before.LastChild();
				if( nd_maybe_c_macro.node_class == ama::N_CALL || nd_maybe_c_macro.isRawNode('(', ')') ) {
					ama::Node*+! nd_maybe_name = nd_maybe_c_macro.LastChild();
					if( nd_maybe_name.node_class == ama::N_REF ) {
						name = nd_maybe_name.data;
					}
				}
			}
		}
		return name;
	}
	//detects: N_FUNCTION and N_CLASS
	//also parses if / else / ...
	//after ParseAssignment	
	private const int! KW_NONE = 0;
	private const int! KW_CLASS = 1;
	private const int! KW_STMT = 2;
	private const int! KW_EXT = 3;
	private const int! KW_FUNC = 4;
	ama::Node*+! ParseScopedStatements(ama::Node*+! nd_root, JSValue! options) {
		Map<char[|], int>! keywords_class = ama::GetPrioritizedList(options, "keywords_class");
		Map<char[|], int>! keywords_statement = ama::GetPrioritizedList(options, "keywords_statement");
		Map<char[|], int>! keywords_extension_clause = ama::GetPrioritizedList(options, "keywords_extension_clause");
		Map<char[|], int>! keywords_function = ama::GetPrioritizedList(options, "keywords_function");
		Map<char[|], int>! keywords_after_class_name = ama::GetPrioritizedList(options, "keywords_after_class_name");
		Map<char[|], int>! keywords_after_prototype = ama::GetPrioritizedList(options, "keywords_after_prototype");
		int32_t! parse_cpp11_lambda = ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_cpp11_lambda'), 1);
		//TODO: C unscoped statements detection
		//TODO: C forward declaration - separate function
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			ama::Node*+! ndi = nd_raw.c;
			ama::Node*+! nd_prototype_start = ndi;
			ama::Node*+*+! pndi = &nd_raw.c;
			ama::Node*+! nd_last_scoped_stmt = NULL;
			int! kw_mode = KW_NONE;
			ama::Node*+! nd_keyword = NULL;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( !kw_mode && (ndi.node_class == ama::N_REF || ndi.node_class == ama::N_CALL) ) {
					//keywords are not necessarily statement starters: template<>, weird macro, label, etc.
					char[|]! name = ndi.GetName();
					if( name != NULL ) {
						if( keywords_class[name] ) {
							nd_keyword = ndi;
							kw_mode = KW_CLASS;
						} else if( keywords_statement[name] ) {
							nd_keyword = ndi;
							kw_mode = KW_STMT;
						} else if( nd_last_scoped_stmt && keywords_extension_clause[name] ) {
							nd_keyword = ndi;
							kw_mode = KW_EXT;
						} else if( keywords_function[name] ) {
							nd_keyword = ndi;
							kw_mode = KW_FUNC;
						}
					}
				} else if( ndi.node_class == ama::N_SYMBOL && (ndi.data == "," || ndi.data == ";") ) {
					nd_prototype_start = ndi_next;
					kw_mode = KW_NONE;
					nd_keyword = NULL;
				} else if( ndi.isRawNode('[', ']') && ndi_next && ndi_next.isRawNode('(', ')') ) {
					//C++11 lambda
					nd_prototype_start = ndi;
					kw_mode = KW_NONE;
					nd_keyword = NULL;
				} else if( (ndi.node_class == ama::N_SCOPE || ndi.isRawNode('{', '}')) && nd_prototype_start && nd_prototype_start != ndi ) {
					//console.log('lol', kw_mode);
					switch( kw_mode ) {
						case KW_CLASS: {
							//search for the class name
							ama::Node*+! nd_class_name = NULL;
							ama::Node*+*+! pnd_class_name = NULL;
							ama::Node*+*+! pndj = &nd_keyword.s;
							for(ama::Node*+! @nojson ndj = nd_keyword.s; ndj != ndi; ndj = ndj.s) {
								if( (ndj.node_class == ama::N_SYMBOL || ndj.node_class == ama::N_REF) && keywords_after_class_name[ndj.data] && nd_class_name ) {
									break;
								}
								if( ndj.node_class == ama::N_REF || ((ndj.node_class == ama::N_CALL || ndj.node_class == ama::N_CALL_TEMPLATE) && ndj.GetName() != NULL) ) {
									nd_class_name = ndj;
									pnd_class_name = pndj;
								}
								pndj = &ndj;
							}
							if( !nd_class_name ) {
								//C mode switch: struct foo{union{int bar;float baz;}}
								//it's not a declaration
								`goto not_declaration;`
							}
							if( nd_keyword.node_class == ama::N_CALL ) {
								nd_keyword = ama::UnparseCall(nd_keyword);
							}
							ama::Node*+! nd_class = ReplaceChildRange(
								NULL,
								nd_keyword, ndi,
								ama::CreateNode(ama::N_CLASS, NULL).setData(nd_keyword.data)
							);
							//class children: whatever before, name, whatever after, body
							*pnd_class_name = NULL;
							ama::Node*+! @nojson nd_before = nd_keyword.s && !nd_keyword.s.s ? nd_keyword.s : ama::CreateNode(ama::N_RAW, nd_keyword.s);
							ama::Node*+! @nojson nd_after = nd_class_name.s;
							nd_class_name.s = NULL;
							*pndi = NULL;
							ndi.s = NULL;
							if( !nd_after || nd_after.s ) {
								nd_after = ama::CreateNode(ama::N_RAW, nd_after);
							}
							nd_class.c = ama::cons(nd_before, ama::cons(nd_class_name, ama::cons(nd_after, ndi)));
							for(ama::Node*+! @nojson ndj = nd_class.c; ndj; ndj = ndj.s) {
								ndj.p = nd_class;
							}
							ndi = nd_class;
							nd_prototype_start = ndi.s;
							ndi_next = ndi.s;
							nd_keyword.s = NULL;
							nd_keyword.p = NULL;
							nd_keyword.FreeASTStorage();
							break;
						}
						case KW_STMT: {
							//pull keyword out of raw, separate "condition" (even if it's empty) and scope
							if( nd_keyword.node_class == ama::N_CALL ) {
								nd_keyword = ama::UnparseCall(nd_keyword);
							}
							ama::Node*+! nd_stmt = ReplaceChildRange(
								NULL,
								nd_keyword, ndi,
								ama::CreateNode(ama::N_SCOPED_STATEMENT, NULL).setData(nd_keyword.data).setCommentsBefore(nd_keyword.comments_before).setIndent(nd_keyword.indent_level)
							);
							ama::Node*+! @nojson nd_arg = nd_keyword.s && !nd_keyword.s.s ? nd_keyword.s : ama::CreateNode(ama::N_RAW, nd_keyword.s);
							nd_arg.MergeCommentsBefore(nd_keyword);
							*pndi = NULL;
							ndi.s = NULL;
							nd_stmt.c = ama::cons(nd_arg, ndi);
							for(ama::Node*+! @nojson ndj = nd_stmt.c; ndj; ndj = ndj.s) {
								ndj.p = nd_stmt;
							}
							ndi = nd_stmt;
							nd_prototype_start = ndi.s;
							nd_keyword.s = NULL;
							nd_keyword.FreeASTStorage();
							////////
							nd_last_scoped_stmt = nd_stmt;
							pndi = &ndi.s;
							ndi = ndi.s;
							continue;
						}
						case KW_EXT: {
							if( nd_keyword.node_class == ama::N_CALL ) {
								nd_keyword = ama::UnparseCall(nd_keyword);
							}
							ReplaceChildRange(
								NULL,
								nd_keyword, ndi,
								NULL
							);
							assert(nd_last_scoped_stmt);
							ama::Node*+! @nojson nd_arg = nd_keyword.s && !nd_keyword.s.s ? nd_keyword.s : ama::CreateNode(ama::N_RAW, nd_keyword.s);
							nd_arg.MergeCommentsBefore(nd_keyword);
							*pndi = NULL;
							ndi.s = NULL;
							//insert into the last statement
							nd_last_scoped_stmt.Insert(ama::POS_BACK, ama::nExtensionClause(
								nd_keyword.data, nd_arg, ndi
							).setCommentsBefore(nd_keyword.comments_before).setIndent(nd_keyword.indent_level));
							nd_keyword.s = NULL;
							nd_keyword.FreeASTStorage();
							ndi = nd_last_scoped_stmt;
							pndi = &ndi.s;
							ndi = ndi.s;
							nd_prototype_start = ndi.s;
							continue;
						}
						case KW_FUNC: default: {
							//it's not necessarily a declaration, detect C / C++11 / Java / etc. keywordless functions
							//what else could it be? C/C++ initializer list, new (which could have (){} for JC)
							//use (){} as indicator: we could drag back those misidentified functions later
							//if we had a keyword, we won't have a C-like return type
							if( !nd_keyword ) {
								nd_keyword = nd_prototype_start;
							} else if( nd_keyword.node_class == ama::N_CALL ) {
								//the unparsing always creates a paramlist
								nd_keyword = ama::UnparseCall(nd_keyword);
							}
							ama::Node*+! nd_paramlist = NULL;
							for(ama::Node*+! @nojson ndj = nd_keyword.s; ndj != ndi; ndj = ndj.s) {
								if( ndj.isRawNode('(', ')') || ndj.node_class == ama::N_CALL ) {
									nd_paramlist = ndj;
								} else if( ndj.node_class == ama::N_SYMBOL && keywords_after_prototype[ndj.data] ) {
									break;
								} else if( parse_cpp11_lambda && ndj.isRawNode('[', ']') && ndj.s.isRawNode('(', ')') ) {
									nd_paramlist = ndj.s;
									break;
								}
							}
							if( !nd_paramlist ) {
								`goto not_declaration;`
							}
							if( nd_paramlist.node_class == ama::N_CALL ) {
								nd_paramlist = ama::UnparseCall(nd_paramlist).s;
							}
							//keyworded function shouldn't have any junk before... but C++ function has both junk before and junk after
							//before (C++ return type plus junk plus name, or just a name), paramlist, after, body, figure out return type separately
							ama::Node*+! nd_func = ReplaceChildRange(
								NULL,
								nd_keyword, ndi,
								ama::CreateNode(ama::N_FUNCTION, NULL)
							);
							ama::Node*+! nd_before = nd_keyword;
							if( nd_before == nd_paramlist ) {
								nd_before = ama::CreateNode(ama::N_RAW, NULL);
							}
							ama::Node*+! @nojson nd_after = nd_paramlist.s;
							if( nd_after == ndi ) {
								nd_after = ama::CreateNode(ama::N_RAW, NULL);
							}
							ama::Node*+*+! pndj = NULL;
							for(ama::Node*+! ndj = nd_keyword;; ndj = ndj.s) {
								if( ndj == nd_paramlist ) {
									*pndj = NULL;
								} else if( ndj == ndi ) {
									*pndj = NULL;
									break;
								}
								pndj = &ndj.s;
							}
							//nd_paramlist.Delete();
							//ndi.Delete();
							if( nd_before.s ) { nd_before = ama::CreateNode(ama::N_RAW, nd_before); }
							if( nd_after.s ) { nd_after = ama::CreateNode(ama::N_RAW, nd_after); }
							nd_func.c = ama::cons(nd_before, ama::cons(nd_paramlist, ama::cons(nd_after, ndi)));
							for(ama::Node*+! @nojson ndj = nd_func.c; ndj; ndj = ndj.s) {
								ndj.p = nd_func;
							}
							nd_func.data = GetFunctionName(kw_mode == KW_FUNC, nd_func);
							ndi = nd_func;
							nd_prototype_start = ndi.s;
							ndi_next = ndi.s;
							break;
						}
					}
					`not_declaration:;`
				}
				nd_last_scoped_stmt = NULL;
				pndi = &ndi.s;
				ndi = ndi_next;
			}
		}
		//COULDDO: set REF_WRITTEN for function / class names
		//TODO: assignment-ify parameters
		return nd_root;
	}
	////detects N_TYPED_VAR
	////also sets REF_WRITTEN and REF_RW
	////after ParseAssignment
	//ama::Node*+! ParseVariableDeclaration(ama::Node*+! nd_root,JSValue! options)
	//	//TODO: search for function prototypes / template declarations, and turn params into N_ASSIGNMENT
	//	//TODO: N_TYPED_VAR
};
