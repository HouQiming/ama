// //// JC version: 3
#include <console.jch>
#include '../ast/node.jch'
#include "../script/jsenv.jch"
#include './postfix.jch'
#include './decl.jch'
#include './operator.jch'

namespace ama {
	private ama::Node*+! ConvertToParameterList(ama::Node*+! nd_raw) {
		assert(nd_raw.isRawNode('(', ')'));
		ama::Node*+[+]! params = new ama::Node*+[+]!();
		for(auto ndi : nd_raw) {
			if( ndi.isSymbol(",") ) { continue; }
			params.push(ndi);
		}
		return ama::CreateNodeFromChildren(ama::N_PARAMETER_LIST, params);
	}
	private char[|]! GetFunctionName(int! is_keyworded, ama::Node*+! nd_func) {
		char[|]! name = '';
		ama::Node*+! nd_before = nd_func.c;
		if( is_keyworded ) {
			//just take the last identifier
			//if nd_before is a single node, it must be the keyword
			if( nd_before.node_class == ama::N_RAW ) {
				//the first child is the keyword
				for(ama::Node*+! ndi = nd_before.c.s; ndi; ndi = ndi.s) {
					if( ndi.node_class == ama::N_REF || ndi.node_class == ama::N_DOT ) {
						name = ndi.data;
					}
				}
			}
		} else {
			//try to find a name
			int! found = 0;
			for(ama::Node*+! ndi = nd_before.c; ndi; ndi = ndi.s) {
				if( ndi.node_class == ama::N_REF || ndi.node_class == ama::N_DOT ) {
					name = ndi.data;
					found = 1;
				}
			}
			if( !found ) {
				//test for old C macro FOO_DECL(int,foo)(int bar){}
				ama::Node*+! nd_maybe_c_macro = nd_before.node_class == ama::N_RAW ? nd_before : nd_before.LastChild();
				if( nd_maybe_c_macro.node_class == ama::N_CALL || nd_maybe_c_macro.isRawNode('(', ')') ) {
					ama::Node*+! nd_maybe_name = nd_maybe_c_macro.LastChild();
					if( nd_maybe_name.node_class == ama::N_REF ) {
						name = nd_maybe_name.data;
					}
				}
			}
		}
		return name;
	}
	//detects: N_FUNCTION and N_CLASS
	//also parses if / else / ...
	//after ParseAssignment	
	private const int! KW_NONE = 0;
	private const int! KW_CLASS = 1;
	private const int! KW_STMT = 2;
	private const int! KW_EXT = 3;
	private const int! KW_FUNC = 4;
	private ama::Node*+! TranslateCUnscopedStatement(ama::Node*+! nd_keyword) {
		ama::Node*+! nd_body = ama::BreakLink(&nd_keyword.s);
		if( nd_keyword.node_class == ama::N_CALL ) {
			nd_keyword = ama::UnparseCall(nd_keyword);
		}
		ama::Node*+! nd_stmt = ama::CreateNode(ama::N_SCOPED_STATEMENT, NULL).setData(nd_keyword.data).setCommentsBefore(nd_keyword.comments_before).setIndent(nd_keyword.indent_level);
		nd_body = ama::toSingleNode(nd_body);
		ama::Node*+! nd_scoped_body = ama::CreateNode(ama::N_SCOPE, nd_body);
		std::swap(nd_scoped_body.comments_before, nd_body.comments_before);
		std::swap(nd_scoped_body.comments_after, nd_body.comments_after);
		nd_scoped_body.indent_level = nd_body.indent_level;
		ama::AdjustIndentLevel(nd_body, -nd_scoped_body.indent_level);
		nd_stmt.c = ama::cons(ama::toSingleNode(ama::BreakLink(&nd_keyword.s)).MergeCommentsBefore(nd_keyword), nd_scoped_body);
		for(ama::Node*+! ndj = nd_stmt.c; ndj; ndj = ndj.s) {
			ndj.p = nd_stmt;
		}
		nd_keyword.ReplaceWith(nd_stmt);
		nd_keyword.FreeASTStorage();
		return nd_stmt;
	}
	private ama::Node*+! TranslateCForwardDeclaration(ama::Node*+! nd_raw) {
		//N_FUNCTION with air body
		//before, paramlist, after, body
		ama::Node*+! nd_proto = NULL;
		ama::Node*+*+! pndi = &nd_raw.c;
		for(ama::Node*+! @nojson ndi = nd_raw.c; ndi; (pndi = &ndi.s, ndi = ndi.s)) {
			if( ndi.node_class == ama::N_CALL ) {
				nd_proto = ndi;
			}
		}
		if( !nd_proto ) { return NULL; }
		ama::Node*+! nd_fname = ama::UnparseCall(nd_proto);
		nd_proto = ama::BreakLink(&nd_fname.s);
		ama::Node*+! nd_before = ama::toSingleNode(nd_raw.c);
		ama::Node*+! nd_after = ama::toSingleNode(ama::BreakLink(&nd_proto.s));
		ama::Node*+! nd_func = ama::nFunction(nd_before, ConvertToParameterList(nd_proto), nd_after, ama::nAir());
		nd_func.data = GetFunctionName(0, nd_func);
		nd_raw.ReplaceWith(nd_func);
		nd_raw.c = NULL;
		nd_raw.FreeASTStorage();
		return nd_func;
	}
	ama::Node*+! ParseScopedStatements(ama::Node*+! nd_root, JSValue! options) {
		Map<char[|], int>! keywords_class = ama::GetPrioritizedList(options, "keywords_class");
		Map<char[|], int>! keywords_statement = ama::GetPrioritizedList(options, "keywords_statement");
		Map<char[|], int>! keywords_extension_clause = ama::GetPrioritizedList(options, "keywords_extension_clause");
		Map<char[|], int>! keywords_function = ama::GetPrioritizedList(options, "keywords_function");
		Map<char[|], int>! keywords_after_class_name = ama::GetPrioritizedList(options, "keywords_after_class_name");
		Map<char[|], int>! keywords_after_prototype = ama::GetPrioritizedList(options, "keywords_after_prototype");
		int32_t! parse_c_forward_declarations = ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_c_forward_declarations'), 1);
		if( ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_colon_statements'), 1) ) {
			//use reverse() to facilitate recursive unparsing of if foo:{}else:{}
			for(ama::Node*+! nd_labeled : nd_root.FindAll(ama::N_LABELED, NULL).reverse()) {
				if( nd_labeled.c.node_class == ama::N_RAW && nd_labeled.c.c && (nd_labeled.c.c.node_class == ama::N_REF || nd_labeled.c.c.node_class == ama::N_CALL) ) {
					char[|]! name = nd_labeled.c.c.GetName();
					if( keywords_statement[name] || keywords_extension_clause[name] ) {
						ama::UnparseLabel(nd_labeled);
					}
				} else if( nd_labeled.c.node_class == ama::N_REF || nd_labeled.c.node_class == ama::N_CALL ) {
					char[|]! name = nd_labeled.c.GetName();
					if( keywords_statement[name] || keywords_extension_clause[name] ) {
						ama::UnparseLabel(nd_labeled);
					}
				} else if( (nd_labeled.c.s.node_class == ama::N_SCOPE && nd_labeled.c.node_class == ama::N_RAW) || nd_labeled.c.node_class == ama::N_CALL ) {
					if( nd_labeled.c.node_class == ama::N_CALL ) {
						ama::Node*+! nd_call = nd_labeled.c;
						ama::Node*+! nd_tmp = ama::GetPlaceHolder();
						nd_call.ReplaceWith(nd_tmp);
						nd_tmp.ReplaceWith(ama::CreateNode(ama::N_RAW, nd_call));
					}
					ama::Node*+! nd_maybe_call = nd_labeled.c.LastChild();
					if( nd_maybe_call.node_class == ama::N_CALL ) {
						//foo():{bar}, treat as function
						ama::Node*+! nd_body = nd_labeled.c.s;
						ama::Node*+! nd_paramlist = ama::UnparseCall(nd_maybe_call).s;
						ama::Node*+! nd_before = nd_labeled.c.c;
						ama::Node*+! nd_after = nd_paramlist.s;
						nd_paramlist.Delete();
						//before, paramlist, after, body
						ama::Node*+! nd_func = ama::CreateNode(ama::N_FUNCTION, ama::cons(
							ama::toSingleNode(nd_before), ama::cons(
								ConvertToParameterList(nd_paramlist),
								ama::cons(ama::toSingleNode(nd_after), nd_body)
							)
						));
						nd_func.data = GetFunctionName(1, nd_func);
						nd_labeled.ReplaceWith(nd_func);
					}
				}
			}
		}
		int32_t! parse_cpp11_lambda = ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_cpp11_lambda'), 1);
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			if( !nd_raw.p ) { continue; }
			ama::Node*+! ndi = nd_raw.c;
			ama::Node*+! nd_prototype_start = ndi;
			ama::Node*+*+! pndi = &nd_raw.c;
			ama::Node*+! nd_last_scoped_stmt = NULL;
			int! kw_mode = KW_NONE;
			ama::Node*+*+! link_keyword = NULL;
			ama::Node*+! nd_keyword = NULL;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( !nd_keyword && (ndi.node_class == ama::N_REF || ndi.node_class == ama::N_CALL) ) {
					//keywords are not necessarily statement starters: template<>, weird macro, label, etc.
					char[|]! name = ndi.GetName();
					if( name != NULL ) {
						if( keywords_class[name] ) {
							link_keyword = pndi;
							nd_keyword = ndi;
							kw_mode = KW_CLASS;
							continue;
						} else if( keywords_extension_clause[name] ) {
							if( nd_last_scoped_stmt ) {
								link_keyword = pndi;
								nd_keyword = ndi;
								kw_mode = KW_EXT;
								continue;
							} else if( nd_keyword && (kw_mode == KW_STMT || kw_mode == KW_EXT) ) {
								//extension of unscoped statement
								ama::Node*+! nd_ext_keyword = ama::BreakLink(pndi);
								ama::Node*+! nd_stmt = TranslateCUnscopedStatement(nd_keyword);
								nd_stmt.s = nd_ext_keyword;
								pndi = &nd_stmt.s;
								link_keyword = &nd_stmt.s;
								nd_keyword = ndi;
								kw_mode = KW_EXT;
								continue;
							} else {
								//fallback: could be `while`
							}
						}
						if( keywords_statement[name] ) {
							link_keyword = pndi;
							nd_keyword = ndi;
							kw_mode = KW_STMT;
							continue;
						} else if( keywords_function[name] ) {
							link_keyword = pndi;
							nd_keyword = ndi;
							kw_mode = KW_FUNC;
							continue;
						}
					}
				} else if( ndi.node_class == ama::N_SYMBOL && (ndi.data == "," || ndi.data == ";") ) {
					if( ndi.data == ";" && nd_keyword && (kw_mode == KW_STMT || kw_mode == KW_EXT) ) {
						//unscoped statement
						ndi_next = ama::BreakLink(&ndi.s);
						//drop the ;
						ama::BreakLink(pndi);
						ama::Node*+! nd_stmt = TranslateCUnscopedStatement(nd_keyword);
						if( kw_mode == KW_EXT && nd_last_scoped_stmt ) {
							nd_stmt.node_class = ama::N_EXTENSION_CLAUSE;
							nd_stmt.Delete();
							nd_last_scoped_stmt.Insert(ama::POS_BACK, nd_stmt);
							ndi = nd_last_scoped_stmt;
							pndi = &ndi.s;
							ndi = ndi.s;
							nd_prototype_start = ndi;
							kw_mode = KW_NONE;
							link_keyword = NULL;
							nd_keyword = NULL;
						} else {
							nd_stmt.s = ndi_next;
							nd_last_scoped_stmt = nd_stmt;
							nd_prototype_start = ndi_next;
							pndi = &nd_stmt.s;
							ndi = ndi_next;
							kw_mode = KW_NONE;
							link_keyword = NULL;
							nd_keyword = NULL;
						}
						continue;
					}
					nd_prototype_start = ndi_next;
					kw_mode = KW_NONE;
					link_keyword = NULL;
					nd_keyword = NULL;
				} else if( ndi.isRawNode('[', ']') && ndi_next && ndi_next.isRawNode('(', ')') ) {
					//C++11 lambda
					nd_prototype_start = ndi;
					kw_mode = KW_NONE;
					link_keyword = NULL;
					nd_keyword = NULL;
				} else if( (ndi.node_class == ama::N_SCOPE || ndi.isRawNode('{', '}')) && nd_prototype_start && nd_prototype_start != ndi ) {
					//console.log('lol', kw_mode);
					switch( kw_mode ) {
						case KW_CLASS: {
							//search for the class name
							ama::Node*+! nd_class_name = NULL;
							ama::Node*+*+! pnd_class_name = NULL;
							ama::Node*+*+! pndj = &nd_keyword.s;
							for(ama::Node*+! ndj = nd_keyword.s; ndj != ndi; ndj = ndj.s) {
								if( (ndj.node_class == ama::N_SYMBOL || ndj.node_class == ama::N_REF) && keywords_after_class_name[ndj.data] && nd_class_name ) {
									break;
								}
								if( ndj.node_class == ama::N_REF || ((ndj.node_class == ama::N_CALL || ndj.node_class == ama::N_CALL_TEMPLATE) && ndj.GetName() != NULL) ) {
									nd_class_name = ndj;
									pnd_class_name = pndj;
								}
								pndj = &ndj;
							}
							if( !nd_class_name ) {
								//C mode switch: struct foo{union{int bar;float baz;}}
								//it's not a declaration
								`goto not_declaration;`
							}
							if( nd_keyword.node_class == ama::N_CALL ) {
								nd_keyword = ama::UnparseCall(nd_keyword);
							}
							ama::Node*+! nd_class = ama::ReplaceChildRange(
								link_keyword,
								nd_keyword, ndi,
								ama::CreateNode(ama::N_CLASS, NULL).setData(nd_keyword.data)
							);
							//class children: whatever before, name, whatever after, body
							*pnd_class_name = NULL;
							ama::Node*+! nd_before = ama::toSingleNode(nd_keyword.s);
							ama::Node*+! nd_after = nd_class_name.s;
							nd_class_name.s = NULL;
							*pndi = NULL;
							ndi.s = NULL;
							nd_after = ama::toSingleNode(nd_after);
							nd_class.c = ama::cons(nd_before, ama::cons(nd_class_name, ama::cons(nd_after, ndi)));
							for(ama::Node*+! ndj = nd_class.c; ndj; ndj = ndj.s) {
								ndj.p = nd_class;
							}
							ndi = nd_class;
							nd_prototype_start = ndi.s;
							ndi_next = ndi.s;
							nd_keyword.s = NULL;
							nd_keyword.p = NULL;
							nd_keyword.FreeASTStorage();
							link_keyword = NULL;
							nd_keyword = NULL;
							break;
						}
						case KW_STMT: {
							//pull keyword out of raw, separate "condition" (even if it's empty) and scope
							if( nd_keyword.node_class == ama::N_CALL ) {
								nd_keyword = ama::UnparseCall(nd_keyword);
							}
							ama::Node*+! nd_stmt = ama::ReplaceChildRange(
								link_keyword,
								nd_keyword, ndi,
								ama::CreateNode(ama::N_SCOPED_STATEMENT, NULL).setData(nd_keyword.data).setCommentsBefore(nd_keyword.comments_before).setIndent(nd_keyword.indent_level)
							);
							ama::Node*+! nd_arg = ama::toSingleNode(nd_keyword.s);
							nd_arg.MergeCommentsBefore(nd_keyword);
							*pndi = NULL;
							ndi.s = NULL;
							nd_stmt.c = ama::cons(nd_arg, ndi);
							for(ama::Node*+! ndj = nd_stmt.c; ndj; ndj = ndj.s) {
								ndj.p = nd_stmt;
							}
							ndi = nd_stmt;
							nd_prototype_start = ndi.s;
							nd_keyword.s = NULL;
							nd_keyword.FreeASTStorage();
							////////
							nd_last_scoped_stmt = nd_stmt;
							pndi = &ndi.s;
							ndi = ndi.s;
							kw_mode = KW_NONE;
							link_keyword = NULL;
							nd_keyword = NULL;
							continue;
						}
						case KW_EXT: {
							if( nd_keyword.node_class == ama::N_CALL ) {
								nd_keyword = ama::UnparseCall(nd_keyword);
							}
							ama::ReplaceChildRange(
								link_keyword,
								nd_keyword, ndi,
								NULL
							);
							assert(nd_last_scoped_stmt);
							ama::Node*+! nd_arg = ama::toSingleNode(nd_keyword.s);
							nd_arg.MergeCommentsBefore(nd_keyword);
							*pndi = NULL;
							ndi.s = NULL;
							//insert into the last statement
							nd_last_scoped_stmt.Insert(ama::POS_BACK, ama::nExtensionClause(
								nd_keyword.data, nd_arg, ndi
							).setCommentsBefore(nd_keyword.comments_before).setIndent(nd_keyword.indent_level));
							nd_keyword.s = NULL;
							nd_keyword.FreeASTStorage();
							ndi = nd_last_scoped_stmt;
							pndi = &ndi.s;
							ndi = ndi.s;
							nd_prototype_start = ndi;
							kw_mode = KW_NONE;
							link_keyword = NULL;
							nd_keyword = NULL;
							continue;
						}
						case KW_FUNC: default: {
							//it's not necessarily a declaration, detect C / C++11 / Java / etc. keywordless functions
							//what else could it be? C/C++ initializer list, new (which could have (){} for JC)
							//use (){} as indicator: we could drag back those misidentified functions later
							//if we had a keyword, we won't have a C-like return type
							if( !nd_keyword ) {
								nd_keyword = nd_prototype_start;
							} else if( nd_keyword.node_class == ama::N_CALL ) {
								//the unparsing always creates a paramlist
								nd_keyword = ama::UnparseCall(nd_keyword);
							}
							ama::Node*+! nd_paramlist = NULL;
							for(ama::Node*+! ndj = nd_keyword.s; ndj != ndi; ndj = ndj.s) {
								if( ndj.isRawNode('(', ')') || ndj.node_class == ama::N_CALL ) {
									nd_paramlist = ndj;
								} else if( ndj.node_class == ama::N_SYMBOL && keywords_after_prototype[ndj.data] ) {
									break;
								} else if( parse_cpp11_lambda && ndj.isRawNode('[', ']') && ndj.s.isRawNode('(', ')') ) {
									nd_paramlist = ndj.s;
									break;
								}
							}
							if( !nd_paramlist ) {
								`goto not_declaration;`
							}
							if( nd_paramlist.node_class == ama::N_CALL ) {
								nd_paramlist = ama::UnparseCall(nd_paramlist).s;
							}
							//keyworded function shouldn't have any junk before... but C++ function has both junk before and junk after
							//before (C++ return type plus junk plus name, or just a name), paramlist, after, body, figure out return type separately
							ama::Node*+! nd_func = ama::ReplaceChildRange(
								link_keyword,
								nd_keyword, ndi,
								ama::CreateNode(ama::N_FUNCTION, NULL)
							);
							ama::Node*+! nd_before = nd_keyword;
							if( nd_before == nd_paramlist ) {
								nd_before = ama::CreateNode(ama::N_RAW, NULL);
							}
							ama::Node*+! nd_after = nd_paramlist.s;
							if( nd_after == ndi ) {
								nd_after = ama::CreateNode(ama::N_RAW, NULL);
							}
							ama::Node*+*+! pndj = NULL;
							for(ama::Node*+! ndj = nd_keyword;; ndj = ndj.s) {
								if( ndj == nd_paramlist ) {
									*pndj = NULL;
								} else if( ndj == ndi ) {
									*pndj = NULL;
									break;
								}
								pndj = &ndj.s;
							}
							//nd_paramlist.Delete();
							//ndi.Delete();
							nd_paramlist = ConvertToParameterList(nd_paramlist);
							nd_before = ama::toSingleNode(nd_before);
							nd_after = ama::toSingleNode(nd_after);
							nd_func.c = ama::cons(nd_before, ama::cons(nd_paramlist, ama::cons(nd_after, ndi)));
							for(ama::Node*+! ndj = nd_func.c; ndj; ndj = ndj.s) {
								ndj.p = nd_func;
							}
							nd_func.data = GetFunctionName(kw_mode == KW_FUNC, nd_func);
							ndi = nd_func;
							nd_prototype_start = ndi.s;
							ndi_next = ndi.s;
							break;
						}
					}
					kw_mode = KW_NONE;
					link_keyword = NULL;
					nd_keyword = NULL;
					`not_declaration:;`
				}
				if( !(kw_mode == KW_EXT && nd_keyword) ) {
					nd_last_scoped_stmt = NULL;
				}
				pndi = &ndi.s;
				ndi = ndi_next;
			}
			if( nd_keyword && (kw_mode == KW_STMT || kw_mode == KW_EXT) ) {
				//C unscoped statement
				ama::Node*+! nd_stmt = TranslateCUnscopedStatement(nd_keyword);
				if( kw_mode == KW_EXT && nd_last_scoped_stmt ) {
					nd_stmt.node_class = ama::N_EXTENSION_CLAUSE;
					nd_stmt.Delete();
					nd_last_scoped_stmt.Insert(ama::POS_BACK, nd_stmt);
				}
			} else if( kw_mode == KW_FUNC && nd_keyword && parse_c_forward_declarations ) {
				//C forward declaration with extern
				TranslateCForwardDeclaration(nd_raw);
				//note that extern is not necessarily function... we may have extern "C"{}
			}
		}
		//C forward declaration
		if( parse_c_forward_declarations ) {
			for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
				//have to rely on context? we can do Owner tests here 
				ama::Node*+! nd_owner = nd_raw.Owner();
				if( !(nd_raw.p && (nd_raw.p.node_class == ama::N_SCOPE || nd_raw.p.node_class == ama::N_FILE)) || nd_owner.node_class == ama::N_FUNCTION ) { continue; }
				ama::Node*+! nd_proto = NULL;
				//console.log('>>>', nd_raw.toSource());
				for(ama::Node*+! ndi = nd_raw.c; ndi; ndi = ndi.s) {
					//console.log(ndi.node_class)
					if( ndi.node_class == ama::N_CALL ) {
						nd_proto = ndi;
					}
					if( ndi.node_class == ama::N_SCOPE ) {
						nd_proto = NULL;
						break;
					}
				}
				if( !nd_proto ) { continue; }
				if( !nd_raw.c.s && nd_proto.c.node_class != ama::N_CALL ) {
					//ignore just-a-call, but allow::
					//FOO_DECL(int,foo)(int bar);
					continue;
				}
				TranslateCForwardDeclaration(nd_raw);
			}
		}
		/////////
		//don't set REF_WRITTEN for function / class names: it's not profitable to treat them as "written" in our current AST formulation
		return nd_root;
	}
	//detects N_TYPED_VAR
	//also sets REF_WRITTEN and REF_RW
	//after ParseAssignment
	ama::Node*+! ParseVariableDeclarations(ama::Node*+! nd_root, JSValue! options) {
		Map<char[|], int>! ambiguous_type_suffix = ama::GetPrioritizedList(options, "ambiguous_type_suffix");
		//if templates weren't parsed, we won't get N_CALL_TEMPLATE anyway
		//turn params into N_ASSIGNMENT
		for(ama::Node*&! nd_paramlist : nd_root.FindAll(ama::N_PARAMETER_LIST, NULL).concat(nd_root.FindAll(ama::N_CALL_TEMPLATE, 'template'))) {
			for(ama::Node*+! nd_param = nd_paramlist.node_class == ama::N_CALL_TEMPLATE ? nd_paramlist.c.s : nd_paramlist.c; nd_param; nd_param = nd_param.s) {
				if( nd_param.node_class == ama::N_ASSIGNMENT ) { continue; }
				if( nd_param.node_class == ama::N_SYMBOL || (nd_param.node_class == ama::N_RAW && nd_param.c && nd_param.c.node_class == ama::N_SYMBOL) ) {
					//rest args
					continue;
				}
				ama::Node*+! nd_tmp = ama::GetPlaceHolder();
				nd_param.ReplaceWith(nd_tmp);
				nd_param = nd_tmp.ReplaceWith(ama::nAssignment(nd_param, ama::nAir()));
			}
		}
		for(ama::Node*&! nd_asgn : nd_root.FindAll(ama::N_ASSIGNMENT, NULL)) {
			ama::Node*+! nd_def = nd_asgn.c;
			if( nd_def.node_class == ama::N_RAW ) {
				nd_def = nd_def.LastChild();
			}
			if( nd_def.node_class == ama::N_BINOP && ambiguous_type_suffix[nd_def.data] ) {
				//type-binop ambiguity: foo*[3]*b=bar*[3]*b
				//a sane method to resolve such ambiguity: LHS of assignment, in a function prototype... and it's C-specific
				//makes sense to put in a separate pass! and maybe unify the situations to "LHS of assignment" first
				nd_def = ama::UnparseBinop(nd_def);
				assert(nd_def.s.node_class == ama::N_SYMBOL);
				//avoid space before type suffix
				nd_def.s.comments_before = "";
				while( nd_def.s ) {
					nd_def = nd_def.s;
				}
			}
			if( nd_def.node_class == ama::N_REF ) {
				nd_def.flags |= ama::REF_WRITTEN;
				if( nd_asgn.data != NULL ) {
					nd_def.flags |= ama::REF_RW;
				}
				if( nd_def.p && nd_def.p.node_class == ama::N_RAW && nd_def != nd_def.p.c ) {
					ama::Node*+! nd_raw = nd_def.p;
					nd_def.Delete();
					ama::Node*+! nd_tmp = ama::GetPlaceHolder();
					nd_raw.ReplaceWith(nd_tmp);
					nd_tmp.ReplaceWith(ama::nTypedVar(nd_raw, nd_def));
				}
			}
		}
		return nd_root;
	}
};
