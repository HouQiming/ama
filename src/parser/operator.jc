// //// JC version: 3
//#include <console.jch>
#include '../ast/node.jch'
#include "../script/jsenv.jch"
#include "./operator.jch"

namespace ama {
	private class ColonStackItem {
		ama::Node*+*+! phead = NULL;
		ama::Node*+*+! pqmark = NULL;
		ama::Node*+*+! pcolon = NULL;
	};
	private ama::Node*+*+! FoldColonStack(ColonStackItem![+]&+! cstk, ama::Node*+*+! pnext) {
		assert(cstk.back().pcolon);
		ama::Node*+*+! phead = cstk.back().phead;
		//console.log(cstk.length, phead);
		ama::Node*+! nd_parent = (*phead).p;
		ama::Node*+! nd_next = ama::BreakLink(pnext);
		ama::Node*+! nd_colon = ama::BreakLink(cstk.back().pcolon);
		ama::Node*+! nd_ret = NULL;
		if( cstk.back().pqmark ) {
			//N_CONDITIONAL
			ama::Node*+! nd_qmark = ama::BreakLink(cstk.back().pqmark);
			ama::Node*+! nd_head = ama::BreakLink(phead);
			ama::Node*+! nd_cond = ama::toSingleNode(nd_head);
			ama::Node*+! nd_true = ama::toSingleNode(nd_qmark.s);
			ama::Node*+! nd_false = ama::toSingleNode(nd_colon.s);
			nd_cond.MergeCommentsAfter(nd_qmark);
			nd_true.MergeCommentsBefore(nd_qmark);
			nd_true.MergeCommentsAfter(nd_colon);
			nd_false.MergeCommentsBefore(nd_colon);
			nd_ret = ama::nConditional(nd_cond, nd_true, nd_false);
			nd_qmark.p = NULL; nd_qmark.FreeASTStorage();
			nd_colon.p = NULL; nd_colon.FreeASTStorage();
		} else {
			//N_LABELED
			ama::Node*+! nd_head = ama::BreakLink(phead);
			ama::Node*+! nd_label = ama::toSingleNode(nd_head);
			ama::Node*+! nd_value = ama::toSingleNode(nd_colon.s);
			nd_label.MergeCommentsAfter(nd_colon);
			nd_value.MergeCommentsBefore(nd_colon);
			nd_ret = ama::nLabeled(nd_label, nd_value);
			nd_colon.p = NULL; nd_colon.FreeASTStorage();
		}
		*phead = nd_ret;
		nd_ret.p = nd_parent;
		nd_ret.s = nd_next;
		cstk.pop();
		if( !cstk.length ) {
			cstk.push(new ColonStackItem!{
				phead: phead
			});
		}
		return &nd_ret.s;
	}
	ama::Node*+! ParseColons(ama::Node*+! nd_root, int! has_c_conditional) {
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			ColonStackItem![+]! cstk;
			cstk.push(new ColonStackItem!{
				phead: &nd_raw.c
			});
			ama::Node*+*+! pndi = &nd_raw.c;
			for(ama::Node*+! ndi = nd_raw.c; ndi; (pndi = &ndi.s, ndi = ndi.s)) {
				if( has_c_conditional && ndi.isSymbol("?") ) {
					assert(cstk.length > 0);
					if( cstk.back().pcolon ) {
						// foo?bar:baz? /*we are here*/
						// bar:baz? /*we are here*/
						// 1?1:0?2:3 == 1?1:(0?2:3) - here we need to create a new conditional
						ama::Node*+! nd_colon = cstk.back().pcolon[0];
						assert(nd_colon);
						cstk.push(new ColonStackItem!{
							phead: &nd_colon->s,
							pqmark: pndi
						});
					} else if( cstk.back().pqmark ) {
						//again, create a new conditional
						ama::Node*+! nd_qmark = cstk.back().pqmark[0];
						assert(nd_qmark);
						cstk.push(new ColonStackItem!{
							phead: &nd_qmark->s,
							pqmark: pndi
						});
					} else {
						cstk.back().pqmark = pndi;
					}
				} else if( ndi.isSymbol(":") ) {
					assert(cstk.length > 0);
					while( cstk.back().pcolon ) {
						assert(cstk.length > 0);
						pndi = FoldColonStack(cstk, pndi);
					}
					//conditional -- foo?bar:
					//label -- bar:
					//both only involves setting pcolon
					cstk.back().pcolon = pndi;
				}
			}
			while( cstk.length ) {
				if( cstk.back().pcolon ) {
					FoldColonStack(cstk, pndi);
				} else {
					cstk.pop();
				}
			}
		}
		return nd_root;
	}
	ama::Node*+! ParseAssignment(ama::Node*+! nd_root, JSValueConst! options) {
		Map<char[|], int>! binop_priority = ama::GetPrioritizedList(options, 'binary_operators');
		ama::Node*+[+]! Q = nd_root.FindAll(ama::N_RAW, NULL);
		for(intptr_t! i = 0; i < Q.length; i++) {
			ama::Node*+! nd_raw = Q[i];
			ama::Node*+! ndi = nd_raw.c;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( ndi_next && ndi_next.s && 
				ndi_next.isSymbol("=") ) {
					ama::Node*+! ndi_next_next = ndi_next.s;
					//move the comments
					ndi.MergeCommentsAfter(ndi_next);
					ndi_next.Delete();
					ama::Node*+! nd_value = ndi_next_next.s ? ama::CreateNode(ama::N_RAW, ndi_next_next) : ndi_next_next;
					nd_value.comments_before = ndi_next_next.comments_before;
					ndi_next_next.comments_before = '';
					nd_value.MergeCommentsBefore(ndi_next);
					nd_value.indent_level = ndi_next_next.indent_level;
					ama::Node*+! nd_tmp = ama::GetPlaceHolder();
					nd_raw.ReplaceWith(nd_tmp);
					ndi.s = NULL;
					ama::Node*+! nd_asgn = nd_tmp.ReplaceWith(ama::nAssignment(nd_raw, nd_value));
					if( ndi.node_class == ama::N_SYMBOL && binop_priority[ndi.data] && ndi != nd_raw.c ) {
						//updating assignment
						ndi.Delete();
						nd_asgn.data = ndi.DestroyForSymbol();
					}
					if( ndi_next_next.s ) {
						//detect nested assignment
						Q.push_back(nd_value);
					}
					ndi_next.FreeASTStorage();
					break;
				}
				ndi = ndi_next;
			}
		}
		return nd_root;
	}
	//COULDDO: lazy parsing with OwningUnparsedExpr  
	private int! FoldBinop(Map<char[|], int>&! binop_priority, ama::Node*+[+]&+! stack, int! pr) {
		int! changed = 0;
		while( stack.length >= 3 && stack.back().node_class != ama::N_SYMBOL && 
		stack[stack.length - 2].node_class == ama::N_SYMBOL && stack[stack.length - 3].node_class != ama::N_SYMBOL && 
		binop_priority[stack[stack.length - 2].data] >= pr ) {
			//fold high priority binop
			ama::Node*+! nd_last_operator = stack[stack.length - 2];
			ama::Node*+! nd_folded = ama::nBinop(
				stack[stack.length - 3].MergeCommentsAfter(nd_last_operator),
				nd_last_operator.data,
				stack[stack.length - 1].MergeCommentsBefore(nd_last_operator)
			);
			nd_last_operator.p = NULL;
			nd_last_operator.FreeASTStorage();
			stack.pop();
			stack.pop();
			stack[stack.length - 1] = nd_folded;
			changed = 1;
		}
		return changed;
	}
	ama::Node*+! ParseOperators(ama::Node*+! nd_root, JSValueConst! options) {
		Map<char[|], int>! binop_priority = ama::GetPrioritizedList(options, 'binary_operators');
		Map<char[|], int>! prefix_ops = ama::GetPrioritizedList(options, 'prefix_operators');
		Map<char[|], int>! postfix_ops = ama::GetPrioritizedList(options, 'postfix_operators');
		Map<char[|], int>! named_ops = ama::GetPrioritizedList(options, 'named_operators');
		//named operators: convert refs to symbols
		for(ama::Node*&+! nd_ref : nd_root.FindAll(ama::N_REF, NULL)) {
			if( named_ops[nd_ref.data] ) {
				nd_ref.node_class = ama::N_SYMBOL;
			}
		}
		//sentenial operand
		//we need to leave uninterpreted structures alone
		//reverse() to fold smaller raws first
		for(ama::Node*&+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL).reverse()) {
			//binary and unary in one pass
			ama::Node*+[+]! stack = new ama::Node*+[+]!();
			//ama::Node*+! nd_raw = Q[i];
			ama::Node*+! ndi = nd_raw.c;
			int! changed = 0;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( ndi.node_class == ama::N_SYMBOL ) {
					int! pr = 0x7fffffff;
					if( postfix_ops[ndi.data] && stack.length > 0 && stack.back().node_class != ama::N_SYMBOL ) {
						//precedence problem - need to replace the prefix-core instead
						ama::Node*+! nd_operand = stack.pop();
						ama::Node*+! nd_prefix_core = nd_operand;
						while( nd_prefix_core.node_class == ama::N_UNARY && !(nd_prefix_core.flags & ama::UNARY_POSTFIX) ) {
							nd_prefix_core = nd_prefix_core.c;
						}
						ama::Node*+! nd_tmp = ama::GetPlaceHolder();
						if( nd_prefix_core != nd_operand ) {
							nd_prefix_core.ReplaceWith(nd_tmp);
						}
						ama::Node*+! nd_unary = ama::nUnaryPostfix(nd_prefix_core.MergeCommentsAfter(ndi), ndi.data);
						ndi.p = NULL;
						ndi.FreeASTStorage();
						if( nd_prefix_core != nd_operand ) {
							nd_tmp.ReplaceWith(nd_unary);
						} else {
							nd_operand = nd_unary;
						}
						stack.push_back(nd_operand);
						ndi = ndi_next;
						changed = 1;
						continue;
					} else {
						pr = binop_priority[ndi.data];
						if( pr ) {
							//flush >=pr
							changed |= FoldBinop(binop_priority, stack, pr);
						} else {
							//separator: ; or , or ...
							changed |= FoldBinop(binop_priority, stack, 1);
						}
					}
				} else {
					//operand, fold prefix
					while( stack.length >= 1 && stack.back().node_class == ama::N_SYMBOL && prefix_ops[stack.back().data] ) {
						if( stack.length >= 2 && stack[stack.length - 2].node_class != ama::N_SYMBOL && binop_priority[stack.back().data] ) {
							//prefix-binary ambiguity: assume binary
							break;
						}
						ama::Node*+! nd_prefix_operator = stack.pop();
						ndi = ama::nUnary(nd_prefix_operator.data, ndi);
						nd_prefix_operator.p = NULL;
						nd_prefix_operator.FreeASTStorage();
						changed = 1;
					}
				}
				stack.push_back(ndi);
				ndi = ndi_next;
			}
			//fold remaining binops
			changed |= FoldBinop(binop_priority, stack, 1);
			if( changed ) {
				if( stack.length == 1 && !(nd_raw.flags & 0xffff) ) {
					nd_raw.ReplaceWith(stack[0]);
					nd_raw.c = NULL;
					nd_raw.FreeASTStorage();
				} else {
					//we still have uninterpreted things, replace children
					assert(stack.length > 1);
					for(ama::Node*&+! ndi : stack) {
						ndi.p = nd_raw;
					}
					ama::Node*+! nd_new_child = ama::InsertMany(stack);
					nd_raw.c = nd_new_child;
				}
			}
		}
		//convert named unary ops to call
		for(ama::Node*&+! nd_unary : nd_root.FindAll(ama::N_UNARY, NULL)) {
			if( named_ops[nd_unary.data] && !(nd_unary.flags & ama::UNARY_POSTFIX) ) {
				if( nd_unary.c && nd_unary.c.comments_before == " " ) {
					nd_unary.c.comments_before = '';
				}
				nd_unary.ReplaceWith(ama::CreateNode(ama::N_CALL, ama::cons(ama::nRef(nd_unary.data), nd_unary.c)));
				nd_unary.c = NULL;
				nd_unary.FreeASTStorage();
			}
		}
		//convert failed-to-fold named ops back
		for(ama::Node*&+! nd_ref : nd_root.FindAll(ama::N_SYMBOL, NULL)) {
			if( named_ops[nd_ref.data] ) {
				nd_ref.node_class = ama::N_REF;
			}
		}
		return nd_root;
	}
	ama::Node*+! ParsePointedBrackets(ama::Node*+! nd_root) {
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			//actually split it
			ama::Node*+*+[+]! stack = new ama::Node*+*+[+]!();
			ama::Node*+*+! p_self = &nd_raw.c;
			int! was_ref = 0;
			for(ama::Node*+! ndi = nd_raw.c; ndi; ndi = ndi.s) {
				if( ndi.node_class == ama::N_SYMBOL ) {
					if( was_ref && ndi.data == "<" ) {
						stack.push_back(p_self);
					} else if( (ndi.data == ">" || ndi.data == ">>" || ndi.data == ">>>") && stack.length >= ndi.data.length ) {
						for(int! j = 0; j < ndi.data.length; j += 1) {
							ama::Node*+*+! p_ndi0 = stack.pop();
							ama::Node*+! ndi0 = *p_ndi0;
							*p_self = NULL;
							ama::Node*+! nd_child = ama::CreateNode(ama::N_RAW, ndi0.s);
							nd_child.flags = uint32_t('<') | uint32_t('>') << 8;
							nd_child.s = ndi.s;
							nd_child.p = nd_raw;
							*p_ndi0 = nd_child;
							p_self = &nd_child.s;
						}
						was_ref = 0;
						continue;
					} else if( ndi.data == '||' || ndi.data == '&&' ) {
						stack.clear();
					}
				}
				was_ref = ndi.node_class == ama::N_REF;
				p_self = &ndi.s;
			}
		}
		return nd_root;
	}
	ama::Node*+! UnparseBinop(ama::Node*+! nd_binop) {
		ama::Node*+! nd_parent = nd_binop.p;
		if( !nd_parent || nd_parent.node_class != ama::N_RAW ) {
			nd_parent = nd_binop.ReplaceWith(ama::CreateNode(ama::N_RAW, NULL));
			nd_parent.c = nd_binop;
			nd_binop.p = nd_parent;
			nd_parent.indent_level = nd_binop.indent_level;
		}
		ama::Node*+! nd_a = nd_binop.c;
		ama::Node*+! nd_b = nd_binop.c.s;
		//.setCommentsBefore(nd_binop.data == ":" ? "" : " ").setCommentsAfter(" ")
		ama::Node*+! ret = nd_binop.ReplaceWith(ama::cons(nd_a, ama::cons(ama::nSymbol(nd_binop.data), nd_b)));
		if( nd_a.isRawNode(0, 0) ) {
			ama::UnparseRaw(nd_a);
		}
		if( nd_b.isRawNode(0, 0) ) {
			ama::UnparseRaw(nd_b);
		}
		nd_binop.c = NULL;
		nd_binop.FreeASTStorage();
		return ret;
	}
	ama::Node*+! UnparseLabel(ama::Node*+! nd_label) {
		assert(nd_label.node_class == ama::N_LABELED);
		nd_label.node_class = ama::N_BINOP;
		nd_label.data = ":";
		return UnparseBinop(nd_label);
	}
};
