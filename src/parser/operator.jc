// //// JC version: 3
#include '../ast/node.jch'
#include "../script/jsenv.jch"
#include "./operator.jch"

namespace ama {
	private Map<char[|], int>! GetOperatorSet(JSValueConst! options, char*! name) {
		char[|]! s_binops = ama::UnwrapString(JS_GetPropertyStr(ama::jsctx, options, name));
		Map<char[|], int>! ret = new Map<char[|], int>!();
		int! priority = 1;
		for(char[...]&! s_binop : s_binops.split(' ')) {
			if( s_binop.endsWith('\n') ) {
				ret[new char[|]!(s_binop.subarray(0, s_binop.length - 1))] = priority;
				priority += 1;
			} else {
				ret[new char[|]!(s_binop)] = priority;
			}
		}
		return <<ret;
	}
	ama::Node*+! ParseAssignment(ama::Node*+! nd_root, JSValueConst! options) {
		Map<char[|], int>! binop_priority = GetOperatorSet(options, 'binary_operators');
		ama::Node*+[+]! Q = nd_root.FindAll(ama::N_RAW, NULL);
		for(intptr_t! i = 0; i < Q.length; i++) {
			ama::Node*+! nd_raw = Q[i];
			ama::Node*+! ndi = nd_raw.c;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( ndi_next && ndi_next.s && 
				ndi_next.node_class == ama::N_SYMBOL && ndi_next.data == "=" ) {
					ama::Node*+! @nojson ndi_next_next = ndi_next.s;
					//move the comments
					ndi.MergeCommentsAfter(ndi_next);
					ndi_next.Delete();
					ama::Node*+! nd_value = ndi_next_next.s ? ama::CreateNode(ama::N_RAW, ndi_next_next) : ndi_next_next;
					nd_value.comments_before = ndi_next_next.comments_before;
					ndi_next_next.comments_before = '';
					nd_value.MergeCommentsBefore(ndi_next);
					nd_value.indent_level = ndi_next_next.indent_level;
					ama::Node*+! nd_tmp = ama::GetPlaceHolder();
					nd_raw.ReplaceWith(nd_tmp);
					ndi.s = NULL;
					ama::Node*+! nd_asgn = nd_tmp.ReplaceWith(ama::nAssignment(nd_raw, nd_value));
					if( ndi.node_class == ama::N_SYMBOL && binop_priority[ndi.data] && ndi != nd_raw.c ) {
						//updating assignment
						ndi.Delete();
						nd_asgn.data = ndi.DestroyForSymbol();
					}
					if( ndi_next_next.s ) {
						//detect nested assignment
						Q.push_back(nd_value);
					}
					ndi_next.FreeASTStorage();
					break;
				}
				ndi = ndi_next;
			}
		}
		return nd_root;
	}
	//COULDDO: lazy parsing with OwningUnparsedExpr  
	private int! FoldBinop(Map<char[|], int>&! binop_priority, ama::Node*+[+]&+! stack, int! pr) {
		int! changed = 0;
		while( stack.length >= 3 && stack.back().node_class != ama::N_SYMBOL && 
		stack[stack.length - 2].node_class == ama::N_SYMBOL && stack[stack.length - 3].node_class != ama::N_SYMBOL && 
		binop_priority[stack[stack.length - 2].data] >= pr ) {
			//fold high priority binop
			ama::Node*+! nd_last_operator = stack[stack.length - 2];
			ama::Node*+! nd_folded = ama::nBinop(
				stack[stack.length - 3].MergeCommentsAfter(nd_last_operator),
				nd_last_operator.data,
				stack[stack.length - 1].MergeCommentsBefore(nd_last_operator)
			);
			nd_last_operator.p = NULL;
			nd_last_operator.FreeASTStorage();
			stack.pop();
			stack.pop();
			stack[stack.length - 1] = nd_folded;
			changed = 1;
		}
		return changed;
	}
	ama::Node*+! ParseOperators(ama::Node*+! nd_root, JSValueConst! options) {
		Map<char[|], int>! binop_priority = GetOperatorSet(options, 'binary_operators');
		Map<char[|], int>! prefix_ops = GetOperatorSet(options, 'prefix_operators');
		Map<char[|], int>! postfix_ops = GetOperatorSet(options, 'postfix_operators');
		Map<char[|], int>! named_ops = GetOperatorSet(options, 'named_operators');
		//named operators: convert refs to symbols
		for(ama::Node*&+! nd_ref : nd_root.FindAll(ama::N_REF, NULL)) {
			if( named_ops[nd_ref.data] ) {
				nd_ref.node_class = ama::N_SYMBOL;
			}
		}
		ama::Node*+[+]! Q = nd_root.FindAll(ama::N_RAW, NULL);
		//sentenial operand
		//we need to leave uninterpreted structures alone
		for(intptr_t! i = 0; i < Q.length; i++) {
			//binary and unary in one pass
			ama::Node*+[+]! stack = new ama::Node*+[+]!();
			ama::Node*+! nd_raw = Q[i];
			ama::Node*+! ndi = nd_raw.c;
			int! changed = 0;
			while( ndi ) {
				ama::Node*+! @nojson ndi_next = ndi.s;
				if( ndi.node_class == ama::N_SYMBOL ) {
					int! pr = 0x7fffffff;
					if( postfix_ops[ndi.data] && stack.length > 0 && stack.back().node_class != ama::N_SYMBOL ) {
						//precedence problem - need to replace the prefix-core instead
						ama::Node*+! nd_operand = stack.pop();
						ama::Node*+! nd_prefix_core = nd_operand;
						while( nd_prefix_core.node_class == ama::N_UNARY && !(nd_prefix_core.flags & ama::UNARY_POSTFIX) ) {
							nd_prefix_core = nd_prefix_core.c;
						}
						ama::Node*+! nd_tmp = ama::GetPlaceHolder();
						if( nd_prefix_core != nd_operand ) {
							nd_prefix_core.ReplaceWith(nd_tmp);
						}
						ama::Node*+! nd_unary = ama::nUnaryPostfix(nd_prefix_core.MergeCommentsAfter(ndi), ndi.data);
						ndi.p = NULL;
						ndi.FreeASTStorage();
						if( nd_prefix_core != nd_operand ) {
							nd_tmp.ReplaceWith(nd_unary);
						} else {
							nd_operand = nd_unary;
						}
						stack.push_back(nd_operand);
						ndi = ndi_next;
						changed = 1;
						continue;
					} else {
						pr = binop_priority[ndi.data];
						if( pr ) {
							//flush >=pr
							changed |= FoldBinop(binop_priority, stack, pr);
						} else {
							//separator: ; or , or ...
							changed |= FoldBinop(binop_priority, stack, 1);
						}
					}
				} else {
					//operand, fold prefix
					while( stack.length >= 1 && stack.back().node_class == ama::N_SYMBOL && prefix_ops[stack.back().data] ) {
						if( stack.length >= 2 && stack[stack.length - 2].node_class != ama::N_SYMBOL && binop_priority[stack.back().data] ) {
							//prefix-binary ambiguity: assume binary
							break;
						}
						ama::Node*+! nd_prefix_operator = stack.pop();
						ndi = ama::nUnary(nd_prefix_operator.data, ndi);
						nd_prefix_operator.p = NULL;
						nd_prefix_operator.FreeASTStorage();
						changed = 1;
					}
				}
				stack.push_back(ndi);
				ndi = ndi_next;
			}
			//fold remaining binops
			changed |= FoldBinop(binop_priority, stack, 1);
			if( changed ) {
				if( stack.length == 1 && !(nd_raw.flags & 0xffff) ) {
					nd_raw.ReplaceWith(stack[0]);
					nd_raw.c = NULL;
					nd_raw.FreeASTStorage();
				} else {
					//we still have uninterpreted things, replace children
					assert(stack.length > 1);
					for(ama::Node*&+! ndi : stack) {
						ndi.p = nd_raw;
					}
					ama::Node*+! nd_new_child = ama::InsertMany(stack);
					nd_raw.c = nd_new_child;
				}
			}
		}
		//convert named unary ops to call
		for(ama::Node*&+! nd_unary : nd_root.FindAll(ama::N_UNARY, NULL)) {
			if( named_ops[nd_unary.data] && !(nd_unary.flags & ama::UNARY_POSTFIX) ) {
				if( nd_unary.c && nd_unary.c.comments_before == " " ) {
					nd_unary.c.comments_before = '';
				}
				nd_unary.ReplaceWith(ama::CreateNode(ama::N_CALL, ama::cons(ama::nRef(nd_unary.data), nd_unary.c)));
				nd_unary.c = NULL;
				nd_unary.FreeASTStorage();
			}
		}
		//TODO: sizeof bug
		//convert failed-to-fold named ops back
		for(ama::Node*&+! nd_ref : nd_root.FindAll(ama::N_SYMBOL, NULL)) {
			if( named_ops[nd_ref.data] ) {
				nd_ref.node_class = ama::N_REF;
			}
		}
		return nd_root;
	}
	ama::Node*+! ParsePointedBrackets(ama::Node*+! nd_root) {
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			//actually split it
			ama::Node*+*+[+]! stack = new ama::Node*+*+[+]!();
			ama::Node*+*+! p_self = &nd_raw.c;
			int! was_ref = 0;
			for(ama::Node*+! ndi = nd_raw.c; ndi; ndi = ndi.s) {
				if( ndi.node_class == ama::N_SYMBOL ) {
					if( was_ref && ndi.data == "<" ) {
						stack.push_back(p_self);
					} else if( (ndi.data == ">" || ndi.data == ">>" || ndi.data == ">>>") && stack.length >= ndi.data.length ) {
						for(int! j = 0; j < ndi.data.length; j += 1) {
							ama::Node*+*+! p_ndi0 = stack.pop();
							ama::Node*+! ndi0 = *p_ndi0;
							*p_self = NULL;
							ama::Node*+! nd_child = ama::CreateNode(ama::N_RAW, ndi0.s);
							nd_child.flags = uint32_t('<') | uint32_t('>') << 8;
							nd_child.s = ndi.s;
							nd_child.p = nd_raw;
							*p_ndi0 = nd_child;
							p_self = &nd_child.s;
						}
						was_ref = 0;
						continue;
					} else if( ndi.data == '||' || ndi.data == '&&' ) {
						stack.clear();
					}
				}
				was_ref = ndi.node_class == ama::N_REF;
				p_self = &ndi.s;
			}
		}
		return nd_root;
	}
	//TODO: weird stuff - C ?:
	//type-binop ambiguity: foo*[3]*b=bar*[3]*b
	//a sane method to resolve such ambiguity: LHS of assignment, in a function prototype... and it's C-specific
	//makes sense to put in a separate pass! and maybe unify the situations to "LHS of assignment" first
	//TODO: type-binop ambiguity resolution
};
