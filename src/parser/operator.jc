// //// JC version: 3
#include '../ast/node.jch'
#include "../script/jsenv.jch"
#include './depends.jch'

namespace ama {
	Map<char[|],int>! GetOperatorSet(JSValueConst! options,char* name)
		char[|]! s_binops = ama::UnwrapString(JS_GetPropertyStr(ama::jsctx, options, name));
		ret=new Map<char[|],int>!
		int priority=1
		for(char[...]&! s_binop : s_binops.split(' ')) {
			if s_binop.endsWith('\n')
				ret[new char[|](s_binop.subarray(0,s_binop.length-1))]=priority
				priority+=1
			else
				ret[new char[|](s_binop)]=priority
		}
		return <<ret
	ama::Node*+! ParseAssignment(ama::Node*+! nd_root, JSValueConst! options) {
		binop_priority=GetOperatorSet(options,'binary_operators')
		Q=nd_root.FindAll(ama::N_RAW, NULL)
		for(intptr_t i=0;i<Q.length;i++) {
			ama::Node*+! nd_raw=Q[i]
			ama::Node*+! ndi = nd_raw.c;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if (ndi_next&&ndi_next.s&&
				ndi_next.node_class==N_SYMBOL&&ndi_next.data=="="&&
				!(ndi.node_class==N_SYMBOL&&binop_priority[ndi.data])):
					//handle updating operators in ParseOperators instead
					ndi_next_next=ndi_next.s
					//move the comments
					ndi.comments_after=new char[|](ndi.comments_after+ndi_next.comments_before)
					ndi_next.Delete()
					nd_value=ndi_next_next.s?CreateNode(N_RAW,ndi_next_next):ndi_next_next
					nd_value.comments_before=new char[|](ndi_next.comments_after+ndi_next_next.comments_before)
					nd_value.indent_level=ndi_next_next.indent_level
					ndi_next_next.comments_before=''
					nd_tmp=GetPlaceHolder()
					nd_raw.ReplaceWith(nd_tmp)
					nd_tmp.ReplaceWith(nAssignment(nd_raw,nd_value))
					if ndi_next_next.s:
						//detect nested assignment
						Q.push_back(nd_value)
					break
				ndi=ndi_next
			}
		}
		return nd_root
	}
	//COULDDO: lazy parsing with OwningUnparsedExpr  
	ama::Node*+! ParseOperators(ama::Node*+! nd_root, JSValueConst! options) {
		binop_priority=GetOperatorSet(options,'binary_operators')
		prefix_ops=GetOperatorSet(options,'prefix_operators')
		postfix_ops=GetOperatorSet(options,'postfix_operators')
		named_ops=GetOperatorSet(options,'named_operators')
		//named operators: convert refs to symbols
		for nd_ref in nd_root.FindAll(N_REF,NULL)
			if named_ops[nd_ref.data]:
				nd_ref.node_class=N_SYMBOL
		Q=nd_root.FindAll(ama::N_RAW, NULL)
		//sentenial operand
		//we need to leave uninterpreted structures alone
		for(intptr_t i=0;i<Q.length;i++) {
			//binary and unary in one pass
			stack=new Node*+[+]
			ama::Node*+! nd_raw=Q[i]
			ama::Node*+! ndi = nd_raw.c;
			changed=0
			while( ndi ) {
				if ndi.node_class==N_SYMBOL:
					int pr=0x7fffffff;
					if postfix_ops[ndi.data]&&stack.length>0&&stack.back().node_class!=N_SYMBOL:
						nd_unary=nUnaryPostfix(stack.pop().MergeCommentsAfter(ndi),ndi.data)
						ndi.FreeASTStorage
						stack.push_back(nd_unary)
						ndi=ndi_next
						changed=1
						continue
					else if (pr=binop_priority[ndi.data]):
						//flush >=pr
						while (stack.length>=3&&stack.back().node_class!=N_SYMBOL&&
						stack[stack.length-2].node_class==N_SYMBOL&&stack[stack.length-3].node_class!=N_SYMBOL&&
						binop_priority[stack[stack.length-2].data]>=pr):
							//fold high priority binop
							nd_last_operator=stack[stack.length-2]
							nd_folded=nBinop(
								stack[stack.length-3].MergeCommentsAfter(nd_last_operator),
								nd_last_operator.data,
								stack[stack.length-1].MergeCommentsBefore(nd_last_operator)
							)
							nd_last_operator.FreeASTStorage()
							stack.pop()
							stack.pop()
							stack.back()=nd_folded
							changed=1
				else
					//operand, fold prefix
					while stack.length>=1&&stack.back().node_class==N_SYMBOL&&prefix_ops[stack.back().data]:
						if stack.length>=2&&stack[stack.length-2].node_class!=N_SYMBOL&&binop_priority[stack.back().data]:
							//prefix-binary ambiguity: assume binary
							break
						nd_prefix_operator=stack.pop()
						ndi=nUnary(nd_prefix_operator.data,ndi)
						nd_prefix_operator.FreeASTStorage()
						changed=1
				stack.push_back(ndi)
				ndi=ndi_next
			}
			if changed:
				if stack.length==1&&!(nd_raw.flags&0xffff):
					nd_raw.ReplaceWith(stack[0])
					nd_raw.FreeASTStorage()
				else
					//we still have uninterpreted things, replace children
					assert(stack.length>1)
					for ndi in stack
						ndi.p=nd_raw
					nd_new_child=InsertMany(stack)
					nd_raw.c=nd_new_child
		}
		stack.clear()
		//convert failed-to-fold named ops back
		for nd_ref in nd_root.FindAll(N_SYMBOL,NULL)
			if named_ops[nd_ref.data]:
				nd_ref.node_class=N_REF
		return nd_root
	}
	//TODO: weird stuff - C ?:
	//type-binop ambiguity: foo*[3]*b=bar*[3]*b
	//a sane method to resolve such ambiguity: LHS of assignment, in a function prototype... and it's C-specific
	//makes sense to put in a separate pass! and maybe unify the situations to "LHS of assignment" first
	//TODO: type-binop ambiguity resolution
}
