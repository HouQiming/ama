// //// JC version: 3
#include '../ast/node.jch'
#include "../script/jsenv.jch"
#include './depends.jch'
#include "./operator.jch"

namespace ama {
	Map<char[|], int>! GetOperatorSet(JSValueConst! options, char*! name) {
		char[|]! s_binops = ama::UnwrapString(JS_GetPropertyStr(ama::jsctx, options, name));
		Map<char[|], int>! ret = new Map<char[|], int>!();
		int! priority = 1;
		for(char[...]&! s_binop : s_binops.split(' ')) {
			if( s_binop.endsWith('\n') ) {
				ret[new char[|]!(s_binop.subarray(0, s_binop.length - 1))] = priority;
				priority += 1;
			} else {
				ret[new char[|]!(s_binop)] = priority;
			}
		}
		return <<ret;
	}
	ama::Node*+! ParseAssignment(ama::Node*+! nd_root, JSValueConst! options) {
		Map<char[|], int>! binop_priority = GetOperatorSet(options, 'binary_operators');
		ama::Node*+[+]! Q = nd_root.FindAll(ama::N_RAW, NULL);
		for(intptr_t! i = 0; i < Q.length; i++) {
			ama::Node*+! nd_raw = Q[i];
			ama::Node*+! ndi = nd_raw.c;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( ndi_next && ndi_next.s && 
				ndi_next.node_class == ama::N_SYMBOL && ndi_next.data == "=" && 
				!(ndi.node_class == ama::N_SYMBOL && binop_priority[ndi.data]) ) {
					//handle updating operators in ParseOperators instead
					ama::Node*+! @nojson ndi_next_next = ndi_next.s;
					//move the comments
					ndi.comments_after = new char[|]!(ndi.comments_after + ndi_next.comments_before);
					ndi_next.Delete();
					ama::Node*+! nd_value = ndi_next_next.s ? ama::CreateNode(ama::N_RAW, ndi_next_next) : ndi_next_next;
					nd_value.comments_before = new char[|]!(ndi_next.comments_after + ndi_next_next.comments_before);
					nd_value.indent_level = ndi_next_next.indent_level;
					ndi_next_next.comments_before = '';
					ama::Node*+! nd_tmp = ama::GetPlaceHolder();
					nd_raw.ReplaceWith(nd_tmp);
					nd_tmp.ReplaceWith(ama::nAssignment(nd_raw, nd_value));
					if( ndi_next_next.s ) {
						//detect nested assignment
						Q.push_back(nd_value);
					}
					break;
				}
				ndi = ndi_next;
			}
		}
		return nd_root;
	}
	//COULDDO: lazy parsing with OwningUnparsedExpr  
	ama::Node*+! ParseOperators(ama::Node*+! nd_root, JSValueConst! options) {
		ama::Node*+[+]! stack;
		Map<char[|], int>! binop_priority = GetOperatorSet(options, 'binary_operators');
		Map<char[|], int>! prefix_ops = GetOperatorSet(options, 'prefix_operators');
		Map<char[|], int>! postfix_ops = GetOperatorSet(options, 'postfix_operators');
		Map<char[|], int>! named_ops = GetOperatorSet(options, 'named_operators');
		//named operators: convert refs to symbols
		for(ama::Node*&+! nd_ref : nd_root.FindAll(ama::N_REF, NULL)) {
			if( named_ops[nd_ref.data] ) {
				nd_ref.node_class = ama::N_SYMBOL;
			}
		}
		ama::Node*+[+]! Q = nd_root.FindAll(ama::N_RAW, NULL);
		//sentenial operand
		//we need to leave uninterpreted structures alone
		for(intptr_t! i = 0; i < Q.length; i++) {
			//binary and unary in one pass
			stack = new ama::Node*+[+]!();
			ama::Node*+! nd_raw = Q[i];
			ama::Node*+! ndi = nd_raw.c;
			int! changed = 0;
			while( ndi ) {
				ama::Node*+! @nojson ndi_next = ndi.s;
				if( ndi.node_class == ama::N_SYMBOL ) {
					int! pr = 0x7fffffff;
					if( postfix_ops[ndi.data] && stack.length > 0 && stack.back().node_class != ama::N_SYMBOL ) {
						//precedence problem - need to replace the prefix-core instead
						ama::Node*+! nd_operand = stack.pop();
						ama::Node*+! nd_prefix_core = nd_operand;
						while( nd_prefix_core.node_class == ama::N_UNARY && !(nd_prefix_core.flags & ama::UNARY_POSTFIX) ) {
							nd_prefix_core = nd_prefix_core.c;
						}
						ama::Node*+! nd_tmp = ama::GetPlaceHolder();
						if( nd_prefix_core != nd_operand ) {
							nd_prefix_core.ReplaceWith(nd_tmp);
						}
						ama::Node*+! nd_unary = ama::nUnaryPostfix(nd_prefix_core.MergeCommentsAfter(ndi), ndi.data);
						ndi.p = NULL;
						ndi.FreeASTStorage();
						if( nd_prefix_core != nd_operand ) {
							nd_tmp.ReplaceWith(nd_unary);
						} else {
							nd_operand = nd_unary;
						}
						stack.push_back(nd_operand);
						ndi = ndi_next;
						changed = 1;
						continue;
					} else {
						pr = binop_priority[ndi.data];
						if( pr ) {
							//flush >=pr
							while( stack.length >= 3 && stack.back().node_class != ama::N_SYMBOL && 
							stack[stack.length - 2].node_class == ama::N_SYMBOL && stack[stack.length - 3].node_class != ama::N_SYMBOL && 
							binop_priority[stack[stack.length - 2].data] >= pr ) {
								//fold high priority binop
								ama::Node*+! nd_last_operator = stack[stack.length - 2];
								ama::Node*+! nd_folded = ama::nBinop(
									stack[stack.length - 3].MergeCommentsAfter(nd_last_operator),
									nd_last_operator.data,
									stack[stack.length - 1].MergeCommentsBefore(nd_last_operator)
								);
								nd_last_operator.p = NULL;
								nd_last_operator.FreeASTStorage();
								stack.pop();
								stack.pop();
								stack.back() = nd_folded;
								changed = 1;
							}
						}
					}
				} else {
					//operand, fold prefix
					while( stack.length >= 1 && stack.back().node_class == ama::N_SYMBOL && prefix_ops[stack.back().data] ) {
						if( stack.length >= 2 && stack[stack.length - 2].node_class != ama::N_SYMBOL && binop_priority[stack.back().data] ) {
							//prefix-binary ambiguity: assume binary
							break;
						}
						ama::Node*+! nd_prefix_operator = stack.pop();
						ndi = ama::nUnary(nd_prefix_operator.data, ndi);
						nd_prefix_operator.p = NULL;
						nd_prefix_operator.FreeASTStorage();
						changed = 1;
					}
				}
				stack.push_back(ndi);
				ndi = ndi_next;
			}
			if( changed ) {
				if( stack.length == 1 && !(nd_raw.flags & 0xffff) ) {
					nd_raw.ReplaceWith(stack[0]);
					nd_raw.FreeASTStorage();
				} else {
					//we still have uninterpreted things, replace children
					assert(stack.length > 1);
					for(ama::Node*&+! ndi : stack) {
						ndi.p = nd_raw;
					}
					ama::Node*+! nd_new_child = ama::InsertMany(stack);
					nd_raw.c = nd_new_child;
				}
			}
		}
		stack.clear();
		//convert failed-to-fold named ops back
		for(ama::Node*&+! nd_ref : nd_root.FindAll(ama::N_SYMBOL, NULL)) {
			if( named_ops[nd_ref.data] ) {
				nd_ref.node_class = ama::N_REF;
			}
		}
		return nd_root;
	}
	//TODO: weird stuff - C ?:
	//type-binop ambiguity: foo*[3]*b=bar*[3]*b
	//a sane method to resolve such ambiguity: LHS of assignment, in a function prototype... and it's C-specific
	//makes sense to put in a separate pass! and maybe unify the situations to "LHS of assignment" first
	//TODO: type-binop ambiguity resolution
};
