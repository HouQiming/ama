// //// JC version: 3
#include '../ast/node.jch'
#include './postfix.jch'

namespace ama {
	private inline int! isCPPLambda(ama::Node*+! ndi) {
		return ndi.node_class == ama::N_CALL && ndi.c.isRawNode('[', ']');
	}
	ama::Node*+! ParsePostfix(ama::Node*+! nd_root) {
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			ama::Node*+! ndi = nd_raw.c;
			ama::Node*+!*+! p_self = &nd_raw.c;
			const int! LAST_PROTOTYPE_NONE = 0;
			const int! LAST_PROTOTYPE_CPP_LAMBDA = 1;
			const int! LAST_PROTOTYPE_MAYBE_SUFFIX = 2;
			int! last_prototype_kind = 0;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( ndi.node_class == ama::N_SYMBOL ) {
					//do nothing
				} else if( ndi.s && ndi.s.node_class == ama::N_SYMBOL && 
				(ndi.s.data == "." || (!isCPPLambda(ndi) && ndi.s.data == "->") || ndi.s.data == "::") && 
				ndi.s.s && ndi.s.s.node_class == ama::N_REF ) {
					//dot
					int! dot_flags = 0;
					if( ndi.s.data == "->" ) {
						dot_flags = ama::DOT_PTR;
					} else if( ndi.s.data == "::" ) {
						dot_flags = ama::DOT_CLASS;
					}
					char[|]! name = ndi.s.s.data;
					*p_self = NULL;
					ndi.p = NULL;
					ndi.s = NULL;
					ndi = ndi.dot(name).setFlags(dot_flags);
					*p_self = ndi;
					ndi.p = nd_raw;
					ndi.s = ndi_next.s.s;
					ndi_next.s.FreeASTStorage();
					ndi_next.FreeASTStorage();
					continue;
				} else if( ndi.s && (ndi.s.isRawNode('(', ')') || ndi.s.isRawNode('<', '>')) ) {
					//call
					uint8_t! call_class = ndi.s.isRawNode('<', '>') ? ama::N_CALL_TEMPLATE : ama::N_CALL;
					*p_self = NULL;
					ndi.p = NULL;
					ndi.s = NULL;
					ama::Node*+! ndi_next_next = ndi_next.s;
					ndi_next.p = NULL;
					ndi_next.s = NULL;
					ama::Node*+[+]! new_children = new ama::Node*+[+]!();
					new_children.push_back(ndi);
					for(ama::Node*+! ndj : ndi_next) {
						//strip trailing ','s
						ama::Node*+! ndj_last = ndj.LastChild();
						if( ndj_last != NULL && ndj_last.isSymbol(",") ) {
							ndj_last.Delete();
							ndj_last.FreeASTStorage();
						}
						new_children.push_back(ndj);
					}
					ama::Node*+! ndi_old = ndi;
					ndi = ama::CreateNodeFromChildren(call_class, new_children);
					ndi.comments_after = ndi_next.comments_after;
					ndi.indent_level = ndi_old.indent_level;
					//ndi_old.indent_level=0;
					ndi.p = nd_raw;
					ndi.s = ndi_next_next;
					*p_self = ndi;
					continue;
				} else if( ndi.s && ndi.s.isRawNode('[', ']') ) {
					//item
					*p_self = NULL;
					ndi.p = NULL;
					ndi.s = NULL;
					ama::Node*+! ndi_next_next = ndi_next.s;
					ndi_next.p = NULL;
					ndi_next.s = NULL;
					ama::Node*+[+]! new_children = new ama::Node*+[+]!();
					new_children.push_back(ndi);
					for(ama::Node*+! ndj : ndi_next) {
						//strip trailing ','s
						ama::Node*+! ndj_last = ndj.LastChild();
						if( ndj_last != NULL && ndj_last.node_class == ama::N_SYMBOL && ndj_last.data == "," ) {
							ndj_last.Delete();
							ndj_last.FreeASTStorage();
						} else {
							new_children.push_back(ndj);
						}
					}
					ndi = ama::CreateNodeFromChildren(ama::N_ITEM, new_children);
					ndi.comments_after = ndi_next.comments_after;
					ndi.p = nd_raw;
					ndi.s = ndi_next_next;
					*p_self = ndi;
					continue;
				}
				p_self = &ndi.s;
				ndi = ndi_next;
			}
		}
		return nd_root;
	}
	ama::Node*+! UnparseCall(ama::Node*+! nd) {
		assert(nd.node_class == ama::N_CALL);
		ama::Node*+[+]! args = new ama::Node*+[+]!();
		for(ama::Node*+! ndi = nd.c.s; ndi; ndi = ndi.s) {
			args.push_back(ndi);
			if( ndi.s ) {
				args.push_back(ama::nSymbol(",").setCommentsAfter(" "));
			}
		}
		ama::Node*+! ret = nd.ReplaceWith(ama::cons(nd.c, ama::CreateNodeFromChildren(ama::N_RAW, args).setFlags(uint32_t('(') | uint32_t(')') << 8)));
		nd.c = NULL;
		nd.FreeASTStorage();
		return ret;
	}
};
