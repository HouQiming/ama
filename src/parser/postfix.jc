// //// JC version: 3
#include <console.jch>
#include <json.jch>
#include '../ast/node.jch'
#include './postfix.jch'

namespace ama {
	private inline int! isCPPLambda(ama::Node*+! ndi) {
		return ndi.node_class == ama::N_CALL && ndi.c.isRawNode('[', ']');
	}
	ama::Node*+! ParsePostfix(ama::Node*+! nd_root, int! parse_air_object) {
		//note: if we do it forward, the free-ed N_RAW() / N_RAW[] will get enumerated later and cause all kinds of issues
		for(ama::Node*+! nd_raw : (new ama::Node*+![+] {nd_root}).concat(nd_root.FindAll(ama::N_SCOPE, NULL), nd_root.FindAll(ama::N_RAW, NULL)).reverse()) {
			ama::Node*+! ndi = nd_raw.c;
			ama::Node*+!*+! p_self = &nd_raw.c;
			const int! LAST_PROTOTYPE_NONE = 0;
			const int! LAST_PROTOTYPE_CPP_LAMBDA = 1;
			const int! LAST_PROTOTYPE_MAYBE_SUFFIX = 2;
			int! last_prototype_kind = 0;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( parse_air_object && 
				ndi.node_class == ama::N_SYMBOL && (ndi.data == "." || (!isCPPLambda(ndi) && ndi.data == "->") || ndi.data == "::") && 
				ndi.s && ndi.s.node_class == ama::N_REF ) {
					//dot
					int! dot_flags = 0;
					if( ndi.data == "->" ) {
						dot_flags = ama::DOT_PTR;
					} else if( ndi.data == "::" ) {
						dot_flags = ama::DOT_CLASS;
					}
					char[|]! name = ndi.s.data;
					ama::Node*+! nd_dot = ama::nAir().dot(name).setFlags(dot_flags);
					ndi.p = NULL;
					ndi.s = NULL;
					*p_self = nd_dot;
					nd_dot.p = nd_raw;
					nd_dot.s = ndi_next.s;
					ndi_next.p = NULL;
					ndi_next.FreeASTStorage();
					ndi.FreeASTStorage();
					ndi = nd_dot;
					continue;
				} else if( ndi.node_class == ama::N_SYMBOL ) {
					//do nothing
				} else if( ndi_next && ndi_next.node_class == ama::N_SYMBOL && 
				(ndi_next.data == "." || (!isCPPLambda(ndi) && ndi_next.data == "->") || ndi_next.data == "::") && 
				ndi_next.s && ndi_next.s.node_class == ama::N_REF ) {
					//dot
					int! dot_flags = 0;
					if( ndi_next.data == "->" ) {
						dot_flags = ama::DOT_PTR;
					} else if( ndi_next.data == "::" ) {
						dot_flags = ama::DOT_CLASS;
					}
					ama::Node*+! nd_name = ndi_next.s;
					char[|]! name = nd_name.data;
					*p_self = NULL;
					ndi.p = NULL;
					ndi.s = NULL;
					ndi = ndi.dot(name).setFlags(dot_flags);
					*p_self = ndi;
					ndi.p = nd_raw;
					ndi.s = nd_name.s;
					nd_name.p = NULL; nd_name.FreeASTStorage();
					ndi_next.p = NULL; ndi_next.FreeASTStorage();
					continue;
				} else if( ndi_next && (ndi_next.isRawNode('(', ')') || ndi_next.isRawNode('<', '>')) && !ndi_next.FindAllWithin(ama::BOUNDARY_ONE_LEVEL, ama::N_SYMBOL, ";").length ) {
					//call
					ama::Node*+! nd_arglist = ndi.s;
					uint8_t! call_class = nd_arglist.isRawNode('<', '>') ? ama::N_CALL_TEMPLATE : ama::N_CALL;
					*p_self = NULL;
					ndi.p = NULL;
					ndi.s = NULL;
					ama::Node*+! ndi_next_next = nd_arglist.s;
					nd_arglist.p = NULL;
					nd_arglist.s = NULL;
					//re-delimit everything completely
					ama::Node*+[+]! new_children = new ama::Node*+[+]!();
					new_children.push_back(ndi);
					if( nd_arglist.c ) {
						ama::Node*+[+]! comma_group = new ama::Node*+[+]!();
						for(ama::Node*+! ndj : nd_arglist) {
							//strip trailing ','s
							if( ndj.isRawNode(0, 0) ) {
								for(ama::Node*+! ndk = ndj.c; ndk; ndk = ndk.s) {
									if( ndk.isSymbol(",") ) {
										new_children.push_back(ama::toSingleNode(ama::InsertMany(comma_group)));
										comma_group.clear();
									} else {
										comma_group.push_back(ndk);
									}
								}
							} else if( ndj.isSymbol(",") ) {
								new_children.push_back(ama::toSingleNode(ama::InsertMany(comma_group)));
								comma_group.clear();
							} else {
								comma_group.push_back(ndj);
							}
						}
						new_children.push_back(ama::toSingleNode(ama::InsertMany(comma_group)));
					}
					for(int! i = 2; i < new_children.length; i += 1) {
						if( new_children[i].comments_before.startsWith(' ') ) {
							new_children[i].comments_before = new char[|]!(new_children[i].comments_before.subarray(1));
						}
					}
					ama::Node*+! ndi_old = ndi;
					ndi = ama::CreateNodeFromChildren(call_class, new_children);
					//merge comments
					ndi.comments_after = nd_arglist.comments_after;
					ndi_old.MergeCommentsAfter(nd_arglist);
					//console.log(JSON.stringify(ndi.toSource()), JSON.stringify(ndi.comments_after));
					ndi.indent_level = ndi_old.indent_level;
					//ndi_old.indent_level=0;
					ndi.p = nd_raw;
					ndi.s = ndi_next_next;
					*p_self = ndi;
					//nd_arglist is also N_RAW: but we shouldn't process it any more
					nd_arglist.c = NULL;
					continue;
				} else if( ndi.s && ndi.s.isRawNode('[', ']') ) {
					//item
					*p_self = NULL;
					ndi.p = NULL;
					ndi.s = NULL;
					ama::Node*+! ndi_next_next = ndi_next.s;
					ndi_next.p = NULL;
					ndi_next.s = NULL;
					ama::Node*+[+]! new_children = new ama::Node*+[+]!();
					new_children.push_back(ndi);
					for(ama::Node*+! ndj : ndi_next) {
						//strip trailing ','s
						ama::Node*+! ndj_last = ndj.LastChild();
						if( ndj_last != NULL && ndj_last.node_class == ama::N_SYMBOL && ndj_last.data == "," ) {
							ndj_last.Delete();
							ndj_last.FreeASTStorage();
						} else {
							new_children.push_back(ndj);
						}
					}
					ndi = ama::CreateNodeFromChildren(ama::N_ITEM, new_children);
					ndi.comments_after = ndi_next.comments_after;
					ndi.p = nd_raw;
					ndi.s = ndi_next_next;
					*p_self = ndi;
					continue;
				}
				p_self = &ndi.s;
				ndi = ndi_next;
			}
		}
		return nd_root;
	}
	ama::Node*+! UnparseCall(ama::Node*+! nd) {
		assert(nd.node_class == ama::N_CALL || nd.node_class == ama::N_CALL_TEMPLATE);
		ama::Node*+[+]! args = new ama::Node*+[+]!();
		for(ama::Node*+! ndi = nd.c.s; ndi; ndi = ndi.s) {
			args.push_back(ndi);
			if( ndi.s ) {
				args.push_back(ama::nSymbol(",").setCommentsAfter(" "));
			}
		}
		uint32_t! flags = uint32_t('(') | uint32_t(')') << 8;
		if( nd.node_class == ama::N_CALL_TEMPLATE ) {
			flags = uint32_t('<') | uint32_t('>') << 8;
		}
		ama::Node*+! ret = nd.ReplaceWith(ama::cons(nd.c, ama::CreateNodeFromChildren(ama::N_RAW, args).setFlags(flags)));
		nd.c = NULL;
		nd.FreeASTStorage();
		return ret;
	}
};
