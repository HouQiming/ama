// //// JC version: 3
#include <console.jch>
#include <json.jch>
#include '../ast/node.jch'
#include './postfix.jch'

namespace ama {
	private inline int! isCPPLambda(ama::Node*+! ndi) {
		return ndi.node_class == ama::N_CALL && ndi.c.isRawNode('[', ']');
	}
	ama::Node*+! ParsePostfix(ama::Node*+! nd_root, int! parse_air_object) {
		//note: if we do it forward, the free-ed N_RAW() / N_RAW[] will get enumerated later and cause all kinds of issues
		for(ama::Node*+! nd_raw : (new ama::Node*+![+] {nd_root}).concat(nd_root.FindAll(ama::N_SCOPE, NULL), nd_root.FindAll(ama::N_RAW, NULL)).reverse()) {
			ama::Node*+! ndi = nd_raw.c;
			const int! LAST_PROTOTYPE_NONE = 0;
			const int! LAST_PROTOTYPE_CPP_LAMBDA = 1;
			const int! LAST_PROTOTYPE_MAYBE_SUFFIX = 2;
			int! last_prototype_kind = 0;
			while( ndi ) {
				//console.log(intptr_t(ndi), ndi.node_class, ndi.toSource());
				//Map<ama::Node*, int>! dedup = new Map<ama::Node*, int>!();
				//for(ama::Node*+! ndj = ndi; ndj; ndj = ndj.s) {
				//	if( dedup[ndj] ) {
				//		assert(0);
				//	}
				//	dedup[ndj] = 1;
				//}
				ama::Node*+! ndi_next = ndi.s;
				if( parse_air_object && 
				ndi.node_class == ama::N_SYMBOL && (ndi.data == "." || (!isCPPLambda(ndi) && ndi.data == "->") || ndi.data == "::") && 
				ndi.s && ndi.s.node_class == ama::N_REF ) {
					//dot
					int! dot_flags = 0;
					if( ndi.data == "->" ) {
						dot_flags = ama::DOT_PTR;
					} else if( ndi.data == "::" ) {
						dot_flags = ama::DOT_CLASS;
					}
					char[|]! name = ndi_next.data;
					ama::Node*+! nd_dot = ama::ReplaceChildRange(
						ndi, ndi_next,
						ama::nAir().setCommentsAfter(new char[|]!(ndi.comments_after + ndi_next.comments_before)).dot(name).setFlags(dot_flags).setCommentsBefore(ndi.comments_before).setCommentsAfter(ndi_next.comments_after)
					);
					ndi_next.p = NULL; ndi_next.FreeASTStorage();
					ndi.p = NULL; ndi.s = NULL; ndi.FreeASTStorage();
					ndi = nd_dot;
					continue;
				} else if( ndi.node_class == ama::N_SYMBOL ) {
					//do nothing
				} else if( ndi_next && ndi_next.node_class == ama::N_SYMBOL && 
				(ndi_next.data == "." || (!isCPPLambda(ndi) && ndi_next.data == "->") || ndi_next.data == "::") && 
				ndi_next.s && ndi_next.s.node_class == ama::N_REF ) {
					//dot
					int! dot_flags = 0;
					if( ndi_next.data == "->" ) {
						dot_flags = ama::DOT_PTR;
					} else if( ndi_next.data == "::" ) {
						dot_flags = ama::DOT_CLASS;
					}
					ama::Node*+! nd_name = ndi_next.s;
					nd_name.MergeCommentsBefore(ndi_next);
					char[|]! name = nd_name.data;
					ama::Node*+! nd_tmp = ama::GetPlaceHolder();
					ama::ReplaceChildRange(ndi, nd_name, nd_tmp);
					ndi.BreakSibling();
					ndi = nd_tmp.ReplaceWith(
						ndi.MergeCommentsAfter(ndi_next).MergeCommentsAfter(nd_name).dot(name).setFlags(dot_flags).setCommentsAfter(nd_name.comments_after)
					);
					nd_name.p = NULL; nd_name.FreeASTStorage();
					ndi_next.p = NULL; ndi_next.FreeASTStorage();
					continue;
				} else if( ndi_next && (ndi_next.isRawNode('(', ')') || ndi_next.isRawNode('<', '>') || ndi_next.isRawNode('[', ']')) && !ndi_next.FindAllWithin(ama::BOUNDARY_ONE_LEVEL, ama::N_SYMBOL, ";").length ) {
					//call
					ama::Node*+! nd_arglist = ndi.s;
					uint8_t! call_class = ama::N_CALL;
					if( nd_arglist.isRawNode('<', '>') ) {
						call_class = ama::N_CALL_TEMPLATE;
					} else if( nd_arglist.isRawNode('[', ']') ) {
						call_class = ama::N_ITEM;
					}
					ndi.MergeCommentsAfter(nd_arglist);
					//re-delimit everything completely
					ama::Node*+[+]! new_children = new ama::Node*+[+]!();
					new_children.push_back(ndi);
					if( nd_arglist.c ) {
						ama::Node*+[+]! comma_group = new ama::Node*+[+]!();
						char[+]! pending_comments_before;
						for(ama::Node*+! ndj : nd_arglist) {
							//strip trailing ','s
							if( ndj.isRawNode(0, 0) ) {
								pending_comments_before.push(ndj.comments_before);
								for(ama::Node*+! ndk = ndj.c; ndk; ndk = ndk.s) {
									if( ndk.isSymbol(",") ) {
										ama::Node*+! nd_arg = ama::toSingleNode(ama::InsertMany(comma_group));
										nd_arg.comments_before = new char[|]!(pending_comments_before + nd_arg.comments_before);
										nd_arg.comments_after = new char[|]!(nd_arg.comments_after + ndk.comments_before);
										new_children.push_back(nd_arg);
										pending_comments_before.clear();
										pending_comments_before.push(ndk.comments_after);
										comma_group.clear();
									} else {
										comma_group.push_back(ndk);
									}
								}
								pending_comments_before.push(ndj.comments_after);
							} else if( ndj.isSymbol(",") ) {
								ama::Node*+! nd_arg = ama::toSingleNode(ama::InsertMany(comma_group));
								nd_arg.comments_before = new char[|]!(pending_comments_before + nd_arg.comments_before);
								nd_arg.comments_after = new char[|]!(nd_arg.comments_after + ndj.comments_before);
								new_children.push_back(nd_arg);
								pending_comments_before.clear();
								pending_comments_before.push(ndj.comments_after);
								comma_group.clear();
							} else {
								comma_group.push_back(ndj);
							}
						}
						assert(comma_group.size() > 0);
						ama::Node*+! nd_arg = ama::toSingleNode(ama::InsertMany(comma_group));
						nd_arg.comments_before = new char[|]!(pending_comments_before + nd_arg.comments_before);
						new_children.push_back(nd_arg);
					}
					//for(int! i = 2; i < new_children.length; i += 1) {
					//	if( new_children[i].comments_before.startsWith(' ') ) {
					//		new_children[i].comments_before = new char[|]!(new_children[i].comments_before.subarray(1));
					//	}
					//}
					ama::Node*+! nd_tmp = ama::GetPlaceHolder();
					ama::ReplaceChildRange(ndi, nd_arglist, nd_tmp);
					ama::Node*+! nd_call = nd_tmp.ReplaceWith(ama::CreateNodeFromChildren(call_class, new_children).setCommentsAfter(nd_arglist.comments_after));
					//console.log(JSON.stringify(ndi.toSource()), JSON.stringify(ndi.comments_after));
					//ndi.indent_level = ndi_old.indent_level;
					//ndi_old.indent_level=0;
					//console.log('>>>', intptr_t(ndi_next_next), intptr_t(ndi_next_next.s));
					//nd_raw.Insert(ama::POS_BACK, ama::cons(ndi, ndi_next_next));
					//nd_arglist is also N_RAW so it can't be freed right now: but we shouldn't process it any more
					ndi = nd_call;
					nd_arglist.c = NULL;
					continue;
				}
				ndi = ndi_next;
			}
		}
		return nd_root;
	}
	ama::Node*+! UnparseCall(ama::Node*+! nd) {
		assert(nd.node_class == ama::N_CALL || nd.node_class == ama::N_CALL_TEMPLATE);
		ama::Node*+[+]! args = new ama::Node*+[+]!();
		for(ama::Node*+! ndi = nd.c.BreakSibling(); ndi; ndi = ndi.s) {
			args.push_back(ndi);
			if( ndi.s ) {
				args.push_back(ama::nSymbol(",").setCommentsAfter(" "));
			}
		}
		uint32_t! flags = uint32_t('(') | uint32_t(')') << 8;
		if( nd.node_class == ama::N_CALL_TEMPLATE ) {
			flags = uint32_t('<') | uint32_t('>') << 8;
		}
		ama::Node*+! ret = nd.ReplaceWith(ama::cons(nd.c.BreakSelf(), ama::CreateNodeFromChildren(ama::N_RAW, args).setFlags(flags)));
		//nd.c = NULL;
		nd.FreeASTStorage();
		return ret;
	}
};
