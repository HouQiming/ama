// //// JC version: 3
#include <console.jch>
#include <json.jch>
#include '../ast/node.jch'
#include './cleanup.jch'

namespace ama {
	ama::Node*+! CleanupDummyRaws(ama::Node*+! nd_root) {
		//need cleanup inside nodeofs
		for(ama::Node*+! nd_raw : nd_root.FindAllWithin(0, ama::N_RAW, NULL)) {
			if( (nd_raw.flags & 0xffff) != 0 || nd_raw == nd_root ) { continue; }
			if( !nd_raw.c && nd_raw.p && nd_raw.p.node_class == ama::N_RAW ) {
				nd_raw.Unlink();
			} else if( nd_raw.c && !nd_raw.c.s ) {
				//nd_raw.ReplaceWith(nd_raw.c);
				ama::UnparseRaw(nd_raw);
			}
		}
		//while( nd_root.c && !nd_root.c.s && nd_root.c.node_class == ama::N_RAW && !(nd_root.c.flags & 0xffff) ) {
		//	nd_root = nd_root.c;
		//	nd_root.p.c = NULL;
		//	nd_root.p.FreeASTStorage();
		//	nd_root.p = NULL;
		//}
		return nd_root;
	}
	ama::Node*+! SanitizeCommentPlacement(ama::Node*+! nd_root) {
		//COULDDO: make \n a trailing comment for statements: what about the first line in a scope?
		//pull comments_before out from nd.c for "headless" nodes
		for(ama::Node*+! nd = nd_root.PostorderFirst(); nd; nd = nd.PostorderNext(nd_root)) {
			if( nd.p && nd.p.node_class == ama::N_SCOPE && nd.Prev() && nd.comments_before.length > 0 && nd.comments_before[0] != '\n' ) {
				ama::Node*+! ndi_last = nd.Prev();
				//associate the first "line" of multi-line comments with the previous statement
				intptr_t! p_newline = nd.comments_before.indexOf('\n');
				if( p_newline > 0L ) {
					ndi_last.comments_after = new char[|]!(ndi_last.comments_after + nd.comments_before.subarray(0, p_newline));
					nd.comments_before = new char[|]!(nd.comments_before.subarray(p_newline));
				}
			}
			if( nd.c && 
			(nd.node_class == ama::N_CALL || nd.node_class == ama::N_CALL_TEMPLATE || nd.node_class == ama::N_CALL_CUDA_KERNEL || 
			nd.node_class == ama::N_BINOP || nd.node_class == ama::N_POSTFIX || 
			nd.node_class == ama::N_DOT || nd.node_class == ama::N_ITEM || nd.node_class == ama::N_FUNCTION || 
			nd.node_class == ama::N_ASSIGNMENT || nd.node_class == ama::N_CONDITIONAL || 
			nd.node_class == ama::N_LABELED || nd.node_class == ama::N_SEMICOLON || 
			(nd.node_class == ama::N_RAW && (nd.flags & 0xffff) == 0)) ) {
				if( nd.c.comments_before.length ) {
					nd.comments_before = new char[|]!(nd.comments_before + nd.c.comments_before);
					nd.c.comments_before = '';
				}
			}
			if( nd.c && 
			(nd.node_class == ama::N_BINOP || nd.node_class == ama::N_PREFIX || 
			nd.node_class == ama::N_FUNCTION || nd.node_class == ama::N_CLASS || 
			nd.node_class == ama::N_ASSIGNMENT || nd.node_class == ama::N_CONDITIONAL || 
			nd.node_class == ama::N_LABELED || nd.node_class == ama::N_SCOPED_STATEMENT || nd.node_class == ama::N_EXTENSION_CLAUSE || 
			(nd.node_class == ama::N_RAW && (nd.flags & 0xffff) == 0)) ) {
				ama::Node*+! nd_last = nd.LastChild();
				if( nd_last.comments_after.length ) {
					nd.comments_after = new char[|]!(nd.comments_after + nd_last.comments_after);
					nd_last.comments_after = '';
				}
			}
		}
		return nd_root;
	}
	ama::Node*+! StripBinaryOperatorSpaces(ama::Node*+! nd_root) {
		for(ama::Node*! nd : nd_root.FindAll(ama::N_BINOP, NULL)) {
			ama::Node*+! nd_a = nd.c;
			if( nd_a.comments_after.endsWith(' ') ) {
				nd_a.comments_after = new char[|]!(nd_a.comments_after.subarray(0, nd_a.comments_after.length - 1));
			}
			ama::Node*+! nd_b = nd.c.s;
			if( nd_b.comments_before.startsWith(' ') ) {
				nd_b.comments_before = new char[|]!(nd_b.comments_before.subarray(1));
			}
		}
		return nd_root;
	}
	private void! dfsAutoFormat(ama::Node*+! nd) {
		for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
			dfsAutoFormat(ndi);
			if( nd.node_class == ama::N_SCOPE || nd.node_class == ama::N_FILE ) {
				if( !ndi.indent_level && nd.node_class == ama::N_SCOPE ) {
					ndi.AdjustIndentLevel(4);
				}
				if( !ndi.comments_before.length ) {
					ndi.comments_before = "\n";
				}
				if( !ndi.s && !ndi.comments_after.length ) {
					ndi.comments_after = "\n";
				}
			}
		}
		if( nd.node_class == ama::N_SCOPE && nd.c ) {
			if( !nd.LastChild().comments_after.length ) { nd.LastChild().comments_after = "\n"; }
		}
	}
	ama::Node*+! AutoFormat(ama::Node*+! nd_root) {
		dfsAutoFormat(nd_root);
		return nd_root;
	}
	ama::Node*+! NodifySemicolonAndParenthesis(ama::Node*+! nd_root) {
		for(ama::Node*+! nd_scope : nd_root.FindAll(ama::N_SCOPE, NULL)) {
			for(ama::Node*+! ndi = nd_scope.c; ndi; ndi = ndi.s) {
				while( ndi.s && ndi.s.isSymbol(";") ) {
					ama::Node*+! nd_semicolon = ndi.s;
					ndi.Unlink();
					nd_semicolon.node_class = ama::N_SEMICOLON;
					nd_semicolon.data = NULL;
					nd_semicolon.indent_level = ndi.indent_level;
					nd_semicolon.Insert(ama::POS_FRONT, ndi);
					ndi.MergeCommentsAfter(nd_semicolon);
					ndi = nd_semicolon;
				}
				ama::Node*+! @nojson*+! link = &ndi.s;
			}
		}
		for(ama::Node*&+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			if( nd_raw.isRawNode('(', ')') && nd_raw.c && !nd_raw.c.s ) {
				nd_raw.node_class = ama::N_PAREN;
				nd_raw.flags = 0;
			} else if( nd_raw.isRawNode(0, 0) && nd_raw.c && nd_raw.LastChild().isSymbol(";") ) {
				nd_raw.LastChild().Unlink();
				nd_raw.ReplaceWith(ama::CreateNode(ama::N_SEMICOLON, ama::toSingleNode(nd_raw.c)));
			}
		}
		return nd_root;
	}
};
