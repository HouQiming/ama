// //// JC version: 3
#include <console.jch>
#include <json.jch>
#include '../ast/node.jch'
#include './cleanup.jch'

namespace ama {
	ama::Node*+! CleanupDummyRaws(ama::Node*+! nd_root) {
		//need cleanup inside nodeofs
		for(ama::Node*+! nd_raw : nd_root.FindAllWithin(0, ama::N_RAW, NULL)) {
			if( (nd_raw.flags & 0xffff) != 0 || nd_raw == nd_root ) { continue; }
			if( !nd_raw.c && nd_raw.p && nd_raw.p.node_class == ama::N_RAW ) {
				nd_raw.Delete();
			} else if( nd_raw.c && !nd_raw.c.s ) {
				nd_raw.ReplaceWith(nd_raw.c);
			}
		}
		//while( nd_root.c && !nd_root.c.s && nd_root.c.node_class == ama::N_RAW && !(nd_root.c.flags & 0xffff) ) {
		//	nd_root = nd_root.c;
		//	nd_root.p.c = NULL;
		//	nd_root.p.FreeASTStorage();
		//	nd_root.p = NULL;
		//}
		return nd_root;
	}
	private void! dfsPullComment(ama::Node*+! nd) {
		ama::Node*+! ndi_last = NULL;
		for(ama::Node*+! ndi : nd) {
			dfsPullComment(ndi);
			if( nd.node_class == ama::N_SCOPE && ndi_last && !ndi_last.hasBrackets() && ndi.comments_before.length > 0 && ndi.comments_before[0] != '\n' ) {
				//associate the first "line" of multi-line comments with the previous statement
				intptr_t! p_newline = ndi.comments_before.indexOf('\n');
				if( p_newline >= 0L ) {
					ndi_last.comments_after = new char[|]!(ndi_last.comments_after + ndi.comments_before.subarray(0, p_newline));
					ndi.comments_before = new char[|]!(ndi.comments_before.subarray(p_newline));
				}
			}
			ndi_last = ndi;
		}
		if( nd.c && 
		(nd.node_class == ama::N_CALL || nd.node_class == ama::N_CALL_TEMPLATE || nd.node_class == ama::N_CALL_CUDA_KERNEL || 
		nd.node_class == ama::N_BINOP || (nd.node_class == ama::N_UNARY && !(nd.flags & ama::UNARY_POSTFIX)) || 
		nd.node_class == ama::N_DOT || nd.node_class == ama::N_ITEM || 
		(nd.node_class == ama::N_RAW && (nd.flags & 0xffff) == 0)) ) {
			if( nd.c.comments_before.length ) {
				nd.comments_before = new char[|]!(nd.comments_before + nd.c.comments_before);
				nd.c.comments_before = '';
			}
		}
	}
	ama::Node*+! SanitizeCommentPlacement(ama::Node*+! nd_root) {
		//COULDDO: make \n a trailing comment for statements: what about the first line in a scope?
		//pull comments_before out from nd.c for "headless" nodes
		dfsPullComment(nd_root);
		return nd_root;
	}
	ama::Node*+! StripBinaryOperatorSpaces(ama::Node*+! nd_root) {
		for(ama::Node*! nd : nd_root.FindAll(ama::N_BINOP, NULL)) {
			ama::Node*+! nd_a = nd.c;
			if( nd_a.comments_after.endsWith(' ') ) {
				nd_a.comments_after = new char[|]!(nd_a.comments_after.subarray(0, nd_a.comments_after.length - 1));
			}
			ama::Node*+! nd_b = nd.c.s;
			if( nd_b.comments_before.startsWith(' ') ) {
				nd_b.comments_before = new char[|]!(nd_b.comments_before.subarray(1));
			}
		}
		return nd_root;
	}
	ama::Node*+! RemoveRedundantSemicolon(ama::Node*+! nd_root) {
		for(ama::Node*+! nd : nd_root.FindAll(ama::N_SYMBOL, ";")) {
			if( nd.p.node_class == ama::N_SCOPE ) {
				if( nd.s ) {
					nd.s.comments_before = new char[|]!(nd.comments_before + nd.comments_after + nd.s.comments_before);
				} else {
					nd.comments_after = new char[|]!(nd.comments_before + nd.comments_after + nd.comments_after);
				}
				nd.Delete();
				nd.FreeASTStorage();
			}
		}
		return nd_root;
	}
	private void! dfsAutoFormat(ama::Node*+! nd) {
		for(ama::Node*+! ndi : nd) {
			dfsAutoFormat(ndi);
			if( nd.node_class == ama::N_SCOPE ) {
				if( !ndi.indent_level ) {
					ama::AdjustIndentLevel(ndi, 4);
				}
				if( !ndi.comments_before.length ) {
					ndi.comments_before = ndi == nd.c ? "\n\t" : "\n";
				}
			} else if( nd.node_class == ama::N_RAW && ndi != nd.c ) {
				if( !ndi.comments_before.length ) {
					ndi.comments_before = " ";
				}
			} else if( nd.node_class == ama::N_FILE ) {
				if( !ndi.comments_before.length ) {
					ndi.comments_before = "\n";
				}
			}
		}
		if( nd.node_class == ama::N_SCOPE ) {
			if( !nd.comments_after.length ) { nd.comments_after = "\n"; }
		}
	}
	ama::Node*+! AutoFormat(ama::Node*+! nd_root) {
		dfsAutoFormat(nd_root);
		return nd_root;
	}
};
