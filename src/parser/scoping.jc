// //// JC version: 3
#include <console.jch>
#include <json.jch>
#include '../ast/node.jch'
#include "../script/jsenv.jch"
#include './scoping.jch'

namespace ama {
	void! ConvertToScope(ama::Node*+! nd_raw) {
		nd_raw.node_class = ama::N_SCOPE;
		nd_raw.flags = 0;
	}
	private void! FoldIndentGroup(ama::Node*+[+]&+! lines_out, int32_t! level, intptr_t! lineno, ama::Node*+! nd_nextline) {
		for(intptr_t! i = lineno; i < lines_out.length; i += 1) {
			ama::AdjustIndentLevel(lines_out[i], -level);
		}
		ama::Node*+! nd_new_scope = ama::CreateNode(ama::N_SCOPE, ama::InsertMany(lines_out.subarray(lineno)));
		nd_new_scope.indent_level = level;
		if( nd_nextline ) {
			intptr_t! p_newline = nd_nextline.comments_before.indexOf('\n');
			if( p_newline >= 0 ) {
				nd_new_scope.comments_after = new char[|]!(nd_new_scope.comments_after + nd_nextline.comments_before.subarray(0, p_newline + 1));
				nd_nextline.comments_before = new char[|]!(nd_nextline.comments_before.subarray(p_newline + 1));
			}
			//MergeCommentsAfter(nd_nextline);
			//console.log(JSON.stringify(nd_new_scope.comments_after))
		} else {
			nd_new_scope.comments_after = "\n";
		}
		lines_out.resize(lineno);
		lines_out.push_back(nd_new_scope);
	}
	ama::Node*+! DelimitCLikeStatements(ama::Node*+! nd_root, JSValue! options) {
		Map<char[|], int>! keywords_extension_clause = ama::GetPrioritizedList(options, "keywords_extension_clause");
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			ama::Node*+[+]! new_children = new ama::Node*+[+]!();
			ama::Node*+! ndi = nd_raw.c;
			new_children.push_back(ndi);
			char! changed = 0;
			int! after_cpp_macro = 0;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( (ndi.node_class == ama::N_SYMBOL && ndi.data == ";") || 
				(ndi_next && ndi_next.node_class == ama::N_SYMBOL && ndi_next.data == ";") ) {
					//after_cpp_macro=0
					//separate ; into its own statement
					changed = ';';
					ndi.s = NULL;
					if( ndi_next ) {
						new_children.push_back(ndi_next);
					}
				} else if( ndi.isRawNode('{', '}') || ndi.node_class == ama::N_SCOPE ) {
					if( ndi.s && ndi.s.node_class == ama::N_REF && keywords_extension_clause[ndi.s.data] ) {
						ndi = ndi_next;
						continue;
					}
					//after_cpp_macro=0
					changed = ';';
					ndi.s = NULL;
					if( ndi_next ) {
						new_children.push_back(ndi_next);
					}
				} else if( ndi.node_class == ama::N_REF && ndi.data.startsWith('#') ) {
					after_cpp_macro = 1;
				}
				if( after_cpp_macro && ndi.s != NULL && ndi.s.comments_before.indexOf('\n') >= 0 ) {
					after_cpp_macro = 0;
					changed = ';';
					ndi.s = NULL;
					if( ndi_next ) {
						new_children.push_back(ndi_next);
					}
				}
				//COULDDO: case:, default:
				ndi = ndi_next;
			}
			if( !changed ) {
				ndi = nd_raw.c;
				while( ndi ) {
					ama::Node*+! ndi_next = ndi.s;
					if( ndi.node_class == ama::N_SYMBOL && ndi.data == "," ) {
						//after_cpp_macro=0
						changed = ',';
						ndi.s = NULL;
						if( ndi_next ) {
							new_children.push_back(ndi_next);
						}
					}
					ndi = ndi_next;
				}
			}
			if( changed || (!nd_raw.isRawNode('{', '}') && nd_raw.c && nd_raw.c.s) ) {
				for(int! i = 0; i < new_children.length; i += 1) {
					ama::Node*+! nd_inner = ama::toSingleNode(new_children[i]);
					new_children[i] = nd_inner;
					new_children[i].indent_level = nd_inner.indent_level;
					new_children[i].p = nd_raw;
				}
				nd_raw.c = ama::InsertMany(new_children);
			}
			if( nd_raw.isRawNode('{', '}') && (changed == ';' || !nd_raw.c) ) {
				ConvertToScope(nd_raw);
			}
		}
		return nd_root;
	}
	ama::Node*+! ParseNodeof(ama::Node*+! nd_root) {
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			ama::Node*+! ndi = nd_raw.c;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( ndi.node_class == ama::N_SYMBOL && ndi.data == "." && ndi_next && (ndi_next.isRawNode('(', ')') || ndi_next.isRawNode('{', '}') || ndi_next.node_class == ama::N_SCOPE) ) {
					//nodeof
					ama::Node*+! ndi_next_next = ndi_next.s;
					ndi_next.Delete();
					ndi.ReplaceWith(ama::nNodeof(ndi_next));
					ndi_next = ndi_next_next;
				}
				ndi = ndi_next;
			}
		}
		return nd_root;
	}
	//do this before DelimitCLikeStatements
	private class IndentStackItem {
		int32_t! level;
		int32_t! lineno;
	};
	ama::Node*+! ConvertIndentToScope(ama::Node*+! nd_root) {
		ama::Node*+[+]! scopes = nd_root.FindAll(ama::N_SCOPE, NULL);
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			if( !nd_raw.p || nd_raw.isRawNode('{', '}') ) {
				scopes.push(nd_raw);
			}
		}
		for(ama::Node*+! nd_scope : scopes) {
			ama::Node*+[+]! lines = new ama::Node*+[+]!();
			int! passed_newline = 1;
			ama::Node*+*+! pndi = &nd_scope.c;
			lines.push_back(nd_scope.c);
			//delimit first
			for(ama::Node*+! ndi = nd_scope.c; ndi; (pndi = &ndi.s, ndi = ndi.s)) {
				if( ndi.comments_before.indexOf('\n') >= 0 ) {
					passed_newline = 1;
				}
				if( passed_newline ) {
					if( ndi != lines.back() ) {
						lines.push_back(ama::BreakLink(pndi));
					}
					passed_newline = 0;
				}
				if( !ndi.hasBrackets() && ndi.comments_after.indexOf('\n') >= 0 ) {
					passed_newline = 1;
				}
			}
			if( lines.length <= 1 ) { continue; }
			for(int! i = 0; i < lines.length; i += 1) {
				lines[i] = ama::toSingleNode(lines[i]);
				//console.log(i, lines[i].toSource());
			}
			//check indent levels after
			IndentStackItem![+]! istk = new IndentStackItem![+]!();
			istk.push(new IndentStackItem!{
				level: lines[0].indent_level,
				lineno: 0
			});
			ama::Node*+[+]! lines_out = new ama::Node*+[+]!();
			for(int! i = 0; i < lines.length; i += 1) {
				while( lines[i].indent_level < istk.back().level ) {
					if( istk.length <= 1 || lines[i].indent_level > istk[istk.length - 2].level ) {
						//bad indent
						istk.back().level = lines[i].indent_level;
					} else {
						FoldIndentGroup(lines_out, istk[istk.length - 2].level, istk.back().lineno, lines[i]);
						istk.pop();
					}
				}
				if( lines[i].indent_level > istk.back().level ) {
					istk.push(new IndentStackItem!{
						level: lines[i].indent_level,
						lineno: int32_t(lines_out.length)
					});
				}
				assert(!lines[i].s);
				lines_out.push_back(lines[i]);
			}
			while( istk.length > 1 ) {
				FoldIndentGroup(lines_out, istk[istk.length - 2].level, istk.back().lineno, NULL);
				istk.pop();
			}
			//merge scopes into surrounding raws
			ama::Node*+[+]! line_group = new ama::Node*+[+]!();
			ama::Node*+[+]! line_out_final = new ama::Node*+[+]!();
			for(int! i0 = 0; i0 < lines_out.length;) {
				int! i1 = i0 + 1;
				while( i1 < lines_out.length && (lines_out[i1].node_class == ama::N_SCOPE || lines_out[i1 - 1].node_class == ama::N_SCOPE) ) {
					i1 += 1;
				}
				if( (i1 - i0) <= 1 ) {
					line_out_final.push_back(lines_out[i0]);
				} else {
					line_group.clear();
					for(int! j = i0; j < i1; j += 1) {
						ama::Node*+! ndj = lines_out[j];
						if( ndj.isRawNode(0, 0) ) {
							if( ndj.c ) {
								ndj.c.comments_before = new char[|]!(ndj.comments_before + ndj.c.comments_before);
								ama::Node*+! ndj_last = ndj.LastChild();
								ndj_last.comments_after = new char[|]!(ndj_last.comments_after + ndj.comments_after);
							}
							for(ama::Node*+! ndk : ndj) {
								line_group.push_back(ndk);
							}
						} else {
							line_group.push_back(ndj);
						}
					}
					assert(line_group.length > 1);
					line_out_final.push_back(ama::CreateNodeFromChildren(ama::N_RAW, line_group));
				}
				i0 = i1;
			}
			//replace old children
			for(ama::Node*+! ndi : line_out_final) {
				ndi.p = nd_scope;
				//if( ndi.s ) {
				//	console.log('has s', ndi.toSource());
				//}
				assert(!ndi.s);
			}
			nd_scope.c = ama::InsertMany(line_out_final);
		}
		return nd_root;
	}
};
