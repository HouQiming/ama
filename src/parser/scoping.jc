// //// JC version: 3
#include <console.jch>
#include <json.jch>
#include '../ast/node.jch'
#include "../script/jsenv.jch"
#include './scoping.jch'

namespace ama {
	void! ConvertToScope(ama::Node*+! nd_raw) {
		nd_raw.node_class = ama::N_SCOPE;
		nd_raw.flags = 0;
	}
	private ama::Node*+[+]! MergeScopesIntoStatements(Map<char[|], int>&! keywords_extension_clause, ama::Node*+[...]! lines_out) {
		ama::Node*+[+]! line_group = new ama::Node*+[+]!();
		ama::Node*+[+]! line_out_final = new ama::Node*+[+]!();
		for(int! i0 = 0; i0 < lines_out.length;) {
			int! i1 = i0 + 1;
			while( i1 < lines_out.length && 
			(lines_out[i1].node_class == ama::N_SCOPE || lines_out[i1].isRawNode('{', '}') || 
			(lines_out[i1].isRawNode(0, 0) && lines_out[i1].c && (lines_out[i1].c.node_class == ama::N_SCOPE || lines_out[i1].c.isRawNode('{', '}'))) || 
			((lines_out[i1 - 1].node_class == ama::N_SCOPE || lines_out[i1 - 1].isRawNode('{', '}')) && 
			((lines_out[i1].node_class == ama::N_REF && keywords_extension_clause[lines_out[i1].data]) || 
			(lines_out[i1].node_class == ama::N_RAW && lines_out[i1].c && lines_out[i1].c.node_class == ama::N_REF && keywords_extension_clause[lines_out[i1].c.data])))) ) {
				if( (lines_out[i1 - 1].node_class == ama::N_SCOPE || lines_out[i1 - 1].isRawNode('{', '}')) && lines_out[i1].comments_before.startsWith('\n') ) {
					lines_out[i1].comments_before = new char[|]!(lines_out[i1].comments_before.subarray(1));
				}
				i1 += 1;
			}
			if( (i1 - i0) <= 1 ) {
				line_out_final.push_back(lines_out[i0]);
			} else {
				line_group.clear();
				for(int! j = i0; j < i1; j += 1) {
					ama::Node*+! ndj = lines_out[j];
					if( ndj.isRawNode(0, 0) ) {
						if( ndj.c ) {
							ndj.c.comments_before = new char[|]!(ndj.comments_before + ndj.c.comments_before);
							ama::Node*+! ndj_last = ndj.LastChild();
							ndj_last.comments_after = new char[|]!(ndj_last.comments_after + ndj.comments_after);
						}
						for(ama::Node*+! ndk : ndj) {
							line_group.push_back(ndk);
						}
					} else {
						line_group.push_back(ndj);
					}
				}
				assert(line_group.length > 1);
				ama::Node*+! nd_raw = ama::CreateNodeFromChildren(ama::N_RAW, line_group);
				nd_raw.indent_level = line_group[0].indent_level;
				line_out_final.push_back(nd_raw);
			}
			i0 = i1;
		}
		return <<line_out_final;
	}
	private void! FoldIndentGroup(
		Map<char[|], int>&! keywords_extension_clause,
		ama::Node*+[+]&+! lines_out, int32_t! level, intptr_t! lineno, ama::Node*+! nd_nextline
	) {
		for(intptr_t! i = lineno; i < lines_out.length; i += 1) {
			lines_out[i].AdjustIndentLevel(-level);
		}
		ama::Node*+! nd_new_scope = ama::CreateNode(ama::N_SCOPE, ama::InsertMany(MergeScopesIntoStatements(keywords_extension_clause, lines_out.subarray(lineno))));
		nd_new_scope.indent_level = level;
		if( nd_nextline ) {
			intptr_t! p_newline = nd_nextline.comments_before.indexOf('\n');
			if( p_newline >= 0 ) {
				if( nd_new_scope.c ) {
					ama::Node*+! nd_last = nd_new_scope.LastChild();
					if( nd_last.comments_after.indexOf('\n') < 0L ) {
						nd_last.comments_after = new char[|]!(nd_last.comments_after + "\n");
					}
				}
				nd_new_scope.comments_after = new char[|]!(nd_new_scope.comments_after + nd_nextline.comments_before.subarray(0, p_newline));
				nd_nextline.comments_before = new char[|]!(nd_nextline.comments_before.subarray(p_newline));
			}
			//MergeCommentsAfter(nd_nextline);
			//console.log(JSON.stringify(nd_new_scope.comments_after))
		} else {
			nd_new_scope.comments_after = "\n";
		}
		lines_out.resize(lineno);
		lines_out.push_back(nd_new_scope);
	}
	ama::Node*+! DelimitCLikeStatements(ama::Node*+! nd_root, JSValue! options) {
		Map<char[|], int>! keywords_extension_clause = ama::GetPrioritizedList(options, "keywords_extension_clause");
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			if( !(nd_raw.flags & 0xffff) && nd_raw.p ) {
				//move out trailing ;
				ama::Node*+! nd_last = nd_raw.LastChild();
				if( nd_last && nd_last.isSymbol(";") && nd_raw.p && (nd_raw.p.node_class == ama::N_SCOPE || nd_raw.p.node_class == ama::N_RAW) ) {
					nd_last.Delete();
					nd_raw.Insert(ama::POS_AFTER, nd_last);
				}
				continue;
			}
			ama::Node*+[+]! new_children = new ama::Node*+[+]!();
			ama::Node*+! ndi = nd_raw.c;
			new_children.push_back(ndi);
			char! changed = 0;
			int! after_cpp_macro = 0;
			while( ndi ) {
				ama::Node*+! ndi_next = ndi.s;
				if( (ndi.isSymbol(";") && !
				(ndi_next && ndi_next.node_class == ama::N_REF && keywords_extension_clause[ndi_next.data])) || 
				(ndi_next && ndi_next.isSymbol(";") && !
				(ndi_next.s && ndi_next.s.node_class == ama::N_REF && keywords_extension_clause[ndi_next.s.data])) ) {
					//after_cpp_macro=0
					//separate ; into its own statement
					changed = ';';
					ndi.BreakSibling();
					if( ndi_next ) {
						new_children.push_back(ndi_next);
					}
				} else if( ndi.isRawNode('{', '}') || ndi.node_class == ama::N_SCOPE ) {
					if( ndi.s && ((ndi.s.node_class == ama::N_REF && keywords_extension_clause[ndi.s.data]) || ndi.s.isSymbol("=")) ) {
						ndi = ndi_next;
						continue;
					}
					//after_cpp_macro=0
					changed = ';';
					ndi.BreakSibling();
					if( ndi_next ) {
						new_children.push_back(ndi_next);
					}
				} else if( ndi.node_class == ama::N_REF && ndi.data.startsWith('#') ) {
					changed = ';';
					if( !new_children.length && new_children.back() == ndi ) {
						ndi.BreakSelf();
						new_children.push_back(ndi);
					}
					after_cpp_macro = 1;
				}
				if( after_cpp_macro && ndi.s != NULL && ndi.s.comments_before.indexOf('\n') >= 0 ) {
					after_cpp_macro = 0;
					changed = ';';
					ndi.BreakSibling();
					if( ndi_next ) {
						new_children.push_back(ndi_next);
					}
				}
				//COULDDO: case:, default:
				ndi = ndi_next;
			}
			if( !changed ) {
				ndi = nd_raw.c;
				while( ndi ) {
					ama::Node*+! ndi_next = ndi.s;
					if( ndi.node_class == ama::N_SYMBOL && ndi.data == "," ) {
						//after_cpp_macro=0
						changed = ',';
						ndi.BreakSibling();
						if( ndi_next ) {
							new_children.push_back(ndi_next);
						}
					}
					ndi = ndi_next;
				}
			}
			if( changed || (!nd_raw.isRawNode('{', '}') && nd_raw.c && nd_raw.c.s) ) {
				for(int! i = 0; i < new_children.length; i += 1) {
					ama::Node*+! nd_inner = ama::toSingleNode(new_children[i]);
					new_children[i] = nd_inner;
					new_children[i].indent_level = nd_inner.indent_level;
				}
				nd_raw.c = NULL;
				nd_raw.Insert(ama::POS_FRONT, ama::InsertMany(new_children));
			}
			//if( nd_raw.isRawNode('{', '}') && (changed == ';' || !nd_raw.c) ) {
			if( nd_raw.isRawNode('{', '}') && changed != ',' ) {
				ConvertToScope(nd_raw);
			}
		}
		return nd_root;
	}
	//do this before DelimitCLikeStatements
	private class IndentStackItem {
		int32_t! level;
		int32_t! lineno;
	};
	ama::Node*+! ConvertIndentToScope(ama::Node*+! nd_root, JSValue! options) {
		Map<char[|], int>! keywords_extension_clause = ama::GetPrioritizedList(options, "keywords_extension_clause");
		ama::Node*+[+]! scopes = nd_root.FindAll(ama::N_SCOPE, NULL);
		for(ama::Node*+! nd_raw : nd_root.FindAll(ama::N_RAW, NULL)) {
			if( nd_raw.isRawNode('{', '}') ) {
				scopes.push(nd_raw);
			}
		}
		scopes.push_back(nd_root);
		for(ama::Node*+! nd_scope : scopes) {
			ama::Node*+[+]! lines = new ama::Node*+[+]!();
			int! passed_newline = 1;
			lines.push_back(nd_scope.c);
			//delimit first
			for(ama::Node*+! ndi = nd_scope.c; ndi; ndi = ndi.s) {
				if( ndi.comments_before.indexOf('\n') >= 0 ) {
					passed_newline = 1;
				}
				if( passed_newline ) {
					if( ndi != lines.back() ) {
						lines.push_back(ndi.BreakSelf());
					}
					passed_newline = 0;
				}
				if( ndi.comments_after.indexOf('\n') >= 0 ) {
					passed_newline = 1;
				}
			}
			if( lines.length <= 1 ) { continue; }
			for(int! i = 0; i < lines.length; i += 1) {
				lines[i] = ama::toSingleNode(lines[i]);
				//console.log(i, lines[i].toSource());
			}
			//check indent levels after
			IndentStackItem![+]! istk = new IndentStackItem![+]!();
			istk.push(new IndentStackItem!{
				level: lines[0].indent_level,
				lineno: 0
			});
			ama::Node*+[+]! lines_out = new ama::Node*+[+]!();
			for(int! i = 0; i < lines.length; i += 1) {
				while( lines[i].indent_level < istk.back().level ) {
					if( istk.length <= 1 || lines[i].indent_level > istk[istk.length - 2].level ) {
						//bad indent
						istk.back().level = lines[i].indent_level;
					} else {
						FoldIndentGroup(keywords_extension_clause, lines_out, istk[istk.length - 2].level, istk.back().lineno, lines[i]);
						istk.pop();
					}
				}
				if( lines[i].indent_level > istk.back().level ) {
					istk.push(new IndentStackItem!{
						level: lines[i].indent_level,
						lineno: int32_t(lines_out.length)
					});
				}
				assert(!lines[i].s);
				lines_out.push_back(lines[i]);
			}
			while( istk.length > 1 ) {
				FoldIndentGroup(keywords_extension_clause, lines_out, istk[istk.length - 2].level, istk.back().lineno, NULL);
				istk.pop();
			}
			//merge scopes into surrounding raws
			ama::Node*+[+]! line_out_final = MergeScopesIntoStatements(keywords_extension_clause, lines_out);
			//replace old children
			for(ama::Node*+! ndi : line_out_final) {
				ndi.p = nd_scope;
				//if( ndi.s ) {
				//	console.log('has s', ndi.toSource());
				//}
				assert(!ndi.s);
			}
			nd_scope.c = NULL;
			nd_scope.Insert(ama::POS_FRONT, ama::InsertMany(line_out_final));
		}
		return nd_root;
	}
};
