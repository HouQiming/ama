// //// JC version: 3
#include <unicode.jch>
#include "./charset.jch"
#include "./literal.jch"

namespace ama {
	private const char[|]! g_hex = '0123456789abcdef';
	private const uint32_t[8]! g_hex_charset = ama::CreateCharSet('0-9A-Fa-f');
	char[+]! escapeJSString(char[...]! s) {
		const char[+]! ret = new char[+]!();
		ret.push('\'');
		for(char! ch : s) {
			switch( ch ) {
				default: {
					if( uint8_t(ch) >= uint8_t(' ') ) {
						ret.push(ch);
						break;
					} else {
						//*** PASS THROUGH ***
					}
					//*** PASS THROUGH ***
				}
				case char(0x7f): {
					ret.push('\\u00', ama::g_hex[intptr_t(ch >> 4) & 0xfL], ama::g_hex[intptr_t(ch) & 0xfL]);
					break;
				}
				case '\t': {
					ret.push('\\', 't');
					break;
				}
				case '\b': {
					ret.push('\\', 'b');
					break;
				}
				case '\r': {
					ret.push('\\', 'r');
					break;
				}
				case '\n': {
					ret.push('\\', 'n');
					break;
				}
				case '\\': {
					ret.push('\\', '\\');
					break;
				}
				case '\'': {
					ret.push('\\', '\'');
					break;
				}
			}
		}
		ret.push('\'');
		return <<ret;
	}
	//we don't have to be fully conformant here - this won't get executed when we convert C / C++ code
	char[+]! ParseJCString(char[...]! s) {
		if( !s.length || (s[0L] != '\'' && s[0L] != '"') ) {
			return new char[+]!(s);
		}
		const char[+]! ret = new char[+]!();
		for(mutable intptr_t! i = 1L; i < (s.length - 1L); ++i) {
			const char! ch = s[i];
			if( ch == '\\' ) {
				i += 1L;
				const char! ch_next = s[i];
				switch( ch_next ) {
					default: {
						// #'
						if( (s.length - i) >= 2L ) {
							ret.push(ch_next);
						}
						break;
					}
					case 'a': {
						ret.push('\u0007');
						break;
					}
					case 'b': {
						ret.push('\u0008');
						break;
					}
					case 't': {
						ret.push('\u0009');
						break;
					}
					case 'n': {
						ret.push('\u000a');
						break;
					}
					case 'v': {
						ret.push('\u000b');
						break;
					}
					case 'f': {
						ret.push('\u000c');
						break;
					}
					case 'r': {
						ret.push('\u000d');
						break;
					}
					case 'x': {
						// x##'
						if( (s.length - i) >= 4L ) {
							const char[3L]! tmp = new char[3L]!();
							tmp[0L] = s[i + 1L];
							tmp[1L] = s[i + 2L];
							ret.push(char(uint8_t(strtoull((char*)(tmp.data()), NULL, 16))));
						}
						i += 2L;
						break;
					}
					case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': {
						mutable int! oct = 0;
						oct = oct * 8 + int(int(ch_next) - 48);
						// ##'
						if( (s.length - i) >= 3L && s[i + 1L] >= '0' && s[i + 1L] <= '7' ) {
							i += 1L;
							oct = oct * 8 + int(s[i]) - 48;
						}
						if( (s.length - i) >= 3L && s[i + 1L] >= '0' && s[i + 1L] <= '7' ) {
							i += 1L;
							oct = oct * 8 + int(s[i]) - 48;
						}
						ret.push(char(uint8_t(uint32_t(oct))));
						break;
					}
					case 'u': {
						// u{#}'
						const char[9L]! tmp = new char[9L]!();
						if( (s.length - i) >= 5L && s[i + 1L] == '{' ) {
							i += 2L;
							const intptr_t! i0 = i;
							// #}'
							while( (s.length - i) >= 3L && (i - i0) <= 8L && ama::isInCharSet(g_hex_charset, uint32_t(s[i])) ) {
								i += 1L;
							}
							memcpy((void*+)(tmp.data()), (void*)(&s[i0]), i - i0);
							//the for skips the remaining }
						} else if( (s.length - i) >= 6L ) {
							// u####'
							memcpy((void*+)(tmp.data()), (void*)(&s[i + 1L]), 4L);
							i += 4L;
						}
						const int! codepoint = int32_t(int64_t(strtoull((char*)(tmp.data()), NULL, 16)));
						unicode::AppendUTF8Char(ret, codepoint);
						break;
					}
				}
			} else {
				ret.push(ch);
			}
		}
		return <<ret;
	}
};
