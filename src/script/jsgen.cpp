//@ama require('./jsgen.js')('ama',ParseCurrentFile()).Save('.cpp');
#include "./jsenv.hpp"
#pragma no_auto_header()
#pragma gen_begin(js_bindings)
namespace ama {
	auto NodeGet_node_class(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return JS_NewInt32(jsctx, nd->node_class);
	}
	auto NodeSet_node_class(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res0 = 0;
		if (JS_ToInt32(jsctx, &res0, val) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `val`");
		}
		nd->node_class = (uint8_t)(res0);
		return JS_UNDEFINED;
	}
	auto NodeGet_indent_level(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return JS_NewInt32(jsctx, nd->indent_level);
	}
	auto NodeSet_indent_level(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res1 = 0;
		if (JS_ToInt32(jsctx, &res1, val) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `val`");
		}
		nd->indent_level = res1;
		return JS_UNDEFINED;
	}
	auto NodeGet_tmp_flags(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return JS_NewInt32(jsctx, nd->tmp_flags);
	}
	auto NodeSet_tmp_flags(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res2 = 0;
		if (JS_ToInt32(jsctx, &res2, val) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `val`");
		}
		nd->tmp_flags = res2;
		return JS_UNDEFINED;
	}
	auto NodeGet_flags(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return JS_NewInt32(jsctx, nd->flags);
	}
	auto NodeSet_flags(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res3 = 0;
		if (JS_ToInt32(jsctx, &res3, val) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `val`");
		}
		nd->flags = res3;
		return JS_UNDEFINED;
	}
	auto NodeGet_data(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapString(nd->data);
	}
	auto NodeSet_data(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (JS_IsNull(val) || JS_IsUndefined(val)) {
			nd->data = "";
		} else {
			if (!JS_IsString(val)) {
				return JS_ThrowTypeError(jsctx, "string expected for `val`");
			}
			nd->data = ama::UnwrapString(val);
		};
		return JS_UNDEFINED;
	}
	auto NodeGet_comments_before(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapString(nd->comments_before);
	}
	auto NodeSet_comments_before(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (JS_IsNull(val) || JS_IsUndefined(val)) {
			nd->comments_before = "";
		} else {
			if (!JS_IsString(val)) {
				return JS_ThrowTypeError(jsctx, "string expected for `val`");
			}
			nd->comments_before = ama::UnwrapString(val);
		};
		return JS_UNDEFINED;
	}
	auto NodeGet_comments_after(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapString(nd->comments_after);
	}
	auto NodeSet_comments_after(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (JS_IsNull(val) || JS_IsUndefined(val)) {
			nd->comments_after = "";
		} else {
			if (!JS_IsString(val)) {
				return JS_ThrowTypeError(jsctx, "string expected for `val`");
			}
			nd->comments_after = ama::UnwrapString(val);
		};
		return JS_UNDEFINED;
	}
	auto NodeGet_c(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->c);
	}
	auto NodeSet_c(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		nd->c = ama::UnwrapNode(val);
		return JS_UNDEFINED;
	}
	auto NodeGet_s(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->s);
	}
	auto NodeSet_s(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		nd->s = ama::UnwrapNode(val);
		return JS_UNDEFINED;
	}
	auto NodeGet_p(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->p);
	}
	auto NodeSet_p(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		nd->p = ama::UnwrapNode(val);
		return JS_UNDEFINED;
	}
	auto NodeGet_v(JSContext* jsctx, JSValueConst this_val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->v);
	}
	auto NodeSet_v(JSContext* jsctx, JSValueConst this_val, JSValueConst val) {
		auto nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		nd->v = ama::UnwrapNode(val);
		return JS_UNDEFINED;
	}
	JSValue NodeCall_LastChildSP(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->LastChildSP());
	}
	JSValue NodeCall_setData(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (argc > 0 && !JS_IsNull(argv[0L])) {
			if (!JS_IsString((0 < argc ? argv[0L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNode(nd->setData(argc > 0 && !JS_IsNull(argv[0L]) ? ama::UnwrapString((0 < argc ? argv[0L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_setFlags(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res4 = 0;
		if (JS_ToInt32(jsctx, &res4, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		return ama::WrapNode(nd->setFlags(res4));
	}
	JSValue NodeCall_setCommentsBefore(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (argc > 0 && !JS_IsNull(argv[0L])) {
			if (!JS_IsString((0 < argc ? argv[0L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNode(nd->setCommentsBefore(argc > 0 && !JS_IsNull(argv[0L]) ? ama::UnwrapString((0 < argc ? argv[0L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_setCommentsAfter(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (argc > 0 && !JS_IsNull(argv[0L])) {
			if (!JS_IsString((0 < argc ? argv[0L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNode(nd->setCommentsAfter(argc > 0 && !JS_IsNull(argv[0L]) ? ama::UnwrapString((0 < argc ? argv[0L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_setIndent(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res5 = 0;
		if (JS_ToInt32(jsctx, &res5, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		return ama::WrapNode(nd->setIndent(res5));
	}
	JSValue NodeCall_AdjustIndentLevel(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res6 = 0;
		if (JS_ToInt32(jsctx, &res6, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		nd->AdjustIndentLevel(res6); return JS_UNDEFINED;
	}
	JSValue NodeCall_FreeASTStorage(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		nd->FreeASTStorage(); return JS_UNDEFINED;
	}
	JSValue NodeCall_DestroyForSymbol(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapString(nd->DestroyForSymbol());
	}
	JSValue NodeCall_Clone(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->Clone());
	}
	JSValue NodeCall_Unlink(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->Unlink());
	}
	JSValue NodeCall_ReplaceWith(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->ReplaceWith(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_ReplaceUpto(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->ReplaceUpto(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED)), ama::UnwrapNode((1 < argc ? argv[1L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_Insert(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (nd == NULL) {
			return JS_ThrowTypeError(jsctx, "cannot insert at a null node");
		}
		if (JS_IsNull(argv[1]) || JS_IsUndefined(argv[1])) {
			return JS_ThrowTypeError(jsctx, "cannot insert a null node");
		}
		int32_t res7 = 0;
		if (JS_ToInt32(jsctx, &res7, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		return ama::WrapNode(nd->Insert(res7, ama::UnwrapNode((1 < argc ? argv[1L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_Root(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->Root());
	}
	JSValue NodeCall_RootStatement(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->RootStatement());
	}
	JSValue NodeCall_ParentStatement(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->ParentStatement());
	}
	JSValue NodeCall_FirstChild(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->FirstChild());
	}
	JSValue NodeCall_LastChild(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->LastChild());
	}
	JSValue NodeCall_Prev(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->Prev());
	}
	JSValue NodeCall_Next(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->Next());
	}
	JSValue NodeCall_Parent(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->Parent());
	}
	JSValue NodeCall_isRawNode(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res8 = 0;
		if (JS_ToInt32(jsctx, &res8, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		int32_t res9 = 0;
		if (JS_ToInt32(jsctx, &res9, (1 < argc ? argv[1L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(1<argc?argv[1L]:JS_UNDEFINED)`");
		}
		return JS_NewInt32(jsctx, nd->isRawNode(res8, res9));
	}
	JSValue NodeCall_isMethodCall(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (argc > 0 && !JS_IsNull(argv[0L])) {
			if (!JS_IsString((0 < argc ? argv[0L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
			}
		}
		return JS_NewInt32(jsctx, nd->isMethodCall(argc > 0 && !JS_IsNull(argv[0L]) ? ama::UnwrapString((0 < argc ? argv[0L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_isSymbol(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (argc > 0 && !JS_IsNull(argv[0L])) {
			if (!JS_IsString((0 < argc ? argv[0L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
			}
		}
		return JS_NewInt32(jsctx, nd->isSymbol(argc > 0 && !JS_IsNull(argv[0L]) ? ama::UnwrapString((0 < argc ? argv[0L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_isRef(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (argc > 0 && !JS_IsNull(argv[0L])) {
			if (!JS_IsString((0 < argc ? argv[0L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
			}
		}
		return JS_NewInt32(jsctx, nd->isRef(argc > 0 && !JS_IsNull(argv[0L]) ? ama::UnwrapString((0 < argc ? argv[0L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_isAncestorOf(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return JS_NewInt32(jsctx, nd->isAncestorOf(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_Owning(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res10 = 0;
		if (JS_ToInt32(jsctx, &res10, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		return ama::WrapNode(nd->Owning(res10));
	}
	JSValue NodeCall_Owner(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->Owner());
	}
	JSValue NodeCall_CommonAncestor(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->CommonAncestor(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_Find(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res11 = 0;
		if (JS_ToInt32(jsctx, &res11, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		if (argc > 1 && !JS_IsNull(argv[1L])) {
			if (!JS_IsString((1 < argc ? argv[1L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(1<argc?argv[1L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNode(nd->Find(res11, argc > 1 && !JS_IsNull(argv[1L]) ? ama::UnwrapString((1 < argc ? argv[1L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_FindAll(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res12 = 0;
		if (JS_ToInt32(jsctx, &res12, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		if (argc > 1 && !JS_IsNull(argv[1L])) {
			if (!JS_IsString((1 < argc ? argv[1L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(1<argc?argv[1L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNodeArray(nd->FindAll(res12, argc > 1 && !JS_IsNull(argv[1L]) ? ama::UnwrapString((1 < argc ? argv[1L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_FindAllWithin(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res13 = 0;
		if (JS_ToInt32(jsctx, &res13, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		int32_t res14 = 0;
		if (JS_ToInt32(jsctx, &res14, (1 < argc ? argv[1L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(1<argc?argv[1L]:JS_UNDEFINED)`");
		}
		if (argc > 2 && !JS_IsNull(argv[2L])) {
			if (!JS_IsString((2 < argc ? argv[2L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(2<argc?argv[2L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNodeArray(nd->FindAllWithin(res13, res14, argc > 2 && !JS_IsNull(argv[2L]) ? ama::UnwrapString((2 < argc ? argv[2L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_FindAllBefore(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res15 = 0;
		if (JS_ToInt32(jsctx, &res15, (1 < argc ? argv[1L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(1<argc?argv[1L]:JS_UNDEFINED)`");
		}
		int32_t res16 = 0;
		if (JS_ToInt32(jsctx, &res16, (2 < argc ? argv[2L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(2<argc?argv[2L]:JS_UNDEFINED)`");
		}
		if (argc > 3 && !JS_IsNull(argv[3L])) {
			if (!JS_IsString((3 < argc ? argv[3L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(3<argc?argv[3L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNodeArray(nd->FindAllBefore(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED)), res15, res16, argc > 3 && !JS_IsNull(argv[3L]) ? ama::UnwrapString((3 < argc ? argv[3L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_GetStringValue(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapString(nd->GetStringValue());
	}
	JSValue NodeCall_GetName(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapString(nd->GetName());
	}
	JSValue NodeCall_dot(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (argc > 0 && !JS_IsNull(argv[0L])) {
			if (!JS_IsString((0 < argc ? argv[0L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNode(nd->dot(argc > 0 && !JS_IsNull(argv[0L]) ? ama::UnwrapString((0 < argc ? argv[0L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_toSource(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapString(nd->toSource());
	}
	JSValue NodeCall_dump(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapString(nd->dump());
	}
	JSValue NodeCall_InsertDependency(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res17 = 0;
		if (JS_ToInt32(jsctx, &res17, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		if (argc > 1 && !JS_IsNull(argv[1L])) {
			if (!JS_IsString((1 < argc ? argv[1L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(1<argc?argv[1L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNode(nd->InsertDependency(res17, argc > 1 && !JS_IsNull(argv[1L]) ? ama::UnwrapString((1 < argc ? argv[1L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_InsertCommentBefore(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (argc > 0 && !JS_IsNull(argv[0L])) {
			if (!JS_IsString((0 < argc ? argv[0L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
			}
		}
		return ama::WrapNode(nd->InsertCommentBefore(argc > 0 && !JS_IsNull(argv[0L]) ? ama::UnwrapString((0 < argc ? argv[0L] : JS_UNDEFINED)) : ""));
	}
	JSValue NodeCall_MergeCommentsBefore(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->MergeCommentsBefore(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_MergeCommentsAfter(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->MergeCommentsAfter(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_MergeCommentsAndIndentAfter(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->MergeCommentsAndIndentAfter(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_Validate(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		nd->Validate(); return JS_UNDEFINED;
	}
	JSValue NodeCall_ValidateEx(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res18 = 0;
		if (JS_ToInt32(jsctx, &res18, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		int32_t res19 = 0;
		if (JS_ToInt32(jsctx, &res19, (1 < argc ? argv[1L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(1<argc?argv[1L]:JS_UNDEFINED)`");
		}
		return JS_NewInt32(jsctx, nd->ValidateEx(res18, res19));
	}
	JSValue NodeCall_ValidateChildCount(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		int32_t res20 = 0;
		if (JS_ToInt32(jsctx, &res20, (0 < argc ? argv[0L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
		}
		int32_t res21 = 0;
		if (JS_ToInt32(jsctx, &res21, (1 < argc ? argv[1L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(1<argc?argv[1L]:JS_UNDEFINED)`");
		}
		return JS_NewInt32(jsctx, nd->ValidateChildCount(res20, res21));
	}
	JSValue NodeCall_BreakSibling(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->BreakSibling());
	}
	JSValue NodeCall_BreakChild(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->BreakChild());
	}
	JSValue NodeCall_BreakSelf(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->BreakSelf());
	}
	JSValue NodeCall_toSingleNode(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->toSingleNode());
	}
	JSValue NodeCall_PreorderNext(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->PreorderNext(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_PreorderSkip(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->PreorderSkip());
	}
	JSValue NodeCall_PostorderFirst(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->PostorderFirst());
	}
	JSValue NodeCall_PostorderNext(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->PostorderNext(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED))));
	}
	JSValue NodeCall_Unparse(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return ama::WrapNode(nd->Unparse());
	}
	JSValue NodeCall_FormatFancyMessage(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		if (argc > 0 && !JS_IsNull(argv[0L])) {
			if (!JS_IsString((0 < argc ? argv[0L] : JS_UNDEFINED))) {
				return JS_ThrowTypeError(jsctx, "string expected for `(0<argc?argv[0L]:JS_UNDEFINED)`");
			}
		}
		int32_t res22 = 0;
		if (JS_ToInt32(jsctx, &res22, (1 < argc ? argv[1L] : JS_UNDEFINED)) < 0) {
			return JS_ThrowTypeError(jsctx, "int expected for `(1<argc?argv[1L]:JS_UNDEFINED)`");
		}
		return ama::WrapString(nd->FormatFancyMessage(argc > 0 && !JS_IsNull(argv[0L]) ? ama::UnwrapString((0 < argc ? argv[0L] : JS_UNDEFINED)) : "", res22));
	}
	JSValue NodeCall_ComputeLineNumber(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return JS_NewInt32(jsctx, nd->ComputeLineNumber());
	}
	JSValue NodeCall_GetCFGRole(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return JS_NewInt32(jsctx, nd->GetCFGRole());
	}
	JSValue NodeCall_isChildCFGDependent(JSContext* jsctx, JSValueConst this_val, int argc, JSValueConst* argv) {
		ama::Node* nd = (ama::Node*)(JS_GetOpaque(this_val, ama::g_node_classid));
		return JS_NewInt32(jsctx, nd->isChildCFGDependent(ama::UnwrapNode((0 < argc ? argv[0L] : JS_UNDEFINED))));
	}
	char const *g_builtin_modules[] = {
		"_cmdline", "'use strict';\n//command line --foo command resolver\nlet _cmdline = module.exports;\n\n_cmdline.help = function(argv) {\n\tconsole.log([\n\t\t\"  ama [options] files          = process files with options\",\n\t\t\"      -f filter                = add a filter\",\n\t\t\"      -o path                  = write output to path\",\n\t\t\"      -s script                = run the script\",\n\t].join('\\n'));\n\tfor (let key in _cmdline) {\n\t\tif (_cmdline[key].usage) {\n\t\t\tconsole.log([\n\t\t\t\t'  ama --', key, _cmdline[key].usage,\n\t\t\t].join(''));\n\t\t}\n\t}\n\tconsole.log('\\nList of filters:');\n\tconst path = require('path');\n\tfor (let fn of __builtin_module_names) {\n\t\t//if (!fn.endsWith('.js')) {continue;}\n\t\tlet nd_root = ParseCode(__GetBuiltinModuleCode(fn));\n\t\tif (!nd_root) {continue;}\n\t\tfor (let nd_func of nd_root.FindAll(N_FUNCTION)) {\n\t\t\tlet s = nd_func.ParentStatement().comments_before;\n\t\t\tlet p_filter = s.indexOf('#filter');\n\t\t\tif (p_filter < 0) {continue;}\n\t\t\tlet fn_require = fn;\n\t\t\tlet name = nd_func.data;\n\t\t\tif (!name && nd_func.p.node_class == N_ASSIGNMENT) {\n\t\t\t\tname = nd_func.p.c.GetName();\n\t\t\t}\n\t\t\tif (name == 'Translate') {name = '';}\n\t\t\tif (name == 'exports') {name = '';}\n\t\t\tif (name) {\n\t\t\t\tfn_require = fn_require + '.' + name;\n\t\t\t}\n\t\t\tlet pnewline = s.indexOf('\\n', p_filter);\n\t\t\tlet brief = s.substr(p_filter + 7, pnewline - p_filter - 7).trim();\n\t\t\tconsole.log(['  ', fn_require, ' '.repeat(Math.max(37 - fn_require.length, 1)), brief].join(''));\n\t\t}\n\t}\n};\n_cmdline.help.usage = '                   = print this help';\n\n/////////////////////////////////\nfunction isFile(path) {\n\tconst fs = require('fs');\n\tlet stat = {};\n\ttry {\n\t\tstat = fs.statSync(path);\n\t} catch (e) {};\n\treturn !!stat.is_file;\n}\n\nfunction ComputeProjectDir(dir0) {\n\tconst path = require('path');\n\tconst fs = require('fs');\n\tconst fsext = require('fsext');\n\tlet dir = dir0;\n\tfor (; ;) {\n\t\tif (fs.existsSync(path.join(dir, '.git'))) {\n\t\t\treturn dir;\n\t\t}\n\t\tif (fs.existsSync(path.join(dir, '.svn'))) {\n\t\t\treturn dir;\n\t\t}\n\t\tlet dir_next = path.dirname(dir);\n\t\tif (dir_next == dir) {break;}\n\t\tdir = dir_next;\n\t}\n\treturn isFile(dir0) ? path.dirname(dir0) : dir0;\n}\n\nlet g_exts = {\n\t'.cpp': ['.cpp', '.hpp', '.cu'],\n\t'.hpp': ['.cpp', '.hpp', '.cu'],\n\t'.cu': ['.cpp', '.hpp', '.cu'],\n\t'.cc': ['.cc', '.hh'],\n\t'.hh': ['.cc', '.hh'],\n\t'.cxx': ['.cxx', '.hxx'],\n\t'.hxx': ['.cxx', '.hxx'],\n\t'.c': ['.c', '.h'],\n\t'.h': ['.c', '.h'],\n\t'.m': ['.m', '.c', '.h'],\n\t'.mm': ['.mm', '.cpp', '.hpp', '.cu'],\n};\n_cmdline.init = function(argv) {\n\tconst path = require('path');\n\tconst depends = require('depends');\n\tconst fsext = require('fsext');\n\tconst fs = require('fs');\n\tconst pipe = require('pipe');\n\tlet fn_init = argv[2] || '.';\n\tlet is_file = isFile(fn_init);\n\tlet dir = ComputeProjectDir(fn_init);\n\tlet fn_sync_js = path.resolve(dir, 'script/sync.js');\n\tif (fs.existsSync(fn_sync_js)) {\n\t\tconsole.log('already initialized');\n\t} else {\n\t\t//generate list of features on the fly\n\t\tlet feature_code = [];\n\t\t//for (let fn of fsext.FindAllFiles(__dirname).sort())\n\t\tfor (let fn of __builtin_module_names) {\n\t\t\t//if (!fn.endsWith('.js')) {continue;}\n\t\t\tlet nd_root = ParseCode(__GetBuiltinModuleCode(fn));\n\t\t\tif (!nd_root) {continue;}\n\t\t\tfor (let nd_func of nd_root.FindAll(N_FUNCTION)) {\n\t\t\t\tlet s = nd_func.ParentStatement().comments_before;\n\t\t\t\tlet p_filter = s.indexOf('#filter');\n\t\t\t\tif (p_filter < 0) {continue;}\n\t\t\t\tlet fn_require = fn.replace(/[.].*/, '');\n\t\t\t\tlet name = nd_func.data;\n\t\t\t\tif (!name && nd_func.p.node_class == N_ASSIGNMENT) {\n\t\t\t\t\tname = nd_func.p.c.GetName();\n\t\t\t\t}\n\t\t\t\tif (name == 'Translate') {name = '';}\n\t\t\t\tif (name == 'exports') {name = '';}\n\t\t\t\tlet pnewline = s.indexOf('\\n', p_filter);\n\t\t\t\tlet brief = s.substr(p_filter + 7, pnewline - p_filter - 7).trim();\n\t\t\t\tlet s_prefix = '//';\n\t\t\t\tif (s.indexOf('#default on') >= 0) {\n\t\t\t\t\ts_prefix = '';\n\t\t\t\t}\n\t\t\t\tfeature_code.push(\n\t\t\t\t\ts_prefix, 'require(', JSON.stringify(fn_require), ')', name ? '.' + name : '', ', //', brief, '\\n'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tlet processed_extensions = ['.cpp', '.hpp', '.cu'];\n\t\tif (is_file && path.extname(fn_init)) {\n\t\t\tlet new_exts = g_exts[path.extname(fn_init)];\n\t\t\tif (new_exts) {\n\t\t\t\tprocessed_extensions = new_exts;\n\t\t\t} else {\n\t\t\t\tprocessed_extensions = [path.extname(fn_init)];\n\t\t\t}\n\t\t}\n\t\t//generate sync.js\n\t\tif (feature_code.length) {feature_code.pop();}\n\t\tlet dir_sync_js = path.dirname(fn_sync_js);\n\t\tpipe.run((__platform == 'win32' ? 'md ' : 'mkdir -p ') + dir_sync_js);\n\t\tfs.writeFileSync(fn_sync_js, '#!/usr/bin/env ama\\n' + nSemicolon(nCall(nCall(nRef(\"require\"), nString(\"bisync\").setFlags(3)), nScope(nLabeled(nRef(\"dir_src\"), nCall(nDot(\"resolve\", nCall(nRef(\"require\"), nString(\"path\").setFlags(3))), nRef(\"__dirname\"), nString(\"..\").setFlags(3).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSymbol(\",\").setIndent(4), nLabeled(nRef(\"processed_extensions\"), (ParseCode(JSON.stringify(processed_extensions))).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSymbol(\",\").setIndent(4), nLabeled(nRef(\"features\"), nRaw((nRaw(nAir().setCommentsBefore(feature_code.join('')))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setFlags(23899).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))))/*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*/.toSource() + '\\n');\n\t\tconsole.log('created', fn_sync_js);\n\t}\n\tlet ret = ProcessAmaFile(fn_sync_js, '');\n\tif (ret <= 0) {\n\t\tthrow new Error('but failed to run it');\n\t}\n};\n_cmdline.init.usage = ' [dir]             = set up a project dir, defaults to ./';\n\n_cmdline.build = function(argv) {\n\tconst path = require('path');\n\tconst depends = require('depends');\n\tconst fsext = require('fsext');\n\tconst fs = require('fs');\n\tconst pipe = require('pipe');\n\tconst cmake = require('cmake');\n\tif (argv[2] && argv[2].startsWith('--')) {\n\t\targv.splice(2, 0, '.');\n\t}\n\tlet fn_init = argv[2] || '.';\n\tlet dir = ComputeProjectDir(fn_init);\n\tlet fn_sync_js = path.resolve(dir, 'script/sync.js');\n\tif (fs.existsSync(fn_sync_js)) {\n\t\tlet ret = ProcessAmaFile(fn_sync_js, '');\n\t\tif (ret <= 0) {\n\t\t\tthrow new Error('failed to synchronize ama files');\n\t\t}\n\t} else if (isFile(fn_init)) {\n\t\tlet ret = ProcessAmaFile(fn_init, '__pipeline.push(require(\"cmake\").AutoCreate);');\n\t\tif (ret <= 0) {\n\t\t\tthrow new Error('failed to synchronize ama files');\n\t\t}\n\t}\n\tlet options = {};\n\toptions.cmakelist_path = path.resolve(dir, 'CMakeLists.txt');\n\tif (!fs.existsSync(options.cmakelist_path)) {\n\t\tfor (let fn of fsext.FindAllFiles(dir)) {\n\t\t\tif (path.basename(fn).toLowerCase() == 'cmakelists.txt') {\n\t\t\t\toptions.cmakelist_path = fn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!options.cmakelist_path) {\n\t\tthrow new Error('cannot find CMakeLists.txt');\n\t}\n\tif (isFile(fn_init)) {\n\t\toptions.target = path.parse(fn_init).name;\n\t} else {\n\t\t//run the first executable\n\t\tlet nd_cmake = require('cmake').LoadCMakeFile(options.cmakelist_path);\n\t\tlet nd_target = nd_cmake.Find(N_CALL, 'add_executable');\n\t\tif (nd_target) {\n\t\t\tlet nd_name = nd_target.c.s.Find(N_REF);\n\t\t\tif (nd_name) {\n\t\t\t\toptions.target = nd_name.data;\n\t\t\t}\n\t\t}\n\t}\n\tlet extra_args = [];\n\toptions.extra_args = extra_args;\n\tfor (let i = 3; i < argv.length; i++) {\n\t\tif (argv[i] == '--clean-first') {\n\t\t\toptions.rebuild = 1;\n\t\t} else if (argv[i] == '--type') {\n\t\t\toptions.build = argv[i + 1];\n\t\t\ti += 1;\n\t\t} else if (argv[i] == '--run') {\n\t\t\toptions.run = [];\n\t\t\textra_args = options.run;\n\t\t} else {\n\t\t\textra_args.push(argv[i]);\n\t\t}\n\t}\n\tcmake.Build(options);\n};\n_cmdline.build.usage = [\n\t' [path] [options] = build a project dir or file, defaults to ./, options:',\n\t'      --type CMAKE_BUILD_TYPE  = specify build type, e.g., Debug / RelWithDebInfo',\n\t'      --clean-first            = rebuild from scratch',\n\t'      --run [args]             = run the result after build'\n].join('\\n');\n",
		"_init", "'use strict';\n//this module is automatically executed by ama::InitScriptEnv()\n//the `require` system isn't ready here so don't use it\n//@ama ParseCurrentFile().Save()\n(function() {\n/////////////\nNode.setFlags = function(flags) {\n\tthis.flags = flags;\n\treturn this;\n}\n\nNode._isRawNode = Node.isRawNode;\nNode.isRawNode = function(s0, s1) {\n\tif (typeof(s0) === 'string') {s0 = s0.charCodeAt(0);}\n\tif (typeof(s1) === 'string') {s1 = s1.charCodeAt(0);}\n\treturn this._isRawNode(s0, s1);\n}\n\nNode.setData = function(data) {\n\tthis.data = data;\n\treturn this;\n}\n\nNode.setIndent = function(indent_level) {\n\tthis.indent_level = indent_level;\n\treturn this;\n}\n\nNode.setCommentsBefore = function(comments_before) {\n\tthis.comments_before = comments_before;\n\treturn this;\n}\n\nNode.setCommentsAfter = function(comments_after) {\n\tthis.comments_after = comments_after;\n\treturn this;\n}\n\n//Create `N_CALL` with `nd` as the function and `args` as arguments.\nNode.call = function(...args) {\n\treturn nCall.apply(null, [this].concat(args));\n}\n\n//Return an enclosure of the current node in `s_brackets`. `s_brackets` can be '[]' or '()'.\nNode.enclose = function(s_brackets) {\n\treturn nRaw(this).setFlags((s_brackets.charCodeAt(0) & 0xff) | (s_brackets.charCodeAt(1) & 0xff) << 8);\n}\n\n//Chainable syntax sugar for `f(nd, ...args)`.\nNode.then = function(f, ...args) {\n\tlet ret = f.apply(null, [this].concat(args));\n\tif (ret === undefined) {\n\t\tret = this;\n\t}\n\treturn ret;\n}\n\n//Callback for `JSON.stringify(nd)`. The resulting JSON is for human inspection only and not useful when parsed back.\nNode.toJSON = function() {\n\tlet children = [];\n\tfor (let ndi = this.c; ndi; ndi = ndi.s) {\n\t\tchildren.push(ndi);\n\t}\n\treturn {\n\t\t\"[node_class]\": __node_class_names[this.node_class],\n\t\tdata: this.data || undefined,\n\t\tflags: this.flags || undefined,\n\t\tindent_level: this.indent_level || undefined,\n\t\tcomments_before: this.comments_before || undefined,\n\t\tcomments_after: this.comments_after || undefined,\n\t\t\"children\": children,\n\t}\n}\n\nNode.dfsMatch = function(ret, nd_pattern) {\n\tif (nd_pattern.node_class === N_NODEOF) {\n\t\tlet nd_save = nd_pattern.c;\n\t\tif (nd_save.node_class === N_REF) {\n\t\t\t//name\n\t\t\tret[nd_save.data] = this;\n\t\t} else if(nd_save.node_class === N_CALL && nd_save.c.s && !nd_save.c.s.s) {\n\t\t\t//N_FOO(name)\n\t\t\tif (this.node_class !== __global[nd_save.GetName()]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tret[nd_save.c.s.GetName()] = this;\n\t\t} else if(nd_save.node_class === N_DOT) {\n\t\t\tif (this.node_class !== N_DOT) {return false;}\n\t\t\tif (!this.c.dfsMatch(ret, nd_save.c)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tret[nd_save.GetName()] = nRef(this.data);\n\t\t} else {\n\t\t\tthrow new Error('invalid pattern: ' + nd_pattern.dump())\n\t\t\t}\n\t\treturn true;\n\t}\n\tif (this.node_class !== nd_pattern.node_class || this.data !== nd_pattern.data) {\n\t\treturn false;\n\t}\n\tlet ndj = nd_pattern.c;\n\tfor (let ndi = this.c; ndi; ndi = ndi.s) {\n\t\tif (!ndj) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!ndi.dfsMatch(ret, ndj)) {\n\t\t\treturn false;\n\t\t}\n\t\tndj = ndj.s;\n\t}\n\tif (ndj) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n//Match a code template specified by `nd_pattern`.\n//`nd.Match` only checks `nd` itself. `nd.MatchAll` matches the pattern against the entire subtree under `nd` and returns an array of matches.\n//\n//The returned match objects have the shape `{nd:<matched node>}`\nNode.Match = function(nd_pattern) {\n\tlet ret = {nd: this};\n\tif (this.dfsMatch(ret, nd_pattern)) {\n\t\treturn ret;\n\t} else {\n\t\treturn undefined;\n\t}\n}\n\nNode.MatchAll = function(nd_pattern) {\n\treturn this.FindAll(nd_pattern.node_class, nd_pattern.data).map(nd=>nd.Match(nd_pattern)).filter(ret=>ret);\n}\n\n//Wildcards for template matching. You can invoke the patterns with nested `@()` inside `@()`.\n//\n//MatchAny matches any node of an optional node class and saves the result in the `name` property of the returned match.\n//\n//For example, this code:\n//```Javascript\n//let nd_source = @(test(3));\n//nd_source.Match(\n//    @(test(@(Node.MatchAny(\"val\"))))\n//)\n//```\n//will return `{nd:nd_source,val:nd_source.Find(N_NUMBER, '3')}`.\nNode.MatchAny = function(/*optional*/node_class, name) {\n\tif (name === undefined) {\n\t\t//node_class is actually the name\n\t\treturn nNodeof(nRef(node_class));\n\t} else {\n\t\treturn nNodeof(nCall(nRef(__node_class_names[node_class]), nRef(name)));\n\t}\n}\n\nNode.MatchDot = function(nd_object, name) {\n\treturn nNodeof(nd_object.dot(name));\n}\n\n//Substitution a match into the code template specified by `nd`.\n//`@(foo)` under `nd` will be replaced with `match.foo`.\n//\n//For example, this code:\n//```Javascript\n//let nd_source = @(test(@(val)));\n//nd_source.Subst({val:nNumber(3)})\n//```\n//will return `@(test(3))`\nNode.Subst = function(match) {\n\tlet nd_ret = this.Clone();\n\tfor (let ndi = nd_ret; ndi; ndi = ndi.PreorderNext(null)) {\n\t\tif (ndi.node_class === N_NODEOF) {\n\t\t\tlet nd_name = ndi.c;\n\t\t\tif (nd_name.node_class === N_DOT) {\n\t\t\t\tlet nd_subst = nd_name.c.Subst(match).dot(match[nd_name.GetName()].GetName() || '');\n\t\t\t\tnd_subst.BreakSibling();\n\t\t\t\tndi = ndi.ReplaceWith(nd_subst);\n\t\t\t} else {\n\t\t\t\tif (nd_name.node_class === N_CALL && nd_name.c.s) {nd_name = nd_name.c.s;}\n\t\t\t\tlet nd_subst = match[nd_name.GetName()];\n\t\t\t\tif (nd_subst) {\n\t\t\t\t\t//nd_subst.BreakSibling();\n\t\t\t\t\tndi = ndi.ReplaceWith(nd_subst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nd_ret;\n}\n\n//Save the node. `options` can be:\n//- A string starting with '.' interpreted as a new extension\n//- A string specifying a full path\n//- An object with saving options, see [Parsing Options](#-parsing-options). `options.name` is the full path\n//For example, `nd.Save('.audit.cpp')` saves the current AST into a new file with the same file name as `nd.Root().data` and extension '.audit.cpp'.\nNode.Save = function(/*optional*/options) {\n\tif (typeof(options) === 'string') {\n\t\tif (options.startsWith('.')) {\n\t\t\toptions = {change_ext: options};\n\t\t} else {\n\t\t\toptions = {full_path: options};\n\t\t}\n\t}\n\tif (!options) {\n\t\toptions = Object.create(__global.default_options);\n\t}\n\tif (options.change_ext) {\n\t\t//we need to handle .ama.js => .js shenanigans, so remove everything after the *first* dot\n\t\tlet pdot = this.data.indexOf('.',Math.max(this.data.lastIndexOf('/'),this.data.lastIndexOf('\\\\'),0));\n\t\tif (pdot < 0) {pdot = this.data.length;}\n\t\toptions.full_path = this.data.substr(0, pdot) + (options.change_ext.startsWith('.') ? '' : '.') + options.change_ext;\n\t\toptions.change_ext = undefined;\n\t}\n\tlet content = this.toSource(options);\n\tlet name = options.full_path || this.data;\n\t//console.log(name,options);\n\t__writeFileSync(name, content);\n\treturn this;\n}\n\nNode.Print = function(options) {\n\tconsole.write(this.toSource(options));\n}\n\n//Remove redundant spaces from the AST, if `aggressive` is true, also remove newlines.\nNode.StripRedundantPrefixSpace = function(aggressive) {\n\tif(typeof(aggressive)==='object'){\n\t\taggressive=aggressive.strip_spaces_aggressively;\n\t}\n\tfunction isSpace(s){\n\t\treturn s&&!s.trim()&&(aggressive||s.indexOf('\\n')<0);\n\t}\n\tfor (let ndi = this; ndi; ndi = ndi.PreorderNext(this)) {\n\t\tif(ndi.node_class===N_KEYWORD_STATEMENT&&ndi.data==='#define'){\n\t\t\tndi=ndi.PreorderSkip();\n\t\t\tcontinue;\n\t\t}\n\t\tif (isSpace(ndi.comments_before)){\n\t\t\tif(ndi.p && (\n\t\t\t\tndi.p.node_class === N_CALL || ndi.p.node_class === N_CALL_TEMPLATE || \n\t\t\t\tndi.p.node_class === N_BINOP || ndi.p.node_class === N_ASSIGNMENT ||\n\t\t\t\tndi.p.node_class === N_PARAMETER_LIST ||\n\t\t\t\tndi.node_class===N_PAREN||ndi.node_class===N_SCOPE||ndi.node_class===N_STRING||\n\t\t\t\tndi.node_class===N_EXTENSION_CLAUSE\n\t\t\t)) {\n\t\t\t\tndi.comments_before = '';\n\t\t\t}else if(aggressive){\n\t\t\t\tndi.comments_before = ndi.comments_before.indexOf('\\n')>=0?'\\n':' ';\n\t\t\t}\n\t\t}\n\t\tif (isSpace(ndi.comments_after)){\n\t\t\tif(ndi.p && (\n\t\t\t\tndi.p.node_class === N_CALL || ndi.p.node_class === N_CALL_TEMPLATE || \n\t\t\t\tndi.p.node_class === N_BINOP || ndi.p.node_class === N_ASSIGNMENT ||\n\t\t\t\tndi.p.node_class === N_PARAMETER_LIST ||\n\t\t\t\tndi.node_class===N_PAREN||ndi.node_class===N_SCOPE||ndi.node_class===N_STRING\n\t\t\t)) {\n\t\t\t\tndi.comments_after = '';\n\t\t\t}else if(aggressive){\n\t\t\t\tndi.comments_after = ndi.comments_after.indexOf('\\n')>=0?'\\n':' ';\n\t\t\t}\n\t\t}\n\t}\n\treturn this;\n}\nNode.StripRedundantPrefixSpace.inverse=Node.StripRedundantPrefixSpace;\n\n//Perform template substitution. `match_jobs` is an array with objects in the form `{from:Node, to:Node}`.\n//Each match of the `from` pattern will be replaced with its parameters substituted into the corresponding `to` pattern with `Node.Subst`.\n//\n//If `is_forward` is false, do it backwards.\nNode.TranslateTemplates = function(match_jobs, is_forward) {\n\tlet nd_root = this;\n\tfor (let ndi = nd_root; ndi; ndi = ndi.PreorderNext(nd_root)) {\n\t\tfor (let job of match_jobs) {\n\t\t\tlet match = ndi.Match(is_forward ? job.from : job.to);\n\t\t\tif (match) {\n\t\t\t\tfor (let param in match) {\n\t\t\t\t\tif (param !== 'nd' && match[param].s) {match[param].BreakSibling();}\n\t\t\t\t}\n\t\t\t\tndi = ndi.ReplaceWith((is_forward ? job.to : job.from).Subst(match));\n\t\t\t\tif (match.nd === nd_root) {\n\t\t\t\t\tnd_root = ndi;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn nd_root;\n}\n\n//Return the name of `N_FUNCTION`. Returns an empty string if the function is unnamed.\nNode.GetFunctionNameNode=function() {\n\tif(this.node_class !== N_FUNCTION){return undefined;}\n\tlet nd_name = this.c;\n\tif (nd_name.node_class === N_RAW) {\n\t\tnd_name = nd_name.LastChild();\n\t}\n\tif (nd_name && nd_name.node_class !== N_REF && nd_name.node_class !== N_DOT) {\n\t\treturn undefined;\n\t}\n\treturn nd_name;\n}\n\n__global.default_options = {\n\t//The default_options tries to be generic enough for any language.\n\t/////////////////////////\n\t//whether to enable `#foo` comments\n\tenable_hash_comment: 0,\n\tsymbols: '!== != && ++ -- -> ... .. :: << <= === == => >= >>> >> || <=> ** .* ->* <<<',\n\t//we treat # as an identifier character to make C stuff like `#define` more idiosyncratic\n\tidentifier_charset: '0-9A-Za-z_$#',\n\tnumber_charset: '0-9bouUlLfFn.eE',\n\thex_number_charset: '0-9A-Fa-fx.pPuUlLn',\n\texponent_charset: '0-9f',\n\t//could use 'dgimsuy', but a later JS standard could extend it\n\tregexp_flags_charset: 'A-Za-z',\n\t//we don't really look up the Unicode tables: enable_unicode_identifiers means \"all high bytes are treated as identifiers\"\n\tenable_unicode_identifiers: 1,\n\t//if enabled, auto finish dangling strings / parenthesis\n\tfinish_incomplete_code: 0,\n\t///////////\n\t//flags controlling individual features\n\tparse_operators: 1,\n\tparse_pointed_brackets: 1,\n\tparse_scoped_statements: 1,\n\tparse_keyword_statements: 1,\n\tparse_colon_statements: 1,\n\tparse_cpp11_lambda: 1,\n\tparse_declarations: 1,\n\tparse_cpp_declaration_initialization: 1,\n\tparse_c_conditional: 1,\n\tparse_labels: 1,\n\tparse_air_object: 1,\n\tparse_indent_as_scope: 0,\n\tparse_indent_as_scope_but_merge_cpp_ctor_lines: 0,\n\tparse_c_forward_declarations: 1,\n\tstruct_can_be_type_prefix: 1,\n\tparse_js_regexp: 1,\n\tenable_c_include: 1,\n\tenable_js_require: 1,\n\t///////////\n\t//binary operators, each \\n denotes a change of priority level, it must be followed by a ' '\n\t//the 'of' operator is a hack to improve JS for-of parsing\n\tbinary_operators: '||\\n &&\\n |\\n ^\\n &\\n == != === !==\\n < <= > >= in of instanceof\\n <=>\\n << >> >>>\\n + -\\n * / %\\n **\\n as\\n .* ->*\\n',\n\tprefix_operators: '++ -- ! ~ + - * && & typeof void delete sizeof await co_await new const volatile unsigned signed long short',\n\tpostfix_operators: 'const volatile ++ --',\n\tcv_qualifiers: 'const volatile',\n\t//the JS `void` is too common in C/C++ to be treated as an operator by default\n\tnamed_operators: 'typeof delete sizeof await co_await new in of instanceof as const volatile',\n\t//unlike generic named_operators, c_type_prefix_operators only make sense when used before another identifier\n\tc_type_prefix_operators: 'unsigned signed long short',\n\tambiguous_type_suffix: '* ** ^ & &&',\n\t///////////\n\tkeywords_class: 'class struct union namespace interface impl trait',\n\tkeywords_scoped_statement: 'enum if for while do try switch',\n\tkeywords_extension_clause: 'until else elif except catch finally while',\n\tkeywords_function: 'extern function fn def inline',\n\tkeywords_after_class_name: ': extends implements for where',\n\tkeywords_after_prototype: ': -> => throw const noexcept override',\n\tkeywords_not_a_function: 'switch case #define #if #else #elif return',\n\tkeywords_not_variable_name: 'static const volatile private public protected final noexcept throw override virtual operator',\n\t//`case` is better treated as a part of a label\n\t//`template` is parsed by the non-scoped statement parser, but it's created as N_SCOPED_STATEMENT\n\tkeywords_statement: 'return typedef using throw goto #pragma #define #undef #if #ifdef #ifndef #elif #else #endif #line break continue template',\n\tkeywords_operator_escape: 'operator',\n\t///////////\n\t//codegen\n\ttab_width: 4,\n\ttab_indent: 2, //2 for auto\n\tauto_space: 1,\n\tauto_curly_bracket: 0,\n};\n\nNode.SmartConvertIndentToScope=function(options){\n\tif(options.parse_indent_as_scope){\n\t\tthis.ConvertIndentToScope(options);\n\t}\n\treturn this;\n}\n\n__global.default_pipeline=[\n\t'ParseSimplePairing',\n\t'SmartConvertIndentToScope',\n\t'ParsePointedBrackets',\n\t'DelimitCLikeStatements',\n\t//from here on, N_RAW no longer includes the root scope\n\t'CleanupDummyRaws',\n\t'ConvertRootToFile',\n\t'ParseDependency',\n\t'ParsePostfix',\n\t'SanitizeCommentPlacement',\n\t'CleanupDummyRaws',\n\t'ParseKeywordStatements',\n\t'ParseScopedStatements',\n\t'ParseAssignment',\n\t'ParseColons',\n\t'ParseOperators',\n\t'CleanupDummyRaws',\n\t'FixPriorityReversal',\n\t'ParseDeclarations',\n\t'NodifySemicolonAndParenthesis',\n\t'CleanupDummyRaws',\n\t'SanitizeCommentPlacement'\n];\n\nfunction ParsePythonLambdas(nd_root){\n\t//parse: Python lambda\n\tfor(let nd_lambda of nd_root.FindAll(N_REF,'lambda')){\n\t\tif(nd_lambda.p.node_class!==N_RAW){continue;}\n\t\tlet nd_raw=nd_lambda.p;\n\t\tif(nd_raw.p.node_class!==N_LABELED){\n\t\t\t//misparsed multi-parameter lambda\n\t\t\tlet ndi=nd_raw;\n\t\t\twhile(ndi&&ndi.node_class!==N_LABELED){\n\t\t\t\tndi=ndi.s;\n\t\t\t}\n\t\t\tif(!ndi){continue;}\n\t\t\tlet ndi_prev=ndi.Prev();\n\t\t\tnd_raw.ReplaceUpto(ndi_prev,null);\n\t\t\tlet nd_other_args=nd_raw.BreakSibling();\n\t\t\tif(nd_other_args){\n\t\t\t\tnd_raw.Insert(POS_BACK,nd_other_args);\n\t\t\t}\n\t\t\tlet nd_last_param=ndi.c;\n\t\t\tnd_last_param.ReplaceWith(nd_raw);\n\t\t\tnd_raw.Insert(POS_BACK,nd_last_param);\n\t\t\t//COULDDO: add back comma if removed\n\t\t}\n\t\tlet nd_labeled=nd_raw.p;\n\t\tlet params=[];\n\t\tfor(let ndi=nd_raw.c.s;ndi;ndi=ndi.s){\n\t\t\tif(ndi.node_class===N_REF){\n\t\t\t\tparams.push(nAssignment(ndi.Clone(),nAir()));\n\t\t\t}\n\t\t}\n\t\tlet nd_body=nd_labeled.c.s;\n\t\tnd_labeled.ReplaceWith(nFunction(\n\t\t\tnd_raw.c.Unlink(),\n\t\t\tnParameterList.apply(null,params).setFlags(PARAMLIST_UNWRAPPED).SanitizeCommentPlacement(),\n\t\t\tnSymbol(':').setCommentsBefore(nd_raw.comments_after),\n\t\t\tnd_body.Unlink()\n\t\t))\n\t}\n\treturn nd_root;\n}\n\nfunction ParseJSLambdas(nd_root){\n\tfor(let nd_func_sym of nd_root.FindAll(N_SYMBOL,'=>')){\n\t\tlet nd_parent=nd_func_sym.p;\n\t\tif(nd_parent&&nd_parent.node_class===N_RAW&&nd_func_sym.Prev()&&nd_func_sym.s){\n\t\t\tlet nd_body=nd_func_sym.BreakSibling();\n\t\t\tnd_func_sym.BreakSelf();\n\t\t\tlet nd_prototype=nd_parent.BreakChild();\n\t\t\tnd_parent.ReplaceWith(nFunction(\n\t\t\t\tnAir(),\n\t\t\t\tnd_prototype.ConvertToParameterList(),\n\t\t\t\tnd_func_sym,\n\t\t\t\tnd_body\n\t\t\t))\n\t\t}\n\t}\n\treturn nd_root;\n}\n\n__global.GetPipelineFromFilename=function(filename,default_pipeline){\n\tlet pdot = filename.lastIndexOf('.');\n\tlet ext=filename.substr(pdot).toLowerCase();\n\tlet p=(default_pipeline||__global.default_pipeline).map(s=>s);\n\tif(ext==='.py'){\n\t\tp.splice(p.indexOf('ParseSimplePairing')+1,0,'ConvertIndentToScope');\n\t\tp.splice(p.indexOf('ParsePointedBrackets'),1);\n\t\tp.unshift({\n\t\t\tenable_hash_comment: 1,\n\t\t\tparse_indent_as_scope: 1,\n\t\t\tparse_js_regexp: 0,\n\t\t\tauto_curly_bracket: 0,\n\t\t});\n\t\tp.push(ParsePythonLambdas);\n\t}else if(ext==='.js'){\n\t\t//we need <> parsing for .ama.js\n\t\t//p.splice(p.indexOf('ParsePointedBrackets'),1);\n\t\tp.unshift({\n\t\t\tprefix_operators: '++ -- ! ~ + - * && & typeof void delete await new void',\n\t\t\tpostfix_operators: '++ --',\n\t\t\tcv_qualifiers: '',\n\t\t\tnamed_operators: 'typeof delete await new in of instanceof as',\n\t\t\tparse_js_regexp: 1,\n\t\t});\n\t\tp.push(ParseJSLambdas);\n\t}\n\tp.unshift({full_path:filename});\n\treturn p;\n};\n\n__global.__GetFilterByName=function(name) {\n\tif(name==='ParseSimplePairing'){\n\t\treturn ParseSimplePairing;\n\t}\n\tif(Node[name]){\n\t\treturn function(nd,options){\n\t\t\treturn nd[name](options);\n\t\t}\n\t}\n\tif(name.startsWith('{')){return JSON.parse(name);}\n\tlet parts=name.split('.');\n\tif(parts.length>=1){\n\t\tlet obj=__require(__init_js_path,parts[0]);\n\t\tfor(let i=1;i<parts.length;i++){\n\t\t\tif(!obj){break;}\n\t\t\tif(parts[i].endsWith('?')){\n\t\t\t\tparts[i]=parts[i].substr(0,parts[i].length-1);\n\t\t\t}\n\t\t\tobj=obj[parts[i]];\n\t\t}\n\t\tif(obj){return obj;}\n\t}\n\tif(name.endsWith('?')){return {};}\n\tthrow new Error('unknown function ' + JSON.stringify(name));\n};\n\n__global.ParseCode=function(input,options_or_pipeline){\n\tlet p=undefined;\n\tif(Array.isArray(options_or_pipeline)){\n\t\tp=options_or_pipeline;\n\t}else if(options_or_pipeline){\n\t\tp=[options_or_pipeline].concat(__global.default_pipeline);\n\t}else{\n\t\tp=__global.default_pipeline;\n\t}\n\tlet options = Object.create(__global.default_options);\n\tfor (let i = 0; i < p.length; i++) {\n\t\tlet item = p[i];\n\t\tif (typeof(item) === 'string') {\n\t\t\titem = __global.__GetFilterByName(item);\n\t\t}\n\t\tif (typeof(item) === 'function') {\n\t\t\tlet ret = item(input, options);\n\t\t\tif (ret != undefined) {\n\t\t\t\tinput = ret;\n\t\t\t}\n\t\t} else if (typeof(item) === 'object') {\n\t\t\tObject.assign(options, item);\n\t\t} else {\n\t\t\tthrow new Error('invalid pipeline item [' + i.toString() + ']')\n\t\t}\n\t}\n\treturn input;\n}\n\n__global.process = {\n\tenv: new Proxy({}, {\n\t\tget: function(target, key) {\n\t\t\treturn __getenv(key);\n\t\t}\n\t}),\n\tplatform: __platform,\n\tchdir: __chdir,\n\tcwd: __cwd,\n\targv:[]\n};\n\n__global.__RequireNativeLibrary = function(exports, module, __filename, __dirname) {\n\tlet handle = NativeLibrary.load(__filename);\n\tmodule.handle = handle;\n\tlet name = JSON.parse(__path_parse(__filename)).name.toLowerCase();\n\tif (__platform !== 'win32' && name.startsWith('lib')) {name = name.substr(3);}\n\tlet code = handle.run('AmaInit_' + name, module);\n\tif (code !== 0) {\n\t\tthrow new Error(['native module ', JSON.stringify(__filename), ' failed with code ', JSON.stringify(code)].join(''));\n\t}\n}\n\n__global.RunCommandLineUtility=function(){\n\tlet argv=process.argv.map(a=>a);\n\twhile(argv.length>=2&&!argv[1].startsWith('--')){\n\t\targv.splice(1,1);\n\t}\n\tif(argv[1].startsWith('--')){\n\t\tlet ret_code=__require(__init_js_path,'_cmdline')[argv[1].substr(2).toLowerCase()](argv)|0;\n\t\treturn ret_code;\n\t}else{\n\t\treturn 1;\n\t}\n}\n\n/////////////\n})();\n",
		"_sandbox", "'use strict';\n//This module is automatically executed by ama::JSRunInSandbox at most once\n//It's in a sandbox and does not have access to ANY native function\n//@ama ParseCurrentFile().Save()\n__global.Sandbox={\n\tglobal_age:0,\n\tconsole:console,\n\tInit:function(){\n\t\tthis.default_value={};\n\t\tthis.ctx_map={};\n\t\tthis.reach_map=new Map();\n\t\tthis.explore_map=new Map();\n\t\tthis.return_map=new Map();\n\t\tthis.errors=[];\n\t\tthis.error_dedup=new Set();\n\t\tthis.destructors=[];\n\t\tthis.queue=[];\n\t\tfor(let key in this){\n\t\t\tlet value=this[key];\n\t\t\tif(typeof(value)==='function'){\n\t\t\t\t//globalize all methods\n\t\t\t\t__global[key]=value.bind(this);\n\t\t\t}\n\t\t}\n\t\t__global.console=this.console;\n\t},\n\tDeclare:function(ctx,name,addr){\n\t\tif(!ctx[name]){\n\t\t\tctx[name]={value:{},addr:addr};\n\t\t}\n\t\treturn ctx[name];\n\t},\n\tAssign:function(ctx,lvalue,rvalue,addr){\n\t\tif(rvalue){\n\t\t\t//merge them\n\t\t\t__global.MergeValue(ctx,lvalue.value,rvalue);\n\t\t}\n\t\treturn rvalue;\n\t},\n\tDot:function(lvalue,addr,name){\n\t\treturn this.Declare(lvalue,'.'+name,addr);\n\t},\n\tItem:function(lvalue,addr/*,subscript*/){\n\t\treturn this.Declare(lvalue,'[]',addr);\n\t},\n\tDummyValue:function(ctx,addr/*,...ignored*/){\n\t\treturn Object.create(this.default_value);\n\t},\n\tGetScopeByTag:function(ctx,addr,addr_return){\n\t\tlet ret=this.ctx_map[addr];\n\t\tif(!ret){\n\t\t\tret={'[parent]':ctx,'[age]':1,'[utag]':addr,'[return]':this.return_map.get(addr_return)};\n\t\t\tthis.ctx_map[addr]=ret;\n\t\t}\n\t\treturn ret;\n\t},\n\tBumpAge:function(ctx){\n\t\tfor(let ctxi=ctx;ctxi;ctxi=ctxi['[parent]']){\n\t\t\tctxi['[age]']+=1;\n\t\t}\n\t},\n\tReach:function(ctx,addr){\n\t\t//TODO: record CFG path for error reporting\n\t\tlet reached_age=this.reach_map.get(addr)|0;\n\t\tif(reached_age!==ctx['[age]']){\n\t\t\tthis.reach_map.set(addr,ctx['[age]']);\n\t\t\tthis.global_age+=1;\n\t\t}\n\t},\n\tExplore:function(ctx_func,ctx,addr,n_branches/*,...dummy_args*/){\n\t\tlet mod=n_branches+1;\n\t\tlet st=this.explore_map.get(addr)|0;\n\t\tlet age_expected=st/mod|0;\n\t\tif(age_expected!==ctx['[age]']){\n\t\t\tst=ctx['[age]']*mod;\n\t\t}\n\t\tlet ret=st%mod;\n\t\tif(ret===n_branches){\n\t\t\t//random sample\n\t\t\tret=Math.min(Math.random()*n_branches|0,n_branches-1);\n\t\t}else{\n\t\t\tthis.global_age+=1;\n\t\t\tthis.explore_map.set(addr,st+1);\n\t\t}\n\t\treturn ret;\n\t},\n\tEndScope:function(ctx){\n\t\tif(!this.destructors.length){return;}\n\t\tfor(let desc of this.EnumVars(ctx.vars)){\n\t\t\tfor(let dtor of this.destructors){\n\t\t\t\tthis.FilterErrors(ctx,desc.addr,dtor(desc.vars[desc.name],desc.vars,desc.name));\n\t\t\t}\n\t\t}\n\t},\n\tQueueCall:function(f,params){\n\t\tlet obj_return=this.return_map.get(f.utag);\n\t\tif(!obj_return){\n\t\t\tobj_return={value:{},caller_ctx:new Set()};\n\t\t\tthis.return_map.set(f.utag,obj_return);\n\t\t}\n\t\tthis.queue.push({f:f,params:params});\n\t\treturn {f:f,obj_return:obj_return};\n\t},\n\tCall:function(ctx,value_func,params){\n\t\tlet value_ret=Object.create(this.default_value);\n\t\tfor(let f of (value_func.f||[])){\n\t\t\tlet desc=QueueCall(f,params);\n\t\t\tdesc.obj_return.caller_ctx.add(ctx);\n\t\t\t__global.MergeValue(ctx,value_ret,desc.obj_return.value);\n\t\t}\n\t\treturn value_ret;\n\t},\n\tReturn:function(ctx,rvalue,addr){\n\t\tlet age0=ctx['[age]'];\n\t\tthis.Assign(ctx,ctx['[return]'].value,rvalue,addr);\n\t\tif(age0<ctx['[age]']){\n\t\t\t//return value updated, notify all callers\n\t\t\tfor(let ctxi of ctx['[return]'].caller_ctx){\n\t\t\t\tBumpAge(ctxi);\n\t\t\t}\n\t\t}\n\t\treturn rvalue;\n\t},\n\t//TODO: error reporting, on-the-spot backtracking\n};\n",
		"assert", "'use strict'\nmodule.exports = function(cond){\n\tif(!cond){\n\t\tthrow new Error('assertion failure')\n\t}\n}\n",
		"auto_paren", "'use strict';\n\n/*\n#filter Enable Python-style `if foo:` / `for foo:` / ... in C / C++ / Javascript.\nThis filter will add '()' and `{}` automatically.\nBefore:\n```C++\nint main() {\n\tif rand()&1:{\n\t\tputs(\"rand()&1\");\n\t}\n\tfor int i=0;i<10;i++\n\t\tprintf(\"iteration %d\\n\",i);\n\treturn 0;\n}\n```\n*/\nfunction Translate(nd_root) {\n\tlet all_scoped=nd_root.FindAll(N_SCOPED_STATEMENT, null);\n\tfor (let ndi of all_scoped) {\n\t\tif(ndi.data==='template'){continue;}\n\t\tif(ndi.data==='for'&&ndi.c.node_class === N_AIR&&ndi.c.s.node_class!==N_AIR){\n\t\t\t//relaxed for syntax: `for i=0;i<n;i++{...}`\n\t\t\tif(ndi.p&&ndi.p.isRawNode(0,0)){\n\t\t\t\tlet nd_container=ndi.p;\n\t\t\t\tlet nd_init=ndi.c.s;\n\t\t\t\tif(nd_init.node_class==N_SCOPE){nd_init=nd_init.c||nAir();}\n\t\t\t\tnd_body=nd_container.LastChild();\n\t\t\t\tif(nd_body.node_class===N_SCOPE){\n\t\t\t\t\tif(!nd_init.s&&nd_init.node_class===N_SEMICOLON){nd_init=nd_init.c;}\n\t\t\t\t\tndi.ReplaceWith(nd_init.Unlink());\n\t\t\t\t\tnd_body.Unlink();\n\t\t\t\t\tlet nd_tmp=Node.GetPlaceHolder();\n\t\t\t\t\tnd_container.ReplaceWith(nd_tmp);\n\t\t\t\t\tnd_container.flags=0x2928;//()\n\t\t\t\t\tnd_tmp.ReplaceWith(nScopedStatement('for',nd_container,nd_body));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(ndi.s&&ndi.s.s){\n\t\t\t\t//we don't have cpp/cpp_indent\n\t\t\t\tlet nd_cond=ndi.s;\n\t\t\t\tlet nd_update_and_body=ndi.s.s;\n\t\t\t\tlet need_semic=0;\n\t\t\t\tif(nd_update_and_body.node_class===N_SEMICOLON&&nd_update_and_body.c.node_class===N_RAW&&nd_update_and_body.c.c&&nd_update_and_body.c.c.s){\n\t\t\t\t\tnd_update_and_body=nd_update_and_body.ReplaceWith(nd_update_and_body.BreakChild());\n\t\t\t\t\tneed_semic=1;\n\t\t\t\t}\n\t\t\t\tif(nd_update_and_body.node_class===N_RAW&&nd_update_and_body.c&&nd_update_and_body.c.s){\n\t\t\t\t\tlet nd_update=ndi.s.s;\n\t\t\t\t\tlet nd_init=ndi.c.s;\n\t\t\t\t\tif(nd_init.node_class==N_SCOPE){nd_init=nd_init.c||nAir();}\n\t\t\t\t\tndi.c.s.ReplaceWith(nAir());\n\t\t\t\t\tlet nd_tmp=Node.GetPlaceHolder();\n\t\t\t\t\tndi.ReplaceUpto(nd_update_and_body,nd_tmp);\n\t\t\t\t\tndi.c.ReplaceWith(nRaw(nd_init.Unlink(),ndi.BreakSibling()).setFlags(0x2928));\n\t\t\t\t\tnd_update.ReplaceWith(nd_update_and_body.c.Unlink());\n\t\t\t\t\tif(!nd_update_and_body.c.s){nd_update_and_body=nd_update_and_body.c;}\n\t\t\t\t\tif(need_semic){\n\t\t\t\t\t\tnd_update_and_body=nSemicolon(nd_update_and_body);\n\t\t\t\t\t}\n\t\t\t\t\tndi.c.s.ReplaceWith(nd_update_and_body);\n\t\t\t\t\tnd_tmp.ReplaceWith(ndi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ndi.c.node_class !== N_PAREN && !ndi.c.isRawNode('(', ')') && ndi.c.node_class !== N_AIR) {\n\t\t\tlet nd_arg = ndi.c;\n\t\t\tlet nd_tmp = Node.GetPlaceHolder()\n\t\t\tnd_arg.ReplaceWith(nd_tmp);\n\t\t\tif (nd_arg.node_class === N_LABELED && nd_arg.c.s.node_class === N_AIR) {\n\t\t\t\tnd_arg = nd_arg.c;\n\t\t\t}\n\t\t\tnd_tmp.ReplaceWith(nParen(nd_arg));\n\t\t}\n\t}\n\t//auto-scope\n\tfor (let ndi of all_scoped.concat(nd_root.FindAll(N_EXTENSION_CLAUSE, null))) {\n\t\tif(ndi.data==='template'){continue;}\n\t\tif(ndi.c.s.node_class!==N_SCOPE&&ndi.c.s.node_class!==N_AIR){\n\t\t\tif(ndi.data=='else'&&ndi.c.s.node_class==N_SCOPED_STATEMENT&&ndi.c.s.data=='if'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet nd_tmp = Node.GetPlaceHolder();\n\t\t\tlet nd_body=ndi.c.s;\n\t\t\tnd_body.SanitizeCommentPlacement();\n\t\t\tnd_body.ReplaceWith(nd_tmp);\n\t\t\tlet nd_scoped_body = nScope(nd_body);\n\t\t\tnd_tmp.ReplaceWith(nd_scoped_body);\n\t\t\tnd_body.comments_before=nd_scoped_body.comments_before;nd_scoped_body.comments_before='';\n\t\t\tnd_body.comments_after=nd_scoped_body.comments_after;nd_scoped_body.comments_after='';\n\t\t\tnd_body.AdjustIndentLevel(nd_scoped_body.indent_level);\n\t\t\tif(nd_body.comments_before.indexOf('\\n')>=0){\n\t\t\t\tnd_body.comments_after=nd_body.comments_after+'\\n';\n\t\t\t}\n\t\t\tnd_scoped_body.indent_level=0;\n\t\t}\n\t}\n}\n\nmodule.exports = Translate;\n",
		"auto_semicolon", "'use strict';\n/*\n#filter Automatically add ';' for C / C++ / Javascript. \nBefore:\n```C++\nint main() {\n\tputs(\"hello world\")\n\treturn 0\n}\n```\n*/\nmodule.exports = function(nd_root) {\n\tfor (let nd of nd_root.FindAll(N_RAW, null)) {\n\t\tif (nd.flags & 0xffff) {continue;}\n\t\tif (!nd.p || (nd.p.node_class !== N_SCOPE && nd.p.node_class !== N_FILE)) {continue;}\n\t\tif (!nd.c || !nd.c.s) {continue;}\n\t\tif (nd.Owning(N_NODEOF)) {continue;}\n\t\t//we are a N_RAW statement with at least 2 children\n\t\tlet new_children = [nd.c];\n\t\tfor (let ndi = nd.c.s; ndi; ndi = ndi.s) {\n\t\t\tif (ndi.comments_before.indexOf('\\n') >= 0 && ndi.node_class !== N_SCOPE && ndi.indent_level === ndi.Prev().indent_level) {\n\t\t\t\tnew_children.push(ndi);\n\t\t\t}\n\t\t}\n\t\tif (new_children.length > 1) {\n\t\t\t//we have multiple statements\n\t\t\tfor (let i = new_children.length - 1; i >= 0; i--) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tnew_children[i].Prev().BreakSibling();\n\t\t\t\t} else if(new_children[i].p) {\n\t\t\t\t\tnew_children[i].p.BreakChild();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < new_children.length; i++) {\n\t\t\t\tlet ndi = new_children[i];\n\t\t\t\tlet nd_test = ndi;\n\t\t\t\twhile ((nd_test.node_class === N_SCOPED_STATEMENT || nd_test.node_class === N_KEYWORD_STATEMENT ||\n\t\t\t\tnd_test.node_class === N_EXTENSION_CLAUSE) && nd_test.c) {\n\t\t\t\t\tnd_test=nd_test.LastChild()\n\t\t\t\t}\n\t\t\t\tif (nd_test.node_class !== N_SCOPE && (ndi.node_class === N_KEYWORD_STATEMENT && !ndi.data.startsWith('#') || \n\t\t\t\t\tndi.node_class === N_ASSIGNMENT || \n\t\t\t\t\tndi.node_class === N_CALL ||\n\t\t\t\t\tndi.node_class === N_POSTFIX ||\n\t\t\t\t\tndi.node_class === N_PREFIX\n\t\t\t\t)) {\n\t\t\t\t\tndi=ndi.toSingleNode();\n\t\t\t\t\tnew_children[i] = nSemicolon(ndi).setIndent(ndi.indent_level);\n\t\t\t\t\tndi.indent_level=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd.ReplaceWith(nScope.apply(null, new_children).c);\n\t\t}\n\t}\n\tfor (let nd of nd_root.FindAll(N_SCOPE, null).concat([nd_root])) {\n\t\tif (nd.Owning(N_NODEOF)) {continue;}\n\t\tif(nd.p&&nd.p.node_class===N_SCOPED_STATEMENT&&nd.p.data==='enum'){continue;}\n\t\tlet found_semic=0;\n\t\tfor(let ndi=nd.c;ndi;ndi=ndi.s){\n\t\t\tif(ndi.node_class===N_SEMICOLON){\n\t\t\t\tfound_semic=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!found_semic){\n\t\t\tlet nd_parent=nd;\n\t\t\twhile(nd_parent&&(nd_parent.node_class===N_SCOPE||nd_parent.isRawNode(0,0))){\n\t\t\t\tnd_parent=nd_parent.p;\n\t\t\t}\n\t\t\tif(nd_parent&&nd_parent.node_class!==N_SCOPED_STATEMENT&&nd_parent.node_class!==N_FUNCTION&&nd_parent.node_class!==N_CLASS){\n\t\t\t\t//initializer-ish scope, don't auto-semicolon\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//let ndi=nd.LastChild();\n\t\t//if(!ndi){continue;}\n\t\tfor (let ndi = nd.c; ndi; ndi = ndi.s) {\n\t\t\tif (ndi.s && (ndi.s.isSymbol(',') || ndi.s.isSymbol(';'))) {continue;}\n\t\t\tlet nd_test = ndi;\n\t\t\twhile ((nd_test.node_class === N_SCOPED_STATEMENT || nd_test.node_class === N_KEYWORD_STATEMENT ||\n\t\t\tnd_test.node_class === N_EXTENSION_CLAUSE) && nd_test.c) {\n\t\t\t\tnd_test=nd_test.LastChild()\n\t\t\t}\n\t\t\tif (nd_test.node_class !== N_SCOPE && (ndi.node_class === N_KEYWORD_STATEMENT && !ndi.data.startsWith('#') || \n\t\t\t\tndi.node_class === N_ASSIGNMENT || \n\t\t\t\tndi.node_class === N_CALL\n\t\t\t)) {\n\t\t\t\tlet nd_tmp = Node.GetPlaceHolder();\n\t\t\t\tndi.ReplaceWith(nd_tmp);\n\t\t\t\tndi = nd_tmp.ReplaceWith(nSemicolon(ndi));\n\t\t\t\t//ndi.c.AdjustIndentLevel(-ndi.indent_level);\n\t\t\t\t//shove trailing comments after the ;\n\t\t\t\tlet all_comments = [];\n\t\t\t\tfor (let ndj = ndi; ; ndj = ndj.LastChild()) {\n\t\t\t\t\tif (ndj.comments_after) {\n\t\t\t\t\t\tall_comments.push(ndj.comments_after);\n\t\t\t\t\t}\n\t\t\t\t\tif (ndj.node_class == N_SCOPE || ndj.node_class == N_CALL || ndj.node_class == N_CALL_TEMPLATE || ndj.node_class == N_SCOPED_STATEMENT || !ndj.c) {break;}\n\t\t\t\t}\n\t\t\t\tif (all_comments.length > 0) {\n\t\t\t\t\tfor (let ndj = ndi; ; ndj = ndj.LastChild()) {\n\t\t\t\t\t\tif (ndj.comments_after) {\n\t\t\t\t\t\t\tndj.comments_after = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ndj.node_class == N_SCOPE || ndj.node_class == N_CALL || ndj.node_class == N_CALL_TEMPLATE || ndj.node_class == N_SCOPED_STATEMENT || !ndj.c) {break;}\n\t\t\t\t\t}\n\t\t\t\t\tndi.comments_after = all_comments.reverse().join('');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nd_root;\n}\n",
		"bisync", "//Bidirectional synchronization system. Usage with default option values:\n//```Javascript\n//require('bisync')({\n//    dir_src: path.resolve(__dirname, '../src'),\n//    middle_extension: '.ama',\n//    processed_extensions: ['.cpp','.hpp','.cu'],\n//    filters: [],\n//})\n//```\n//The module will search for all files with `processed_extensions` in `dir_src`.\n//It will apply filters specified in `filters` to files with `middle_extension` (e.g. `foo.ama.cpp`) to generate the corresponding non-ama file (e.g. `foo.cpp`).\n//When available, it will also apply the inverse version of the filters to generate ama files from non-ama files.\n//Between each pair of ama and non-ama files, `bisync` will always synchronize the the newer file's content to its older counterpart.\n//\n//See [the filters section](#-filters) for possible filters.\n'use strict';\nconst pipe = require('pipe');\nconst path = require('path');\nconst fs = require('fs');\nconst fsext = require('fsext');\n\nmodule.exports = function Bisync(options) {\n\tif (!options) {options = {};}\n\tfunction GetFileTime(fn) {\n\t\tif (!fs.existsSync(fn)) {return 0;}\n\t\tlet stat = fs.statSync(fn);\n\t\treturn stat.mtimeMs;\n\t}\n\tlet middle_extension = options.middle_extension || '.ama';\n\tlet dir_src = options.dir_src || path.resolve('./src');\n\tprocess.chdir(dir_src);\n\t/////////\n\tlet script_ama2cpp = '';\n\tlet script_cpp2ama = '';\n\tlet p_backup = __global.default_pipeline;\n\tlet p_forward = __global.default_pipeline.map(a => a);\n\tlet p_inverse = __global.default_pipeline.map(a => a);\n\tif (options.filters) {\n\t\tlet p_inverse_rev = [];\n\t\tfor (let item of options.filters) {\n\t\t\tif (typeof(item) == 'string') {\n\t\t\t\titem = __global.__GetFilterByName(item);\n\t\t\t}\n\t\t\tp_forward.push(item);\n\t\t\tif (item.setup) {\n\t\t\t\tp_forward.unshift(item.setup);\n\t\t\t}\n\t\t\tif (item.inverse) {\n\t\t\t\tp_inverse_rev.push(item.inverse);\n\t\t\t\tif (item.setup) {\n\t\t\t\t\tp_inverse.unshift(item.setup);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let item of p_inverse_rev.reverse()) {\n\t\t\tp_inverse.push(item);\n\t\t}\n\t\t//we cannot edit the default pipeline: it's used in depends\n\t\tscript_ama2cpp = '__pipeline=GetPipelineFromFilename(__filename,__global.forward_pipeline);';\n\t\tscript_cpp2ama = '__pipeline=GetPipelineFromFilename(__filename,__global.inverse_pipeline);/*ignore per-file scripts*/return;';\n\t\t__global.inverse_pipeline = p_inverse;\n\t\t__global.forward_pipeline = p_forward;\n\t} else {\n\t\tscript_ama2cpp = options.script_forward || fs.readFileSync(path.join(__dirname, 'cpp/from_ama.js')).toString();\n\t\tscript_cpp2ama = options.script_backward || fs.readFileSync(path.join(__dirname, 'cpp/to_ama.js')).toString();\n\t}\n\tlet all_cpp_files = new Set();\n\tlet mext_dot = middle_extension + '.';\n\tlet exts = options.processed_extensions || ['.cpp', '.hpp', '.cu'];\n\tlet all_files = fsext.FindAllFiles(dir_src);\n\tfor (let ext of exts) {\n\t\t//for (let fn_rel_cpp of pipe.runPiped(process.platform == 'win32' ? 'dir /s /b *' + ext : \"find -iname '*\" + ext + \"'\").stdout.split('\\n')) \n\t\tfor (let fn_rel_cpp of all_files) {\n\t\t\t//if (!fn_rel_cpp) {continue;}\n\t\t\tif (path.extname(fn_rel_cpp) != ext) {continue;}\n\t\t\t//COULDDO: ignore patterns\n\t\t\tif (fn_rel_cpp.indexOf('/build/') >= 0 || fn_rel_cpp.indexOf('\\\\build\\\\') >= 0) {continue;}\n\t\t\tall_cpp_files.add(path.resolve(dir_src, fn_rel_cpp.replace(mext_dot, '.')));\n\t\t}\n\t}\n\tlet rebuild_ama = 'rebuild_' + middle_extension.replace(/\\./g, '');\n\tlet rebuild_cpp = 'rebuild_' + exts[0].replace(/\\./g, '');\n\tfor (let fn_cpp of all_cpp_files) {\n\t\t//Node.gc();\n\t\tlet parts = path.parse(fn_cpp);\n\t\tlet fn_ama_cpp = path.join(parts.dir, parts.name + middle_extension + parts.ext);\n\t\tlet t_cpp = GetFileTime(fn_cpp);\n\t\tlet t_ama = GetFileTime(fn_ama_cpp);\n\t\tp_inverse.push({change_ext: middle_extension + parts.ext}, 'Save');\n\t\tp_forward.push({change_ext: parts.ext}, 'Save');\n\t\tif (t_ama < t_cpp || process.aba || process[rebuild_ama]) {\n\t\t\t//cpp to ama\n\t\t\tif (process.dry_run || ProcessAmaFile(fn_cpp, script_cpp2ama) == 1) {\n\t\t\t\tif (!process.dry_run) {fsext.SyncTimestamp(fn_cpp, fn_ama_cpp);}\n\t\t\t\tconsole.log(process.dry_run ? 'will update' : 'updated', fn_ama_cpp);\n\t\t\t}\n\t\t}\n\t\tif (t_cpp < t_ama || process.aba || process[rebuild_cpp]) {\n\t\t\t//ama to cpp\n\t\t\tif (process.dry_run || ProcessAmaFile(fn_ama_cpp, script_ama2cpp) == 1) {\n\t\t\t\tif (!process.dry_run) {fsext.SyncTimestamp(fn_ama_cpp, fn_cpp);}\n\t\t\t\tconsole.log(process.dry_run ? 'will update' : 'updated', fn_cpp);\n\t\t\t}\n\t\t}\n\t\tp_forward.pop();p_forward.pop();\n\t\tp_inverse.pop();p_inverse.pop();\n\t}\n};\n",
		"class", "'use strict';\nconst assert = require('assert');\nconst depends = require('depends');\n//this is a language support module, we mainly extend Node\nlet classes = module.exports;\n\nlet g_not_class = new Set(['static', 'final', 'const', 'public', 'private', 'protected', 'extends', 'implements']);\nlet g_protections = ['public', 'private', 'protected'];\n\nfunction ListOwnProperties(properties, nd_class) {\n\tlet nd_scope = nd_class.LastChild();\n\tlet last_appearance = {};\n\tlet lingering_protection = nd_class.data == 'class' ? 'private' : 'public';\n\tfor (let ndi = nd_scope; ndi; ndi = ndi.PreorderNext(nd_scope)) {\n\t\tif (ndi.node_class == N_REF && g_not_class.has(ndi.data)) {\n\t\t\tif (ndi.p && ndi.p.node_class == N_LABELED && ndi.p.c == ndi) {\n\t\t\t\t//it's lingering\n\t\t\t\tlingering_protection = ndi.data;\n\t\t\t} else {\n\t\t\t\tlast_appearance[ndi.data] = ndi.ParentStatement();\n\t\t\t}\n\t\t}\n\t\tlet protection = lingering_protection;\n\t\tfor (let prot of g_protections) {\n\t\t\tif (last_appearance[prot] && last_appearance[prot].isAncestorOf(ndi)) {\n\t\t\t\tprotection = prot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ndi.node_class == N_REF && (ndi.flags & REF_DECLARED)) {\n\t\t\tlet is_static = last_appearance['static'] && last_appearance['static'].isAncestorOf(ndi) || nd_class.data == 'namespace';\n\t\t\tproperties.push({\n\t\t\t\tenumerable: !is_static | 0,\n\t\t\t\twritable: !(last_appearance['final'] && last_appearance['final'].isAncestorOf(ndi) || last_appearance['const'] && last_appearance['const'].isAncestorOf(ndi)) | 0,\n\t\t\t\town: 1,\n\t\t\t\tshadowed: 0,\n\t\t\t\tstatic: is_static | 0,\n\t\t\t\tprotection: protection,\n\t\t\t\tkind: 'variable',\n\t\t\t\tnode: ndi,\n\t\t\t\tname: ndi.data\n\t\t\t});\n\t\t} else if (ndi.node_class == N_FUNCTION) {\n\t\t\tif (ndi.data) {\n\t\t\t\tproperties.push({\n\t\t\t\t\tenumerable: 0,\n\t\t\t\t\twritable: 0,\n\t\t\t\t\town: 1,\n\t\t\t\t\tshadowed: 0,\n\t\t\t\t\tstatic: 0 | (last_appearance['static'] && last_appearance['static'].isAncestorOf(ndi)),\n\t\t\t\t\tprotection: protection,\n\t\t\t\t\tkind: 'method',\n\t\t\t\t\tnode: ndi,\n\t\t\t\t\tname: ndi.data\n\t\t\t\t});\n\t\t\t}\n\t\t\tndi = ndi.PreorderSkip();\n\t\t\tcontinue;\n\t\t} else if (ndi.node_class == N_CLASS) {\n\t\t\tproperties.push({\n\t\t\t\tenumerable: 0,\n\t\t\t\twritable: 0,\n\t\t\t\town: 1,\n\t\t\t\tshadowed: 0,\n\t\t\t\tstatic: 1,\n\t\t\t\tprotection: protection,\n\t\t\t\tkind: 'class',\n\t\t\t\tnode: ndi,\n\t\t\t\tname: ndi.GetName()\n\t\t\t});\n\t\t\tndi = ndi.PreorderSkip();\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\n///figure out inheritance and property list without caching: nodes could change later\n///often we aren't reusing the result anyway\nNode.ParseClass = function() {\n\tif (this.node_class != N_CLASS) {throw new Error('ParseClass is only valid on a class node');}\n\t//children: before, name, after, scope\n\t//base classes\n\tlet nd_after = this.c.s.s;\n\tlet base_class_set = new Set();\n\tfor (let ndi = nd_after; ndi; ndi = ndi.PreorderNext(nd_after)) {\n\t\tif ((ndi.node_class == N_REF || ndi.node_class == N_DOT) && !g_not_class.has(ndi.data)) {\n\t\t\t//COULDDO: use typing: let type_obj = typing.TryGettingClass(typing.ComputeType(ndi))\n\t\t\tfor (let nd_class of ndi.LookupClass()) {\n\t\t\t\tif (nd_class) {base_class_set.add(nd_class);}\n\t\t\t}\n\t\t}\n\t\tif (ndi.node_class == N_CALL || ndi.node_class == N_CALL_TEMPLATE ||\n\t\tndi.node_class == N_RAW && (ndi.flags & 0xffff) || ndi.node_class == N_SCOPE ||\n\t\tndi.node_class == N_DOT || ndi.node_class == N_ITEM) {\n\t\t\tndi = ndi.PreorderSkip();\n\t\t}\n\t}\n\tlet base_classes = [];\n\tbase_class_set.forEach(nd_class => {\n\t\tbase_classes.push(nd_class);\n\t});\n\t//properties: enum base_classes first\n\tlet properties = [];\n\tfor (let nd_class of base_classes) {\n\t\tListOwnProperties(properties, nd_class);\n\t}\n\tfor (let ppt of properties) {\n\t\tppt.own = 0;\n\t}\n\tListOwnProperties(properties, this);\n\t//shadowing deduction\n\tlet shadows = new Set();\n\tfor (let i = properties.length - 1; i >= 0; i--) {\n\t\tif (shadows.has(properties[i].name)) {\n\t\t\tproperties[i].enumerable = 0;\n\t\t\tproperties[i].shadowed = 1;\n\t\t}\n\t\tshadows.add(properties[i].name);\n\t}\n\treturn {\n\t\tnd: this,\n\t\tbase_classes: base_classes,\n\t\tproperties: properties,\n\t}\n};\n\nfunction LookupClassInFile(ret, nd_root, nd_name) {\n\t//COULDDO: match-ness scoring + high score picking, but conservative listing could work better\n\tlet name = nd_name.GetName();\n\tfor (let nd_class of nd_root.FindAll(N_CLASS, name)) {\n\t\t//skip forwards\n\t\tif (nd_class.LastChild().node_class == N_SCOPE) {\n\t\t\tret.push(nd_class);\n\t\t}\n\t}\n}\n\n//look up a ref / dot node\nNode.LookupClass = function() {\n\tlet ret = [];\n\tfor (let nd_root of depends.ListAllDependency(this.Root(), true)) {\n\t\tif (nd_root) {\n\t\t\tLookupClassInFile(ret, nd_root, this);\n\t\t}\n\t}\n\treturn ret;\n};\n",
		"cmake", "'use strict';\nconst assert = require('assert');\nconst fs = require('fs');\nconst path = require('path');\nconst depends = require('depends');\nlet cmake = module.exports;\n\n//as a new language support module, cmake.jcs extends Node\n//a small number will be interpreted as the opening char\nconst CMAKE_CHANGED = 65536;\n\nlet cmake_options = {\n\tenable_hash_comment: 1,\n\tparse_indent_as_scope: 0,\n\tparse_c_forward_declarations: 0,\n\tparse_js_regexp: 0,\n\tstruct_can_be_type_prefix: 0,\n\tkeywords_scoped_statement: '',\n\t//////////\n\ttab_indent: 2,//2 for auto\n\tauto_space: 0,\n};\n\ncmake.options = cmake_options;\n\ncmake.LoadCMakeFile = function(fn, template) {\n\tlet flags = 0;\n\tlet nd_root = ParseCode((fs.readFileSync(fn) || (flags = CMAKE_CHANGED, typeof(template) == 'function' ? template () : template) || '').toString(), cmake_options);\n\t//if-endif pairing\n\twhile (nd_root.c && !nd_root.c.s && nd_root.c.node_class == N_RAW && !(nd_root.c.flags & 0xffff) && nd_root.c.c) {\n\t\tnd_root.c.ReplaceWith(nd_root.c.c);\n\t}\n\tnd_root.flags |= flags;\n\tnd_root.data = fn;\n\tlet if_stk = [];\n\tfor (let ndi = nd_root.c; ndi; ndi = ndi.s) {\n\t\tif (ndi.node_class == N_CALL) {\n\t\t\tlet name = ndi.GetName();\n\t\t\tif (name == 'if') {\n\t\t\t\tif_stk.push(ndi);\n\t\t\t} else if (name == 'endif' && if_stk.length > 0) {\n\t\t\t\tlet nd0 = if_stk.pop();\n\t\t\t\tlet nd_tmp = Node.GetPlaceHolder();\n\t\t\t\tnd0.ReplaceUpto(ndi, nd_tmp)\n\t\t\t\tndi = nd_tmp.ReplaceWith(CreateNode(N_RAW, nd0));\n\t\t\t} else {\n\t\t\t\t//do nothing\n\t\t\t}\n\t\t}\n\t}\n\treturn nd_root;\n};\n\nNode.TokenizeCMakeArgs = function() {\n\tlet nd_call = this;\n\tlet ret = [];\n\tif (!nd_call.c.s) {return ret;}\n\tlet merge_group = [];\n\tfunction FlushMergeGroup() {\n\t\t//unquoted args - merge and convert. quoting individual names in target is fine\n\t\tif (merge_group.length == 1 && merge_group[0].node_class == N_REF) {\n\t\t\t//leave single identifiers alone\n\t\t\tret.push(merge_group[0])\n\t\t\tmerge_group.length = 0;\n\t\t} else {\n\t\t\tlet n0 = ret.length;\n\t\t\tfor (let str of merge_group.map(nd => nd.toSource(cmake_options)).join('').trim().split(' ')) {\n\t\t\t\tret.push(nString(str).setCommentsBefore(' '));\n\t\t\t}\n\t\t\tmerge_group[0].ReplaceUpto(merge_group[merge_group.length - 1], nScope.apply(null, ret.slice(n0)).c)\n\t\t\tmerge_group.length = 0;\n\t\t}\n\t}\n\tfunction dfsTokenizeCMakeArgs(nd) {\n\t\tif (merge_group.length && nd.comments_before.length > 0) {\n\t\t\tFlushMergeGroup();\n\t\t}\n\t\tif (nd.node_class == N_RAW && !(nd.flags & 0xffff)) {\n\t\t\tfor (let ndi = nd.c; ndi; ndi = ndi.s) {\n\t\t\t\tdfsTokenizeCMakeArgs(ndi);\n\t\t\t}\n\t\t} else if (nd.node_class == N_STRING) {\n\t\t\tif (merge_group.length) {\n\t\t\t\tFlushMergeGroup();\n\t\t\t}\n\t\t\tret.push(nd);\n\t\t} else if (nd.node_class == N_REF || nd.node_class == N_NUMBER || nd.node_class == N_SYMBOL) {\n\t\t\tmerge_group.push(nd);\n\t\t} else {\n\t\t\t//console.error('unrecognized cmake arg:', nd);\n\t\t\t//ret.push(nd)\n\t\t\tmerge_group.push(nd);\n\t\t}\n\t}\n\tfor (let ndi = nd_call.c.s; ndi; ndi = ndi.s) {\n\t\tif (ndi.node_class == N_BINOP) {\n\t\t\tndi = ndi.Unparse();\n\t\t}\n\t}\n\tfor (let ndi = nd_call.c.s; ndi; ndi = ndi.s) {\n\t\tdfsTokenizeCMakeArgs(ndi);\n\t}\n\tif (merge_group.length) {\n\t\tFlushMergeGroup();\n\t}\n\treturn ret;\n};\n\nNode.CMakeFindTarget = function(name) {\n\tlet nd_root = this;\n\tfor (let nd_target of nd_root.FindAll(N_CALL, 'add_executable').concat(nd_root.FindAll(N_CALL, 'add_library'))) {\n\t\tif (!nd_target.c.s) {continue;}\n\t\tlet args = nd_target.TokenizeCMakeArgs();\n\t\tif (args.length && args[0].node_class == N_REF && args[0].data == name) {\n\t\t\t//found\n\t\t\treturn nd_target;\n\t\t}\n\t}\n\treturn null;\n};\n\nNode.CMakeCreateTarget = function(name, options) {\n\tlet nd_root = this;\n\tif (!options) {\n\t\toptions = {};\n\t}\n\t//create a new target\n\tlet new_target = ['\\n'];\n\tlet output_format = options.format;\n\tif (output_format == 'exe') {\n\t\tnew_target.push('add_executable(', name);\n\t} else if (output_format == 'dll') {\n\t\tnew_target.push('add_library(', name, ' SHARED');\n\t} else if (output_format == 'lib') {\n\t\tnew_target.push('add_library(', name);\n\t} else {\n\t\tthrow new Error('invalid output format ' + output_format);\n\t}\n\tlet files = options.files || [];\n\tfor (let fn of files) {\n\t\tnew_target.push('\\n  ', JSON.stringify(fn));\n\t}\n\tnew_target.push('\\n)');\n\treturn nd_root.Insert(POS_BACK, ParseCode(new_target.join(''), cmake_options).Find(N_CALL, null));\n};\n\nfunction TryRelative(dir_cmake, src_name_abs) {\n\tlet src_name_rel = path.relative(dir_cmake, src_name_abs);\n\tif (path.isAbsolute(src_name_rel) || src_name_rel.length > src_name_abs.length) {\n\t\tsrc_name_rel = src_name_abs;\n\t}\n\t//if (src_name_abs.startsWith(__std_module_dir + '/')) {\n\t//\tsrc_name_rel = '${AMA_MODULES}' + src_name_abs.substr(__std_module_dir.length);\n\t//} else if (src_name_rel.startsWith(__std_module_dir_global + '/')) {\n\t//\tsrc_name_rel = '${AMA_MODULES_GLOBAL}' + src_name_abs.substr(__std_module_dir_global.length);\n\t//}\n\treturn src_name_rel;\n}\n\n//let nd_output_format_template = ParseCode('#pragma add(\"output_format\",@(N_STRING(format)))\\n').Find(N_KEYWORD_STATEMENT, '#pragma')\nlet nd_output_format_template = nKeywordStatement(\"#pragma\", nCall(nRef(\"add\"), nString(\"output_format\"), (Node.MatchAny(N_STRING, 'format')).setCommentsBefore(\" \")).setCommentsBefore(\" \"));\n\nNode.CMakeInsertAMACommand = function(options) {\n\tlet dir_cmake = path.dirname(path.resolve(this.data));\n\tlet fn_src = TryRelative(dir_cmake, options.source_file);\n\tlet fn_out = TryRelative(dir_cmake, options.output);\n\tfor (let nd_call of this.FindAll(N_CALL, 'add_custom_command')) {\n\t\tlet args = nd_call.TokenizeCMakeArgs();\n\t\tfor (let i = 0; i + 1 < args.length; i++) {\n\t\t\tif (args[i].GetName() == 'OUTPUT' && args[i + 1].GetName() == fn_out) {\n\t\t\t\t//we already have a command\n\t\t\t\treturn nd_call;\n\t\t\t}\n\t\t}\n\t}\n\tthis.flags |= CMAKE_CHANGED;\n\tlet cmd = [\n\t\t'\\nadd_custom_command(\\n',\n\t\t'  OUTPUT ', JSON.stringify(fn_out), '\\n',\n\t\t'  COMMAND ', options.command.replace(/\\$\\{SOURCE_FILE\\}/g, JSON.stringify(fn_src)), '\\n',\n\t\t'  MAIN_DEPENDENCY ', options.main_dependency.map(fn => JSON.stringify(TryRelative(dir_cmake, fn))).join(' '), '\\n',\n\t\t'  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\\n',\n\t\t')\\n'\n\t].join('');\n\treturn this.Insert(POS_BACK, ParseCode(cmd, cmake_options).Find(N_CALL, null));\n};\n\nNode.CreateCXXCMakeTarget = function(fn_cmake, options) {\n\tif (!fn_cmake) {\n\t\tfn_cmake = __global.__cmakelist;\n\t}\n\tif (!fn_cmake) {\n\t\tlet dir = path.dirname(this.Root().data);\n\t\tlet dir_git = undefined;\n\t\tfor (; ;) {\n\t\t\tlet fn_test = path.join(dir, 'CMakeLists.txt');\n\t\t\tif (fs.existsSync(path.join(dir, '.git'))) {\n\t\t\t\tdir_git = dir;\n\t\t\t}\n\t\t\tif (fs.existsSync(fn_test)) {\n\t\t\t\tfn_cmake = fn_test;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dir_git) {break;}\n\t\t\tlet dir_next = path.dirname(dir);\n\t\t\tif (dir_next == dir) {break;}\n\t\t\tdir = dir_next;\n\t\t}\n\t\tif (dir_git && !fn_cmake) {\n\t\t\tfn_cmake = path.join(dir_git, 'CMakeLists.txt');\n\t\t}\n\t}\n\tif (!fn_cmake) {\n\t\tlet dir = path.dirname(this.Root().data);\n\t\tfn_cmake = path.join(dir, 'CMakeLists.txt');\n\t}\n\tfn_cmake = path.resolve(fn_cmake);\n\tlet nd_cmake = cmake.LoadCMakeFile(fn_cmake, () => [\n\t\t'cmake_minimum_required (VERSION 3.0)\\n',\n\t\t'project(', path.basename(path.dirname(path.resolve(fn_cmake))).replace(/[^0-9a-zA-Z]+/g, '_'), ')\\n',\n\t].join(''))   \n\t//insert files\n\tlet src_name_abs = path.resolve(this.data);\n\tlet dir_cmake = path.dirname(fn_cmake);\n\tlet our_files = new Set(depends.ListAllDependency(this, false).map(nd_root => __path_toAbsolute(nd_root.data)));\n\tlet our_files_filtered = [];\n\t//our own file could be .ama.\n\tlet src_name_rel = TryRelative(dir_cmake, src_name_abs).replace('.ama.', '.');\n\tfor (let fn of our_files) {\n\t\tif (path.extname(fn).startsWith('.h') && fn != src_name_abs) {\n\t\t\t//exclude all headers except the current file\n\t\t\tcontinue;\n\t\t}\n\t\t//use relative dirs whenever possible\n\t\tlet fn_rel = TryRelative(dir_cmake, fn).replace('.ama.', '.');\n\t\tour_files_filtered.push(fn_rel);\n\t}\n\tlet name = path.parse(this.data).name.replace(/[.].*/, '');\n\t//search for existing target\n\t//if found\n\t//COULDDO: also add to 'set' commands\n\tlet nd_my_target = undefined;\n\tfor (let nd_target of nd_cmake.FindAll(N_CALL, 'add_executable').concat(nd_cmake.FindAll(N_CALL, 'add_library'))) {\n\t\tif (!nd_target.c.s) {continue;}\n\t\tlet args = nd_target.TokenizeCMakeArgs();\n\t\tif (args[0].isRef(name)) {\n\t\t\tnd_my_target = nd_target;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nd_my_target) {\n\t\t//just add the files\n\t\tlet args = nd_my_target.TokenizeCMakeArgs();\n\t\tlet p_files = 1;\n\t\tif (args[1] && args[1].isRef('SHARED')) {\n\t\t\tp_files += 1;\n\t\t}\n\t\tlet files = new Set(args.slice(p_files).map(nd => nd.GetName()));\n\t\tlet new_files = our_files_filtered.filter(fn => !files.has(fn));\n\t\tif (new_files.length) {\n\t\t\t//append the new files\n\t\t\tfor (let fn of new_files) {\n\t\t\t\tnd_cmake.flags |= CMAKE_CHANGED;\n\t\t\t\tassert(nd_my_target.LastChild().node_class == N_RAW);\n\t\t\t\tnd_my_target.LastChild().Insert(POS_BACK, nString(fn).setCommentsBefore(' '));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet format = 'exe';\n\t\tfor (let nd_format of this.FindAll(N_KEYWORD_STATEMENT, '#pragma')) {\n\t\t\tlet match = nd_format.Match(nd_output_format_template);\n\t\t\tif (match) {\n\t\t\t\tformat = match.format.GetStringValue();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnd_cmake.flags |= CMAKE_CHANGED;\n\t\tnd_cmake.CMakeCreateTarget(name, {\n\t\t\tformat: format,\n\t\t\tfiles: our_files_filtered\n\t\t});\n\t}\n\tif (nd_cmake.flags & CMAKE_CHANGED) {\n\t\tnd_cmake.Save(cmake_options);\n\t}\n\tif (options) {\n\t\toptions.target = name;\n\t\tnd_cmake.CMakeBuild(options);\n\t}\n\treturn nd_cmake;\n};\n\n//this is not a filter\ncmake.Build = function(options) {\n\tif (!options) {options = {};}\n\tconst pipe = require('pipe');\n\tprocess.chdir(path.dirname(path.resolve(options.cmakelist_path)));\n\tlet build = (options.build || process.build || 'Debug');\n\tlet ret_code = pipe.run([\n\t\t__platform == 'win32' ? 'md build\\\\' : 'mkdir -p build/', process.platform, '_', build.toLowerCase(), ' && ',\n\t\t__platform == 'win32' ? 'cd build\\\\' : 'cd build/', process.platform, '_', build.toLowerCase(), ' && ',\n\t\t'cmake -DCMAKE_BUILD_TYPE=', build, ' ../.. && ',\n\t\t'cmake --build .', options.target ? ' --target ' + options.target : '', ' --config ', build, options.rebuild || process.rebuild ? ' --clean-first' : '',\n\t\toptions.extra_args ? ' ' + options.extra_args.join(' ') : ''\n\t].join(''));\n\tif (ret_code == 0 && (options.run || process.run) && options.target) {\n\t\tpipe.run([\n\t\t\t__platform == 'win32' ? 'build\\\\' : 'build/', process.platform, '_', build.toLowerCase(), __platform == 'win32' ? '\\\\' : '/', options.target, ' ',\n\t\t\toptions.run.map(s => s.indexOf(' ') >= 0 ? JSON.stringify(s) : s).join(' ')\n\t\t].join(''));\n\t}\n};\n\n///called from a cmake node\nNode.CMakeBuild = function(options) {\n\tif (!options) {options = {};}\n\toptions.cmakelist_path = this.data;\n\treturn cmake.Build(options);\n};\n\nNode.CMakeEnsureCommand = function(nd_command) {\n\tif (!this.MatchAll(nd_command).length) {\n\t\tlet nd_command_tokenized = nd_command.Clone();\n\t\tnd_command_tokenized.TokenizeCMakeArgs();\n\t\tif (!this.MatchAll(nd_command_tokenized).length) {\n\t\t\tthis.Insert(POS_BACK, nd_command);\n\t\t}\n\t}\n};\n\nlet g_main_functions = new Set(['main', 'WinMain', 'DllMain']);\n/*\n#default on\n#filter Create cmake build files for C/C++ source\nThis filter only applies to files containing a main function.\nIt will create a build target for that file and a wrapping `CMakeLists.txt` if it can't find one.\nIf there is already a build target, it will search for dependent files and update the source file list when necessary.\nNon-include dependency can be added with `#pragma add(\"c_files\",\"./foo.c\")`.\n*/\ncmake.AutoCreate = function(nd_root, options) {\n\tif (!nd_root.FindAll(N_FUNCTION).filter(nd => g_main_functions.has(nd.data)).length) {return;}\n\tif (options.full_path) {\n\t\tnd_root.data = options.full_path;\n\t}\n\toptions.nd_cmake = nd_root.CreateCXXCMakeTarget(options.cmakelist_path);\n\t//{build:\"debug\",run:[]}\n};\ncmake.AutoCreate.inverse = cmake.AutoCreate; \n",
		"cpp/amacpp", "const path=require('path');\nconst jsism=require('cpp/jsism');\nconst short_types=require('cpp/short_types');\nconst sane_types=require('cpp/sane_types');\nconst sane_init=require('cpp/sane_init');\nconst sane_export=require('cpp/sane_export');\nconst move_operator=require('cpp/move_operator');\nconst unified_null=require('cpp/unified_null');\nsane_types.setup('',default_options);\nmove_operator.setup('',default_options);\nfunction ToCPP(nd_root,options){\n\tif(!options){options={};}\n\t(nd_root\n\t\t.StripRedundantPrefixSpace()\n\t\t.then(require('auto_semicolon'))\n\t\t.then(require('cpp/sane_for'))\n\t\t.then(require('auto_paren'))\n\t\t.then(sane_types.FixArrayTypes)\n\t\t.then(require('cpp/auto_decl'))\n\t\t.then(require('cpp/typing').DeduceAuto)\n\t\t.then(require('cpp/auto_dot'))\n\t\t.then(require('cpp/cpp_indent'))\n\t);\n\tif(options.update_source){nd_root.Save();}\n\treturn (nd_root\n\t\t.then(require('cpp/line_sync'))\n\t\t.then(short_types)\n\t\t.then(sane_types)\n\t\t.then(sane_init)\n\t\t.then(sane_export)\n\t\t.then(move_operator)\n\t\t.then(unified_null)\n\t\t.then(jsism.EnableJSLambdaSyntax)\n\t\t.then(jsism.EnableJSON)\n\t\t.then(jsism.EnableConsole)\n\t\t.then(jsism.EnableSingleQuotedStrings)\n\t\t.then(require('cpp/auto_header'))\n\t\t.then(require('cpp/asset'))\n\t);\n}\n\nfunction FromCPP(nd_root){\n\treturn (nd_root\n\t\t.then(require('cpp/gentag').DropGeneratedCode)\n\t\t.StripRedundantPrefixSpace(false)\n\t\t.then(jsism.EnableJSLambdaSyntax.inverse)\n\t\t.then(unified_null.inverse)\n\t\t.then(move_operator.inverse)\n\t\t.then(sane_export.inverse)\n\t\t.then(sane_init.inverse)\n\t\t.then(sane_types.inverse)\n\t\t.then(short_types.inverse)\n\t\t.then(require('cpp/line_sync').inverse)\n\t);\n}\n\nmodule.exports=ToCPP;\nmodule.exports.inverse=FromCPP;\n",
		"cpp/asset", "'use strict'\nconst fs = require('fs');\nconst path = require('path');\nconst gentag = require('cpp/gentag');\n\n/*\n#filter Pull in an external file to a zero-terminated C constant array.\nBefore:\n```C++\n#pragma gen(asset('./_doc_asset.txt'))\n```\n*/\nmodule.exports = function Translate(nd_root) {\n\tfor (let match of gentag.FindAllGenTags(nd_root, nCall(nRef(\"asset\"), (Node.MatchAny(N_STRING, 'file'))))) {\n\t\tlet file = match.file.GetStringValue();\n\t\tif (nd_root.data && file.startsWith('.')) {\n\t\t\tfile = path.resolve(path.dirname(nd_root.data), file);\n\t\t}\n\t\tlet name = path.parse(file).name.replace(/[^a-zA-Z0-9]+/g, '_').toLowerCase();\n\t\tlet data = new Uint8Array(fs.readFileSync(file));\n\t\tlet ret = ['\\nstatic const uint8_t ', name, '[]={'];\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tif (!(i & 127)) {\n\t\t\t\tret.push('\\n\\t');\n\t\t\t}\n\t\t\tret.push(data[i].toString(), ',');\n\t\t}\n\t\tret.push('0\\n};\\n');\n\t\tgentag.UpdateGenTagContent(match.gentag, nAir().setCommentsBefore(ret.join('')));\n\t}\n};\n",
		"cpp/auto_decl", "'use strict';\n\nfunction DeclScope(nd) {\n\tfor (let ndi = nd; ndi; ndi = ndi.p) {\n\t\tif (ndi.node_class == N_SCOPE) {\n\t\t\tlet nd_asgn = ndi.Owning(N_ASSIGNMENT);\n\t\t\tif (nd_asgn && nd_asgn.c.isAncestorOf(ndi)) {\n\t\t\t\t//hack out of destructuring\n\t\t\t\treturn nd_asgn.Owning(N_SCOPE);\n\t\t\t}\n\t\t\treturn ndi;\n\t\t}\n\t\tif (ndi.node_class == N_PARAMETER_LIST) {\n\t\t\treturn ndi.p;\n\t\t}\n\t}\n\treturn nd.Root();\n}\n\n/*\n#filter Automatically declare variables on assignment\nBefore:\n```C++\nint main(int argc){\n\ta=42;\n\tif(argc>=2){\n\t\tb=0;\n\t\ta=b;\n\t}else{\n\t\ta+=100;\n\t}\n\treturn a;\n}\n```\n*/\nfunction Translate(nd_root, options) {\n\tlet all_refs = nd_root.FindAll(N_REF, null);\n\t//track the locally undeclared\n\tlet scope_to_context = new Map();\n\tfor (let nd_def of all_refs) {\n\t\tif (!(nd_def.flags & REF_DECLARED)) {continue;}\n\t\tlet nd_scope = DeclScope(nd_def);\n\t\tlet ctx = scope_to_context.get(nd_scope);\n\t\tif (!ctx) {\n\t\t\tctx = {defs: new Set()};\n\t\t\tscope_to_context.set(nd_scope, ctx);\n\t\t}\n\t\tctx.defs.add(nd_def.data);\n\t}\n\t//find the locally undeclared: then declare them or do name search\n\tlet locally_undeclared = [];\n\tfor (let nd_ref of all_refs) {\n\t\tif (nd_ref.flags & REF_DECLARED) {continue;}\n\t\tlet nd_owning_kwstmt = nd_ref.Owning(N_KEYWORD_STATEMENT);\n\t\tif (nd_owning_kwstmt && nd_owning_kwstmt.data == 'using') {continue;}\n\t\tlet declared = 0;\n\t\tfor (let nd_scope = nd_ref; nd_scope; nd_scope = nd_scope.p) {\n\t\t\tlet ctx = scope_to_context.get(nd_scope);\n\t\t\tif (ctx && ctx.defs.has(nd_ref.data)) {declared = 1;break;}\n\t\t}\n\t\tif (!declared) {\n\t\t\tlocally_undeclared.push(nd_ref);\n\t\t}\n\t}\n\t//worse is better: just make each first assignment decl, then look up the never-writtens\n\tlet owner_to_context = new Map();\n\tlet keyword = (options || {}).keyword || 'auto';\n\tfor (let nd_ref of locally_undeclared) {\n\t\tif (nd_ref.flags == REF_WRITTEN) {\n\t\t\t//check already-declared-ness\n\t\t\tlet declared = 0;\n\t\t\tfor (let nd_scope = nd_ref; nd_scope; nd_scope = nd_scope.p) {\n\t\t\t\tlet ctx = scope_to_context.get(nd_scope);\n\t\t\t\tif (ctx && ctx.defs.has(nd_ref.data)) {declared = 1;break;}\n\t\t\t}\n\t\t\tif (declared) {continue;}\n\t\t\t//make it a declaration\n\t\t\tlet nd_tmp = Node.GetPlaceHolder();\n\t\t\tnd_ref.ReplaceWith(nd_tmp)\n\t\t\tnd_tmp.ReplaceWith(nRaw(nRef(keyword).setCommentsAfter(' '), nd_ref));\n\t\t\tnd_ref.flags |= REF_DECLARED;\n\t\t\t///////////\n\t\t\t//add it to the declarations\n\t\t\tlet nd_scope = DeclScope(nd_ref);\n\t\t\tlet ctx = scope_to_context.get(nd_scope);\n\t\t\tif (!ctx) {\n\t\t\t\tctx = {defs: new Set()};\n\t\t\t\tscope_to_context.set(nd_scope, ctx);\n\t\t\t}\n\t\t\tctx.defs.add(nd_ref.data);\n\t\t}\n\t\tif (nd_ref.flags & REF_WRITTEN) {\n\t\t\tlet nd_owner = nd_ref.Owner();\n\t\t\tlet ctx = owner_to_context.get(nd_owner);\n\t\t\tif (!ctx) {\n\t\t\t\tctx = {writtens: new Set()};\n\t\t\t\towner_to_context.set(nd_owner, ctx);\n\t\t\t}\n\t\t\tctx.writtens.add(nd_ref.data);\n\t\t}\n\t}\n\t//look up the never-writtens\n\tlet keywords_class = new Set(default_options.keywords_class.split(' '));\n\tlet all_possible_names = undefined;\n\tfor (let nd_ref of locally_undeclared) {\n\t\tif (nd_ref.flags & (REF_WRITTEN | REF_DECLARED)) {continue;}\n\t\tlet nd_owner = nd_ref.Owner();\n\t\tlet ctx = owner_to_context.get(nd_owner);\n\t\tif (ctx && ctx.writtens.has(nd_ref.data)) {continue;}\n\t\tif (nd_ref.p) {\n\t\t\t//check a few should-not-fix cases\n\t\t\tif (nd_ref.p.node_class == N_KEYWORD_STATEMENT && nd_ref.p.c == nd_ref && keywords_class.has(nd_ref.p.data)) {\n\t\t\t\t//struct forward decl\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (!all_possible_names) {\n\t\t\t//collect names\n\t\t\tconst depends = require('depends');\n\t\t\tall_possible_names = new Map();\n\t\t\tfor (let nd_root_i of depends.ListAllDependency(nd_root, true)) {\n\t\t\t\tfor (let ndi = nd_root_i; ndi; ndi = ndi.PreorderNext(nd_root_i)) {\n\t\t\t\t\tif (ndi.node_class == N_SCOPE && ndi.p && (ndi.p.node_class == N_FUNCTION || ndi.p.node_class == N_CLASS && ndi.p.data != 'namespace')) {\n\t\t\t\t\t\tndi = ndi.PreorderSkip();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ndi.node_class == N_PARAMETER_LIST) {\n\t\t\t\t\t\tndi = ndi.PreorderSkip();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ndi.node_class == N_REF && (ndi.flags & REF_DECLARED)) {\n\t\t\t\t\t\tlet defs = all_possible_names.get(ndi.data);\n\t\t\t\t\t\tif (!defs) {\n\t\t\t\t\t\t\tdefs = [];\n\t\t\t\t\t\t\tall_possible_names.set(ndi.data, defs);\n\t\t\t\t\t\t\tdefs.push(ndi);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet defs = all_possible_names.get(nd_ref.data);\n\t\tif (defs && defs.length == 1) {\n\t\t\t//resolve it\n\t\t\tlet names = [];\n\t\t\tlet nd_def = defs[0];\n\t\t\tfor (let ndi = nd_def; ndi; ndi = ndi.p) {\n\t\t\t\tif (ndi.node_class == N_CLASS && nd_def != ndi.c.s || ndi.node_class == N_REF) {\n\t\t\t\t\tnames.push(ndi.GetName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet nd_ret = nRef(names.pop());\n\t\t\twhile (names.length > 0) {\n\t\t\t\tnd_ret = nd_ret.dot(names.pop()).setFlags(DOT_CLASS);\n\t\t\t};\n\t\t\tnd_ref.ReplaceWith(nd_ret);\n\t\t}\n\t}\n}\n\nmodule.exports = Translate;\n",
		"cpp/auto_dot", "const typing = require('cpp/typing');\n\n/*\n#filter Automatically deduce `->` or `::` from `.`\nBefore:\n```C++\nnamespace ama{\n\tstruct Node{...};\n}\nama.Node* GetChild(ama.Node* nd){\n\treturn nd.c;\n}\n```\n*/\nmodule.exports = function Translate(nd_root) {\n\tfor (let nd_dot of nd_root.FindAll(N_DOT)) {\n\t\tif (!nd_dot.flags) {\n\t\t\tif (nd_dot.c.isRef('this')) {\n\t\t\t\tnd_dot.flags = DOT_PTR;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet type = typing.ComputeType(nd_dot.c);\n\t\t\tif (type && type.node_class == N_POSTFIX && type.data == '*') {\n\t\t\t\tnd_dot.flags = DOT_PTR;\n\t\t\t} else if (type && type.node_class == N_CLASS && type.data == 'namespace') {\n\t\t\t\tnd_dot.flags = DOT_CLASS;\n\t\t\t}\n\t\t}\n\t}\n};",
		"cpp/auto_header", "'use strict';\nconst path = require('path');\nconst fs = require('fs');\nconst depends = require('depends');\nconst typing = require('cpp/typing');\n\n/*\n#filter Synchronize methods and functions to classes and headers\n\nIf you `#include \"./foo.hpp\"` in `foo.cpp`, this filter will also add function forward declarations to `foo.hpp`.\nUse `#pragma no_auto_header()` to suppress this behavior.\n\nBefore:\n```C++\nstruct TestClass{\n\tint a;\n};\nint TestClass::get_a(){\n\treturn this->a;\n}\nvoid TestClass::set_a(int a){\n\tthis->a = a;\n}\n```\n*/\nfunction Translate(nd_root, options) {\n\tif (path.extname(nd_root.data).startsWith('.h')) {return;}\n\tif (nd_root.Find(N_CALL, 'no_auto_header')) {return;}\n\tlet header_file = (options || {}).header_file;\n\tif (!header_file && nd_root.data) {\n\t\t//search for same-name dependency first\n\t\tlet my_name = path.parse(nd_root.data).name;\n\t\tfor (let ndi of nd_root.FindAll(N_DEPENDENCY)) {\n\t\t\tif ((ndi.flags & DEP_TYPE_MASK) == DEP_C_INCLUDE && ( ndi.flags & DEPF_C_INCLUDE_NONSTR )) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet fn_dep = depends.Resolve(ndi);\n\t\t\tif (fn_dep && path.parse(fn_dep).name == my_name) {\n\t\t\t\theader_file = fn_dep;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!header_file) {\n\t\theader_file = nd_root.data || '';\n\t\tlet pdot = header_file.lastIndexOf('.');\n\t\tif (pdot >= 0) {\n\t\t\theader_file = header_file.substr(0, pdot);\n\t\t}\n\t\theader_file = header_file + '.hpp';\n\t}\n\t//search for method implementation and globally exported functions\n\tlet to_sync = [];\n\tfor (let nd_func of nd_root.FindAll(N_FUNCTION, null)) {\n\t\t//before, param, after, scope\n\t\t//reject forward declarations\n\t\tif (nd_func.LastChild().node_class != N_SCOPE) {continue;}\n\t\t//reject private declarations\n\t\tif (nd_func.c.Find(N_REF, 'static')) {continue;}\n\t\t//reject in-class methods of private classes\n\t\tlet nd_class = nd_func.Owning(N_CLASS);\n\t\tif (nd_class && nd_class.data != 'namespace') {continue;}\n\t\tif (!nd_func.GetFunctionNameNode()) {continue;}\n\t\t//gotta sync to header\n\t\tto_sync.push(nd_func);\n\t}\n\t//fast path: skip header loading if we don't have anything to sync\n\tif (!to_sync.length) {return;}\n\t//load the header\n\tlet nd_header = undefined;\n\tif (!fs.existsSync(header_file)) {\n\t\tlet header_name = path.parse(header_file).name.replace(/[^a-zA-Z0-9]+/g, '_').toUpperCase();\n\t\tnd_header = ParseCode([\n\t\t\t'#ifndef __', header_name, '_HEADER\\n',\n\t\t\t'#define __', header_name, '_HEADER\\n',\n\t\t\t'#endif\\n'\n\t\t].join(''));\n\t\tnd_header.data = header_file;\n\t} else {\n\t\tnd_header = depends.LoadFile(header_file);\n\t}\n\t//sync to header\n\tlet endifs = nd_header.FindAll(N_KEYWORD_STATEMENT, '#endif');\n\tlet nd_endif = undefined;\n\tif (endifs.length) {\n\t\tnd_endif = endifs.pop();\n\t}\n\tlet changed = 0;\n\tfor (let nd_func of to_sync) {\n\t\tlet nd_name = nd_func.GetFunctionNameNode();\n\t\tlet names = [];\n\t\twhile (nd_name.node_class == N_DOT) {\n\t\t\tnames.push(nd_name.data);\n\t\t\tnd_name = nd_name.c;\n\t\t};\n\t\tif (nd_name.node_class != N_AIR) {\n\t\t\tnames.push(nd_name.GetName());\n\t\t}\n\t\tlet class_names = [];\n\t\tfor (let ndi = nd_name.p; ndi; ndi = ndi.p) {\n\t\t\tif (ndi.node_class == N_CLASS) {\n\t\t\t\tclass_names.push(ndi.GetName());\n\t\t\t}\n\t\t}\n\t\t//namespace deduplication\n\t\tif (names.length > 1) {\n\t\t\tlet inner_starting_class = names[names.length - 1];\n\t\t\tlet p_class_names = class_names.indexOf(inner_starting_class);\n\t\t\tif (p_class_names >= 0) {\n\t\t\t\tclass_names.splice(0, p_class_names + 1);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < class_names.length; i++) {\n\t\t\tnames.push(class_names[i]);\n\t\t}\n\t\tif (!names.length) {continue;}\n\t\t//look up in all possible namespaces\n\t\tlet scopes = [nd_header];\n\t\tif (names.length > 1) {\n\t\t\t//finding in ANY dependent file prevents the sync\n\t\t\tscopes = typing.LookupClassesByNames(nd_header, names.slice(1), {include_dependency: 1});\n\t\t}\n\t\tlet found = 0;\n\t\tfor (let nd_scope of scopes) {\n\t\t\t//constructor forwards are found as calls\n\t\t\tif (nd_scope.Find(N_FUNCTION, names[0]) || nd_scope.Find(N_CALL, names[0])) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\t//check for out-of-class implementation of a private class\n\t\t\tlet body_scopes = typing.LookupClassesByNames(nd_root, names.slice(1), {});\n\t\t\tfor (let nd_scope of body_scopes) {\n\t\t\t\tlet nd_class = nd_scope.Owning(N_CLASS);\n\t\t\t\tif (nd_class && nd_class.data != 'namespace') {\n\t\t\t\t\t//use found=1 to prevent headersyncing\n\t\t\t\t\tfound = 1;\n\t\t\t\t\t//sync to that private class instead\n\t\t\t\t\tif (!nd_scope.Find(N_FUNCTION, names[0]) && !nd_scope.Find(N_CALL, names[0])) {\n\t\t\t\t\t\tlet nd_forward = nd_func.Clone().setCommentsBefore('').setCommentsAfter('');\n\t\t\t\t\t\tnd_forward.GetFunctionNameNode().ReplaceWith(nRef(names[0]).setCommentsBefore(' '))\n\t\t\t\t\t\tnd_forward.LastChild().ReplaceWith(nAir()).setCommentsBefore('').setCommentsAfter('');\n\t\t\t\t\t\tif (nd_forward.c.s.s.node_class == N_LABELED) {\n\t\t\t\t\t\t\t//C++ constructor\n\t\t\t\t\t\t\tnd_forward.c.s.s.ReplaceWith(nAir());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnd_forward = nSemicolon(nd_forward);\n\t\t\t\t\t\tnd_scope.Insert(POS_BACK, nd_forward);\n\t\t\t\t\t\tnd_forward.AutoFormat();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\t//we already have it, no need to sync\n\t\t\t//ignore overloading cases for now\n\t\t\tcontinue;\n\t\t}\n\t\t//assume all ::s along the way are namespaces\n\t\t//recreate them\n\t\tlet failed = 0;\n\t\twhile (failed < names.length) {\n\t\t\tfailed += 1;\n\t\t\tscopes = (failed >= names.length ? [nd_header] : typing.LookupClassesByNames(nd_header, names.slice(failed), {}));\n\t\t\tif (scopes.length) {break;}\n\t\t}\n\t\tlet nd_scope = scopes[0];\n\t\tchanged = 1;\n\t\tlet nd_insertion_root = undefined;\n\t\tfor (let i = failed - 1; i > 0; i--) {\n\t\t\tlet nd_namespace = nClass('namespace', nAir(), nRef(names[i]), nAir(), nScope());\n\t\t\tif (!nd_insertion_root) {\n\t\t\t\tnd_insertion_root = nd_namespace;\n\t\t\t}\n\t\t\tnd_scope.Insert(POS_BACK, nd_namespace);\n\t\t\tnd_scope = nd_namespace.LastChild();\n\t\t}\n\t\tlet nd_forward = nd_func.Clone().setCommentsBefore('').setCommentsAfter('');\n\t\tnd_forward.GetFunctionNameNode().ReplaceWith(nRef(names[0]).setCommentsBefore(' '))\n\t\tnd_forward.LastChild().ReplaceWith(nAir()).setCommentsBefore('').setCommentsAfter('');\n\t\tnd_forward = nSemicolon(nd_forward);\n\t\tif (!nd_insertion_root) {\n\t\t\tnd_insertion_root = nd_forward;\n\t\t}\n\t\tnd_scope.Insert(POS_BACK, nd_forward);\n\t\tnd_insertion_root.AutoFormat();\n\t}\n\tif (changed) {\n\t\t//place #endif to EOF again\n\t\tif (nd_endif) {\n\t\t\tnd_endif.Unlink();\n\t\t\tnd_header.Insert(POS_BACK, nd_endif);\n\t\t}\n\t\tif (options && options.audit) {\n\t\t\tnd_header.Save({name: options.audit, full_path: options.audit});\n\t\t} else {\n\t\t\tnd_header.Save();\n\t\t}\n\t}\n}\n\nmodule.exports = Translate;\n",
		"cpp/c_for", "//Parser for C `for(init;cond;iter){}` loops\n'use strict';\nmodule.exports = function ParseCFor(nd_for) {\n\tif (!(nd_for.node_class == N_SCOPED_STATEMENT && nd_for.data == 'for')) {\n\t\treturn undefined;\n\t}\n\tif (!nd_for.c.isRawNode('(', ')')) {\n\t\treturn undefined;\n\t}\n\tlet raw_parts = nd_for.c.children;\n\tif (raw_parts.length != 5 || !raw_parts[1].isSymbol(';') || !raw_parts[3].isSymbol(';')) {\n\t\treturn undefined;\n\t}\n\treturn {\n\t\tinit: raw_parts[0],\n\t\tcond: raw_parts[2],\n\t\titer: raw_parts[4],\n\t}\n};\n",
		"cpp/cpp_indent", "'use strict';\n/*\n#filter Indent-based scoping for C / C++ / Javascript \nBefore:\n```C++\nint main()\n\tputs(\"hello world\");\n\treturn 0;\n```\n*/\nmodule.exports = function(nd_root) {\n\t//Fix overzealously scoped C Pre-Processor commands\n\t//N_SCOPE inside N_KEYWORD_STATEMENT\n\tfor (let nd_stmt of nd_root.FindAll(N_KEYWORD_STATEMENT)) {\n\t\tif (!nd_stmt.data.startsWith('#')) {continue;}\n\t\tlet nd_scope = nd_stmt.c;\n\t\tlet base_indent_level = nd_stmt.indent_level;\n\t\tif (nd_scope && nd_scope.node_class == N_RAW) {\n\t\t\tbase_indent_level += nd_scope.indent_level;\n\t\t\tnd_scope = nd_scope.LastChild();\n\t\t}\n\t\tif (!(nd_scope && nd_scope.node_class == N_SCOPE)) {continue;}\n\t\tbase_indent_level += nd_scope.indent_level;\n\t\tfor (let ndi = nd_scope.c; ndi; ndi = ndi.s) {\n\t\t\tndi.AdjustIndentLevel(base_indent_level);\n\t\t}\n\t\tnd_scope.indent_level = 0;\n\t\tnd_scope.Unlink();\n\t\tif (!nd_stmt.c) {\n\t\t\tnd_stmt.Insert(POS_BACK, nAir());\n\t\t}\n\t\tlet nd_last = nd_scope.LastChild();\n\t\tif (nd_last.comments_after.endsWith('\\n')) {\n\t\t\tnd_last.comments_after = nd_last.comments_after.substr(0, nd_last.comments_after.length - 1);\n\t\t}\n\t\tlet nd_statements = nd_scope.BreakChild();\n\t\tnd_stmt.Insert(POS_AFTER, nd_statements);\n\t}\n};\nmodule.exports.setup = function(code, options) {\n\tif (code.indexOf('@' + 'disable_cpp_indent') >= 0) {return;}\n\tObject.assign(options, {parse_indent_as_scope: 1,auto_curly_bracket: 1,parse_indent_as_scope_but_merge_cpp_ctor_lines: 1});\n};\n\n",
		"cpp/from_ama", "const amacpp=require('cpp/amacpp');\nconst path=require('path');\nlet nd_root=ParseCurrentFile({parse_indent_as_scope:1,auto_curly_bracket:1,parse_indent_as_scope_but_merge_cpp_ctor_lines:1}).then(amacpp,{update_source:1});\nnd_root.Save(path.extname(__filename));\n//make the per-file script take the translated source\nParseCurrentFile=function(){return nd_root;}\n",
		"cpp/gentag", "'use strict'\nconst assert = require('assert');\nlet gentag = module.exports;\n\ngentag.FindGenTag = function(nd_root, nd_pattern, want_all) {\n\tlet ret = [];\n\tfor (let nd_pragma of nd_root.FindAll(N_KEYWORD_STATEMENT, '#pragma')) {\n\t\tlet nd_arg = nd_pragma.c;\n\t\tif (!nd_arg || nd_arg.node_class != N_CALL || nd_arg.c.node_class != N_REF) {continue;}\n\t\tif ((nd_arg.c.data == 'gen' || nd_arg.c.data == 'gen_begin') && nd_arg.c.s) {\n\t\t\tlet match = nd_arg.c.s.Match(nd_pattern);\n\t\t\tif (match) {\n\t\t\t\tmatch.gentag = nd_pragma;\n\t\t\t\tif (want_all) {\n\t\t\t\t\tret.push(match);\n\t\t\t\t} else {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (want_all) {\n\t\treturn ret;\n\t} else {\n\t\treturn undefined;\n\t}\n};\n\ngentag.FindAllGenTags = function(nd_root, nd_pattern) {\n\treturn gentag.FindGenTag(nd_root, nd_pattern, true);\n};\n\ngentag.UpdateGenTagContent = function(nd_gentag, nd_new) {\n\tassert(nd_gentag.c.node_class == N_CALL && nd_gentag.c.c.node_class == N_REF);\n\tif (nd_gentag.c.GetName() == 'gen_begin') {\n\t\tlet nd_end = nd_gentag.s;\n\t\tlet count = 0;\n\t\twhile (nd_end) {\n\t\t\tif (nd_end.node_class == N_KEYWORD_STATEMENT && nd_end.data == '#pragma' && nd_end.c && nd_end.c.node_class == N_CALL) {\n\t\t\t\tif (nd_end.c.GetName() == 'gen_begin') {\n\t\t\t\t\tcount += 1;\n\t\t\t\t} else if (nd_end.c.GetName() == 'gen_end') {\n\t\t\t\t\tcount -= 1;\n\t\t\t\t\tif (count < 0) {break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd_end = nd_end.s;\n\t\t}\n\t\tif (nd_end) {\n\t\t\tif (!nd_new) {\n\t\t\t\tlet nd_empty_gentag = nd_gentag.Clone();\n\t\t\t\tnd_empty_gentag.c.c.ReplaceWith(nRef('gen'));\n\t\t\t\tnd_gentag.ReplaceUpto(nd_end, nd_empty_gentag);\n\t\t\t} else {\n\t\t\t\tnd_gentag.s.ReplaceUpto(nd_end.Prev(), nd_new);\n\t\t\t\tnd_new.AutoFormat();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t//if we can't find an ending tag, assume it's broken and treat as non-begin 'gen'\n\t}\n\tnd_gentag.c.c.data = 'gen_begin';\n\tlet nd_end = nd_gentag.Clone();\n\tnd_end.c.c.data = 'gen_end';\n\tif (nd_end.comments_before.length > 1) {\n\t\tnd_end.comments_before = '\\n';\n\t}\n\tnd_gentag.Insert(POS_AFTER, nd_end);\n\tif (nd_new) {\n\t\tnd_gentag.Insert(POS_AFTER, nd_new);\n\t\tnd_new.AutoFormat();\n\t}\n};\n\ngentag.DropGeneratedCode = function(nd_root) {\n\tlet all_gen_begins = [];\n\tfor (let nd_pragma of nd_root.FindAll(N_KEYWORD_STATEMENT, '#pragma')) {\n\t\tlet nd_arg = nd_pragma.c;\n\t\tif (!nd_arg || nd_arg.node_class != N_CALL || nd_arg.c.node_class != N_REF) {continue;}\n\t\tif (nd_arg.c.data == 'gen_begin' && nd_arg.c.s) {\n\t\t\tall_gen_begins.push(nd_pragma);\n\t\t}\n\t}\n\tfor (let nd_gentag of all_gen_begins) {\n\t\tgentag.UpdateGenTagContent(nd_gentag, null);\n\t}\n};\n/*\n#filter Generic inverse filter for things like `jsism.EnableJSON`\nThis filter replaces code inside:\n```C++\n#pragma gen_begin(foo)\n#pragma gen_end(foo)\n```\nwith\n```C++\n#pragma gen(foo)\n```\n\nWe recommend custom filters that generate C++ to follow this convention to put generated code inside `gen_begin` and `gen_end`.\nThat allows the generated code to be cleared when synchronized back to `.ama.cpp` files.  \n*/\ngentag.GeneratedCode = function() {};\ngentag.GeneratedCode.inverse = gentag.DropGeneratedCode;\n",
		"cpp/jsism", "'use strict'\nconst assert = require('assert');\nlet jsism = module.exports;\n\nlet console_method_to_options = {\n\tlog: {\n\t\tseparator: ' ',\n\t\ttail: '\\n',\n\t\tostream: 'std::cout',\n\t\tstd_stream: 'stdout',\n\t},\n\terror: {\n\t\tseparator: ' ',\n\t\ttail: '\\n',\n\t\tostream: 'std::cerr',\n\t\tstd_stream: 'stderr',\n\t},\n\t/////////////\n\t//extensions\n\twrite: {\n\t\tseparator: '',\n\t\ttail: '',\n\t\tostream: 'std::cout',\n\t\tstd_stream: 'stdout',\n\t},\n\twriteError: {\n\t\tseparator: '',\n\t\ttail: '',\n\t\tostream: 'std::cerr',\n\t\tstd_stream: 'stderr',\n\t},\n\tformat: {\n\t\tseparator: '',\n\t\ttail: '',\n\t\tostream: 'std::ostringstream()',\n\t\tstd_stream: '/* error: not supported */',\n\t\tjust_format: 1,\n\t},\n};\n/*\n#filter Translate `console.log` to `std::cout << foo`\nThe filter also supports some Javascript formatting methods like `toFixed` and `padStart`.\nBefore:\n```C++\nint main(){\n\tconsole.log(\"hello world\",(0.25).toFixed(3));\n\treturn 0;\n}\n```\n*/\njsism.EnableConsole = function(nd_root, options) {\n\toptions = options || {};\n\tlet backend = options.backend || 'iostream';\n\tlet console_uses = nd_root.FindAll(N_CALL, null).filter(nd_call => {\n\t\treturn nd_call.c.node_class == N_DOT && nd_call.c.c.node_class == N_REF && nd_call.c.c.data == 'console' && console_method_to_options[nd_call.c.data];\n\t});\n\tif (!console_uses.length) {\n\t\treturn;\n\t}\n\tlet need_iomanip = 0;\n\tlet need_sstream = 0;\n\tlet need_ios = 0;\n\tfunction ReplaceWithStdFormat(nd_call) {\n\t\tlet format_parts = [];\n\t\tlet options = console_method_to_options[nd_call.c.data];\n\t\tlet args = [nRef('std').dot('format').setFlags(DOT_CLASS), /*filled later*/null];\n\t\tfor (let ndi = nd_call.c.s; ndi; ndi = ndi.s) {\n\t\t\tif (format_parts.length && options.separator) {\n\t\t\t\tformat_parts.push(options.separator);\n\t\t\t}\n\t\t\tlet nd_value = ndi\n\t\t\tlet fmt = '';\n\t\t\tif (nd_value.node_class == N_STRING) {\n\t\t\t\tformat_parts.push(nd_value.GetStringValue())\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nd_value.isMethodCall('padStart') && nd_value.c.s && nd_value.c.s.node_class == N_NUMBER) {\n\t\t\t\tfmt = ':>' + nd_value.c.s.data;\n\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\tif (nd_value.isMethodCall('toString') && !nd_value.c.s) {\n\t\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\t}\n\t\t\t} else if (nd_value.isMethodCall('padEnd') && nd_value.c.s && nd_value.c.s.node_class == N_NUMBER) {\n\t\t\t\tfmt = ':<' + nd_value.c.s.data;\n\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\tif (nd_value.isMethodCall('toString') && !nd_value.c.s) {\n\t\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nd_value.isMethodCall('toExponential') && !nd_value.c.s) {\n\t\t\t\tif (!fmt) {fmt = ':';}\n\t\t\t\tfmt = fmt + 'e';\n\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t} else if (nd_value.isMethodCall('toFixed') && nd_value.c.s && nd_value.c.s.node_class == N_NUMBER) {\n\t\t\t\tif (!fmt) {fmt = ':';}\n\t\t\t\tfmt = fmt + '.' + nd_value.c.s.data + 'f';\n\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t}\n\t\t\tformat_parts.push('{' + fmt + '}')\n\t\t\targs.push(nd_value);\n\t\t}\n\t\tif (options.tail) {\n\t\t\tformat_parts.push(options.tail);\n\t\t}\n\t\targs[1] = nString(format_parts.join(''));\n\t\tlet nd_format = nCall.apply(null, args);\n\t\tif (!options.just_format) {\n\t\t\tif (options.std_stream == 'stdout') {\n\t\t\t\tnd_format = nCall(nRef('printf'), nString('%s'), nCall(nd_format.dot('c_str')));  \n\t\t\t} else {\n\t\t\t\tnd_format = nCall(nRef('fprintf'), nRef(options.std_stream), nString('%s'), nCall(nd_format.dot('c_str')));  \n\t\t\t}\n\t\t}\n\t\tnd_format.comments_before = nd_call.c.c.comments_before\n\t\tnd_call.ReplaceWith(nd_format);\n\t}\n\tfunction ReplaceWithIOStream(nd_call) {\n\t\tlet options = console_method_to_options[nd_call.c.data];\n\t\tlet nd_stream = ParseCode(options.ostream).c;\n\t\tlet is_first = 1;\n\t\tfor (let ndi = nd_call.c.s; ndi;) {\n\t\t\tlet ndi_next = ndi.s;\n\t\t\tif (is_first) {\n\t\t\t\tis_first = 0;\n\t\t\t} else if (options.separator) {\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nString(options.separator));  \n\t\t\t}\n\t\t\tlet nd_value = ndi;\n\t\t\tif (nd_value.isMethodCall('padStart') && nd_value.c.s && nd_value.c.s.node_class == N_NUMBER) {\n\t\t\t\tneed_iomanip = 1;\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nRef('std').dot('right').setFlags(DOT_CLASS))  ;\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nRef('std').dot('setw').setFlags(DOT_CLASS).call(nd_value.c.s))  \n\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\tif (nd_value.isMethodCall('toString') && !nd_value.c.s) {\n\t\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\t}\n\t\t\t} else if (nd_value.isMethodCall('padEnd') && nd_value.c.s && nd_value.c.s.node_class == N_NUMBER) {\n\t\t\t\tneed_iomanip = 1;\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nRef('std').dot('left').setFlags(DOT_CLASS))  ;\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nRef('std').dot('setw').setFlags(DOT_CLASS).call(nd_value.c.s))  \n\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\tif (nd_value.isMethodCall('toString') && !nd_value.c.s) {\n\t\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nd_value.isMethodCall('toExponential') && !nd_value.c.s) {\n\t\t\t\tneed_iomanip = 1;\n\t\t\t\tneed_ios = 1\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nRef('std').dot('scientific').setFlags(DOT_CLASS))  \n\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nd_value);\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nRef('std').dot('defaultfloat').setFlags(DOT_CLASS))  ;\n\t\t\t\tndi = ndi_next;\n\t\t\t\tcontinue;\n\t\t\t} else if (nd_value.isMethodCall('toFixed') && nd_value.c.s && nd_value.c.s.node_class == N_NUMBER) {\n\t\t\t\tneed_iomanip = 1;\n\t\t\t\tneed_ios = 1;\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nRef('std').dot('fixed').setFlags(DOT_CLASS))  \n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nRef('std').dot('setprecision').setFlags(DOT_CLASS).call(nd_value.c.s))  ;\n\t\t\t\tnd_value = nd_value.c.c;\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nd_value);\n\t\t\t\tnd_stream = nBinop(nd_stream, '<<', nRef('std').dot('defaultfloat').setFlags(DOT_CLASS))  ;\n\t\t\t\tndi = ndi_next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnd_stream = nBinop(nd_stream, '<<', nParen(nd_value));\n\t\t\tndi = ndi_next;\n\t\t}\n\t\tif (options.tail) {\n\t\t\tnd_stream = nBinop(nd_stream, '<<', options.tail == '\\n' ? nRef('std').dot('endl').setFlags(DOT_CLASS) : nString(options.tail));  \n\t\t}\n\t\tif (options.just_format) {\n\t\t\tneed_sstream = 1;\n\t\t\tnd_stream = nCall(nSymbol('(std::ostringstream&)'), nd_stream).enclose('()').dot('str').call();\n\t\t}\n\t\tnd_call.ReplaceWith(nd_stream);\n\t\tnd_stream.comments_after = '';\n\t}\n\tfor (let nd_call of console_uses) {\n\t\tif (backend == 'std::format') {\n\t\t\tReplaceWithStdFormat(nd_call);\n\t\t} else if (backend == 'iostream') {\n\t\t\tReplaceWithIOStream(nd_call);\n\t\t} else {\n\t\t\tthrow new Error('unknown backend ' + backend);\n\t\t}\n\t}\n\tif (backend == 'std::format') {\n\t\tnd_root.InsertDependency(DEP_C_INCLUDE | DEPF_C_INCLUDE_NONSTR, '<format>');\n\t\tnd_root.InsertDependency(DEP_C_INCLUDE | DEPF_C_INCLUDE_NONSTR, '<stdio.h>');\n\t} else if (backend == 'iostream') {\n\t\tif (need_ios) {\n\t\t\tnd_root.InsertDependency(DEP_C_INCLUDE | DEPF_C_INCLUDE_NONSTR, '<ios>');\n\t\t}\n\t\tif (need_iomanip) {\n\t\t\tnd_root.InsertDependency(DEP_C_INCLUDE | DEPF_C_INCLUDE_NONSTR, '<iomanip>');\n\t\t}\n\t\tif (need_sstream) {\n\t\t\tnd_root.InsertDependency(DEP_C_INCLUDE | DEPF_C_INCLUDE_NONSTR, '<sstream>');\n\t\t}\n\t\tnd_root.InsertDependency(DEP_C_INCLUDE | DEPF_C_INCLUDE_NONSTR, '<iostream>');\n\t}\n};\n\n/*\n#filter Enable `JSON.stringify` and `JSON.parse<T>` in C++\nTo use this filter, you need to: \n```C++\n#include \"<.ama_modules dir>/modules/cpp/json/json.h\"\n```\nAnd add `json.cpp` to your project. For each class you wish to stringify or parse, add:\n```C++\n#pragma gen(JSON.stringify<YourClass>)\n```\nor\n```C++\n#pragma gen(JSON.parse<YourClass>)\n```\nin a file with this filter enabled. The pragmas will be translated to stringify / parse implementation.\nIf the class is in the same file as the `JSON.foo`, the pragma can be omitten.\n\nBefore:\n```C++\n#include <iostream>\n#include \"<.ama_modules dir>/modules/cpp/json/json.h\"\n\nstruct Test{\n\tint a;\n};\nint main(){\n\tTest obj{3};\n\tstd::cout<<JSON.stringify(obj)<<std::endl;\n\treturn 0;\n}\n```\n*/\njsism.EnableJSON = function(nd_root) {\n\t//stringify / parse callback generation\n\t//for persistent, we want StringifyToImpl in header\n\t//replace #pragma with JSON impl\n\t//generate #pragma when call scanner finds a type without implementation\n\tconst typing = require('cpp/typing');\n\tconst gentag = require('cpp/gentag');\n\trequire('class');\n\tfor (let nd_json of nd_root.FindAll(N_REF, 'JSON')) {\n\t\tlet nd_parent = nd_json.p;\n\t\tif (nd_parent.node_class != N_DOT || nd_parent.flags != 0) {continue;}\n\t\tlet nd_owning_pragma = nd_json.Owning(N_KEYWORD_STATEMENT);\n\t\tif (nd_owning_pragma && nd_owning_pragma.data == '#pragma') {continue;}\n\t\tlet nd_call = nd_parent.p;\n\t\tlet type = undefined;\n\t\tif (nd_parent.data == 'stringify' && nd_call && nd_call.node_class == N_CALL && nd_call.c.s) {\n\t\t\ttype = typing.ComputeType(nd_call.c.s);\n\t\t} else if (nd_parent.data == 'parse' && nd_call && nd_call.node_class == N_CALL_TEMPLATE && nd_call.c.s) {\n\t\t\ttype = typing.ComputeType(nd_call.c.s);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (type && type.node_class == N_CLASS) {\n\t\t\t//look for implementation in both class header and the call site\n\t\t\t//#pragma gen(JSON.stringify<foo>)\n\t\t\t//#pragma gen_begin(JSON.stringify<foo>)\n\t\t\t//#pragma gen_end(JSON.stringify<foo>)\n\t\t\t//dedicated finder for generator tags? replacement / inverse? make generating passes use those tags?\n\t\t\t//how do we differentiate request from result? replace gen with gen_begin and gen_end\n\t\t\tlet nd_tag = nCallTemplate(nDot(\"foo\", nRef(\"JSON\")), (typing.AccessTypeAt(type, nd_root)));\n\t\t\tnd_tag.Find(N_DOT, 'foo').data = nd_parent.data;\n\t\t\tlet match_gentag = gentag.FindGenTag(nd_root, nd_tag);\n\t\t\tif (!match_gentag) {\n\t\t\t\tmatch_gentag = gentag.FindGenTag(type.Root(), nd_tag);;\n\t\t\t}\n\t\t\tif (!match_gentag) {\n\t\t\t\t//create a new gentag and insert it\n\t\t\t\t//COULDDO: insert recursively\n\t\t\t\tlet nd_gentag = nKeywordStatement(\"#pragma\", nCall(nRef(\"gen\"), (nd_tag)).setCommentsBefore(\" \"));\n\t\t\t\tif (type.Root() == nd_root) {\n\t\t\t\t\ttype.ParentStatement().Insert(POS_AFTER, nd_gentag.setCommentsBefore('\\n'));\n\t\t\t\t} else {\n\t\t\t\t\tlet deps = nd_root.FindAll(N_DEPENDENCY, null);\n\t\t\t\t\tif (deps.length) {\n\t\t\t\t\t\tdeps[deps.length - 1].Insert(POS_AFTER, nd_gentag.setCommentsBefore('\\n'));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnd_root.Insert(POS_FRONT, nd_gentag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//make it `JSON::`\n\t\tnd_parent.flags = DOT_CLASS;\n\t}\n\t//generate code for the gentags\n\tfor (let match of gentag.FindAllGenTags(nd_root, nCallTemplate(nDot(\"stringify\", nRef(\"JSON\")), (Node.MatchAny('type'))))) {\n\t\tlet type = typing.ComputeType(match.type);\n\t\tif (type.node_class != N_CLASS) {continue;}\n\t\t//generate and replace\n\t\tlet desc = type.ParseClass();\n\t\tlet nd_generated = nClass(\"namespace\", nAir(), nRef(\"JSON\").setFlags(4).setCommentsBefore(\" \"), nAir(), nScope(nSemicolon(nScopedStatement(\"template\", nParameterList().setFlags(1).setCommentsBefore(\" \"), nClass(\"struct\", nAir(), nRef(\"StringifyToImpl\").setFlags(4).setCommentsBefore(\" \"), nRaw((typing.AccessTypeAt(type, match.gentag))).setFlags(15932), nScope(nSemicolon(nKeywordStatement(\"typedef\", nRaw(nRef(\"void\"), nRef(\"type\").setCommentsBefore(\" \")).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n//`type` is only used for SFINAE\\n\").setIndent(4), nScopedStatement(\"template\", nParameterList(nAssignment(nRaw(nRef(\"typename\"), nRef(\"T\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), (typing.AccessTypeAt(type, match.gentag)))).setFlags(1).setCommentsBefore(\" \"), nFunction(\"stringifyTo\", nRaw(nRef(\"static\"), nRef(\"void\").setCommentsBefore(\" \"), nRef(\"stringifyTo\").setFlags(5).setCommentsBefore(\" \")), nParameterList(nAssignment(nRaw(nPostfix(\"&\", nDot(\"string\", nRef(\"std\")).setFlags(2)), nRef(\"buf\").setFlags(5).setCommentsBefore(\" \")), nAir()), nAssignment(nRaw(nPostfix(\"&\", nPostfix(\"const\", (typing.AccessTypeAt(type, match.gentag)).setCommentsAfter(\" \"))), nRef(\"a\").setFlags(5).setCommentsBefore(\" \")), nAir()).setCommentsBefore(\" \")), nAir(), nScope(nSemicolon(nCall(nDot(\"push_back\", nRef(\"buf\")), nString(\"{\").setFlags(3))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nRef(\"__INSERT_HERE\")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nDot(\"push_back\", nRef(\"buf\")), nString(\"}\").setFlags(3))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\")/*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*/;\n\t\tlet body = [];\n\t\tfor (let ppt of desc.properties) {\n\t\t\tif (!ppt.enumerable) {continue;}\n\t\t\t//comment tag check\n\t\t\tlet nd_stmt = ppt.node.ParentStatement();\n\t\t\tif (nd_stmt.comments_before.indexOf('nojson') >= 0 || nd_stmt.comments_after.indexOf('nojson') >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (body.length) {\n\t\t\t\tbody.push(nSemicolon(nCall(nDot(\"push_back\", nRef(\"buf\")), nString(\",\").setFlags(3))).setCommentsBefore(\"\\n\")/*\n\t\t\t\t*\n\t\t\t\t*/);\n\t\t\t}\n\t\t\tbody.push(nSemicolon(nCall(nDot(\"append\", nRef(\"buf\")), (nString(JSON.stringify(ppt.name) + ':')))).setCommentsBefore(\"\\n\")/*\n\t\t\t*\n\t\t\t*/);\n\t\t\tbody.push(nSemicolon(nCall(nDot(\"stringifyTo\", nRef(\"JSON\")).setFlags(2), nRef(\"buf\"), (nRef('a').dot(ppt.name)).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\")/*\n\t\t\t*\n\t\t\t*/);\n\t\t}\n\t\tnd_generated.Find(N_REF, '__INSERT_HERE').ParentStatement().ReplaceWith(nScope.apply(null, body).c);\n\t\tgentag.UpdateGenTagContent(match.gentag, nd_generated);\n\t}\n\tfor (let match of gentag.FindAllGenTags(nd_root, nCallTemplate(nDot(\"parse\", nRef(\"JSON\")), (Node.MatchAny('type'))))) {\n\t\tlet type = typing.ComputeType(match.type);\n\t\tif (type.node_class != N_CLASS) {continue;}\n\t\t//generate and replace\n\t\tlet desc = type.ParseClass();\n\t\tlet nd_generated = nClass(\"namespace\", nAir(), nRef(\"JSON\").setFlags(4).setCommentsBefore(\" \"), nAir(), nScope(nSemicolon(nScopedStatement(\"template\", nParameterList().setFlags(1).setCommentsBefore(\" \"), nClass(\"struct\", nAir(), nRef(\"ParseFromImpl\").setFlags(4).setCommentsBefore(\" \"), nRaw((typing.AccessTypeAt(type, match.gentag))).setFlags(15932), nScope(nSemicolon(nKeywordStatement(\"typedef\", nRaw(nRef(\"void\"), nRef(\"type\").setCommentsBefore(\" \")).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n//`type` is only used for SFINAE\\n\").setIndent(4), nScopedStatement(\"template\", nParameterList(nAssignment(nRaw(nRef(\"typename\"), nRef(\"T\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), (typing.AccessTypeAt(type, match.gentag)))).setFlags(1).setCommentsBefore(\" \"), nFunction(\"parseFrom\", nRaw(nRef(\"static\"), (typing.AccessTypeAt(type, match.gentag)).setCommentsBefore(\" \"), nRef(\"parseFrom\").setFlags(5).setCommentsBefore(\" \")), nParameterList(nAssignment(nRaw(nPostfix(\"&\", nRef(\"JSONParserContext\")), nRef(\"ctx\").setFlags(5).setCommentsBefore(\" \")), nAir()), nAssignment(nPostfix(\"**\", (typing.AccessTypeAt(type, match.gentag))), nAir()).setCommentsBefore(\" \")), nAir(), nScope(nSemicolon(nRaw(nRef(\"T\"), nRef(\"ret\").setFlags(5).setCommentsBefore(\" \"), nScope())).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nBinop(\"==\", nDot(\"begin\", nRef(\"ctx\")).setCommentsAfter(\" \"), nDot(\"end\", nRef(\"ctx\")).setCommentsBefore(\" \")).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nSemicolon(nKeywordStatement(\"return\", nCall(nDot(\"move\", nRef(\"std\")).setFlags(2), nRef(\"ret\")).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nDot(\"SkipSpace\", nRef(\"ctx\")))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nBinop(\"!=\", nPrefix(\"*\", nDot(\"begin\", nRef(\"ctx\"))).setCommentsAfter(\" \"), nString(\"{\").setFlags(3).setCommentsBefore(\" \")).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nSemicolon(nAssignment(nDot(\"error\", nRef(\"ctx\")).setCommentsAfter(\" \"), nString(\"'{' expected\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nDot(\"error_location\", nRef(\"ctx\")).setCommentsAfter(\" \"), nDot(\"begin\", nRef(\"ctx\")))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nKeywordStatement(\"return\", nCall(nDot(\"move\", nRef(\"std\")).setFlags(2), nRef(\"ret\")).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(\"+\", nDot(\"begin\", nRef(\"ctx\").setFlags(3)), nNumber(\"1\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nDot(\"SkipSpace\", nRef(\"ctx\")))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"while\", nParen(nBinop(\"&&\", nBinop(\"!=\", nDot(\"begin\", nRef(\"ctx\")).setCommentsAfter(\" \"), nDot(\"end\", nRef(\"ctx\")).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nBinop(\"!=\", nItem(nDot(\"begin\", nRef(\"ctx\")), nNumber(\"0\")).setCommentsAfter(\" \"), nString(\"}\").setFlags(3).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nSemicolon(nCall(nDot(\"SkipSpace\", nRef(\"ctx\")))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nRef(\"__PARSE_FIELD_HERE\")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nLabeled(nRef(\"skip\"), nCall(nDot(\"SkipStringBody\", nRef(\"ctx\"))).setCommentsBefore(\"\\n\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nDot(\"SkipField\", nRef(\"ctx\")))).setCommentsBefore(\"\\n\").setIndent(4), nLabeled(nRef(\"done\"), nScopedStatement(\"if\", nParen(nDot(\"error\", nRef(\"ctx\")).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nSemicolon(nKeywordStatement(\"return\", nCall(nDot(\"move\", nRef(\"std\")).setFlags(2), nRef(\"ret\")).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nDot(\"SkipSpace\", nRef(\"ctx\")))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nBinop(\"&&\", nBinop(\"!=\", nDot(\"begin\", nRef(\"ctx\")).setCommentsAfter(\" \"), nDot(\"end\", nRef(\"ctx\")).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nParen(nBinop(\"||\", nBinop(\"==\", nPrefix(\"*\", nDot(\"begin\", nRef(\"ctx\"))).setCommentsAfter(\" \"), nString(\",\").setFlags(3).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nBinop(\"==\", nPrefix(\"*\", nDot(\"begin\", nRef(\"ctx\"))).setCommentsAfter(\" \"), nString(\"}\").setFlags(3).setCommentsBefore(\" \")).setCommentsBefore(\" \"))).setCommentsBefore(\" \")).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nScopedStatement(\"if\", nParen(nBinop(\"==\", nPrefix(\"*\", nDot(\"begin\", nRef(\"ctx\"))).setCommentsAfter(\" \"), nString(\",\").setFlags(3).setCommentsBefore(\" \")).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nSemicolon(nAssignment(\"+\", nDot(\"begin\", nRef(\"ctx\").setFlags(3)), nNumber(\"1\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \"), nExtensionClause(\"else\", nAir(), nScope(nSemicolon(nAssignment(nDot(\"error\", nRef(\"ctx\")).setCommentsAfter(\" \"), nString(\"',' or '}' expected\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nDot(\"error_location\", nRef(\"ctx\")).setCommentsAfter(\" \"), nDot(\"begin\", nRef(\"ctx\")))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nKeywordStatement(\"return\", nCall(nDot(\"move\", nRef(\"std\")).setFlags(2), nRef(\"ret\")).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nBinop(\"!=\", nDot(\"begin\", nRef(\"ctx\")).setCommentsAfter(\" \"), nDot(\"end\", nRef(\"ctx\")).setCommentsBefore(\" \")).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nSemicolon(nAssignment(\"+\", nDot(\"begin\", nRef(\"ctx\").setFlags(3)), nNumber(\"1\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nKeywordStatement(\"return\", nCall(nDot(\"move\", nRef(\"std\")).setFlags(2), nRef(\"ret\")).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\")/*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*/;\n\t\tlet properties = [];\n\t\tfor (let ppt of desc.properties) {\n\t\t\tif (!ppt.enumerable) {continue;}\n\t\t\t//comment tag check\n\t\t\tlet nd_stmt = ppt.node.ParentStatement();\n\t\t\tif (nd_stmt.comments_before.indexOf('nojson') >= 0 || nd_stmt.comments_after.indexOf('nojson') >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!ppt.name) {continue;}\n\t\t\tppt.type = typing.ComputeType(ppt.node);\n\t\t\tif (!ppt.type) {continue;}\n\t\t\tppt.json_name = JSON.stringify(ppt.name);\n\t\t\tproperties.push(ppt);\n\t\t}\n\t\tproperties.sort((a, b) => (a.json_name < b.json_name ? -1 : (a.json_name > b.json_name ? 1 : 0)));\n\t\tfunction GenerateParseField(properties, lg_eaten) {\n\t\t\tif (!properties.length) {return nAir();}\n\t\t\t//eating the common prefix\n\t\t\tlet name0 = properties[0].json_name;\n\t\t\tlet name1 = properties[properties.length - 1].json_name;\n\t\t\tlet lg_prefix = Math.min(__byte_length(name0), __byte_length(name1)) - lg_eaten;\n\t\t\tfor (let i = 0; i < lg_prefix; i++) {\n\t\t\t\tif (__byte_at(name0, i + lg_eaten) != __byte_at(name1, i + lg_eaten)) {\n\t\t\t\t\tlg_prefix = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet nd_prefix = undefined;\n\t\t\tif (lg_prefix > 0) {\n\t\t\t\tnd_prefix = nScopedStatement(\"if\", nParen(nPrefix(\"!\", nCall(nDot(\"TrySkipName\", nRef(\"ctx\")), (nString(__byte_substr(name0, lg_eaten, lg_prefix))))).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nSemicolon(nKeywordStatement(\"goto\", nRef(\"skip\").setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \"), nExtensionClause(\"else\", nAir(), nScope(nSemicolon(nRef(\"__SWITCH\")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\")/*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*/;\n\t\t\t\tlg_eaten += lg_prefix;\n\t\t\t}\n\t\t\t//no-switch special case\n\t\t\tlet nd_switch = undefined;\n\t\t\tif (properties.length == 1) {\n\t\t\t\tnd_switch = nScope(nSemicolon(nCall(nDot(\"SkipColon\", nRef(\"ctx\")))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nDot(\"error\", nRef(\"ctx\")).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nSemicolon(nKeywordStatement(\"return\", nCall(nDot(\"move\", nRef(\"std\")).setFlags(2), nRef(\"ret\")).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment((nRef('ret').dot(properties[0].name)).setCommentsAfter(\" \"), nCall(nDot(\"parseFrom\", nRef(\"JSON\")).setFlags(2), nRef(\"ctx\"), nCall(nParen(nPostfix(\"**\", (typing.AccessTypeAt(properties[0].type, match.gentag)))), nRef(\"NULL\")).setCommentsBefore(\" \")))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nDot(\"error\", nRef(\"ctx\")).setCommentsBefore(\" \").setCommentsAfter(\" \")).setCommentsBefore(\" \"), nScope(nSemicolon(nKeywordStatement(\"return\", nCall(nDot(\"move\", nRef(\"std\")).setFlags(2), nRef(\"ret\")).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nKeywordStatement(\"goto\", nRef(\"done\").setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*/;\n\t\t\t} else {\n\t\t\t\t//there cannot be a directly-return case: quotes should ensure that for us\n\t\t\t\t//first-byte switch\n\t\t\t\tlet i0 = 0;\n\t\t\t\tlet byte_i0 = undefined;\n\t\t\t\tlet cases = [];\n\t\t\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\t\t\tassert(lg_eaten < __byte_length(properties[i].json_name));\n\t\t\t\t\tlet byte_i = __byte_at(properties[i].json_name, lg_eaten) | 0;\n\t\t\t\t\tif (byte_i0 == undefined || byte_i != byte_i0) {\n\t\t\t\t\t\tif (i0 < i) {\n\t\t\t\t\t\t\tcases.push({\n\t\t\t\t\t\t\t\tstart: i0,\n\t\t\t\t\t\t\t\tend: i,\n\t\t\t\t\t\t\t\tindicator: byte_i0\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti0 = i;\n\t\t\t\t\t\tbyte_i0 = byte_i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i0 < properties.length) {\n\t\t\t\t\tcases.push({\n\t\t\t\t\t\tstart: i0,\n\t\t\t\t\t\tend: properties.length,\n\t\t\t\t\t\tindicator: byte_i0\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t//the default clause breaks and skips\n\t\t\t\tnd_switch = nScopedStatement(\"switch\", nParen(nPrefix(\"*\", nDot(\"begin\", nRef(\"ctx\")))).setCommentsBefore(\" \"), nScope().setCommentsBefore(\" \")).setCommentsBefore(\"\\n\")/*\n\t\t\t\t*\n\t\t\t\t*/;\n\t\t\t\tlet nd_body = nd_switch.Find(N_SCOPE, null);\n\t\t\t\tfor (let i = 0; i < cases.length; i++) {\n\t\t\t\t\tlet nd_char = undefined;\n\t\t\t\t\tif (cases[i].indicator >= 32 && cases[i].indicator < 127) {\n\t\t\t\t\t\tnd_char = nString(String.fromCharCode(cases[i].indicator)).setFlags(STRING_SINGLE_QUOTED | LITERAL_PARSED);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnd_char = nNumber(cases[i].indicator.toString());\n\t\t\t\t\t}\n\t\t\t\t\t//we must not have ; after the @(): it screws up multi-node insertion\n\t\t\t\t\tnd_body.Insert(POS_BACK, nLabeled(nRaw(nRef(\"case\"), (nd_char).setCommentsBefore(\" \")), nScope(nSemicolon(nAssignment(\"+\", nDot(\"begin\", nRef(\"ctx\").setFlags(3)), nNumber(\"1\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nRaw((GenerateParseField(properties.slice(cases[i].start, cases[i].end), lg_eaten + 1)), nKeywordStatement(\"break\", nAir()).setCommentsBefore(\"\\n\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\")/*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*/);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nd_prefix) {\n\t\t\t\tnd_prefix.Find(N_REF, '__SWITCH').ParentStatement().ReplaceWith(nd_switch);\n\t\t\t\tnd_switch = nd_prefix.setCommentsBefore('');\n\t\t\t}\n\t\t\treturn nd_switch;\n\t\t}\n\t\tnd_generated.Find(N_REF, '__PARSE_FIELD_HERE').ParentStatement().ReplaceWith(GenerateParseField(properties, 0));\n\t\tgentag.UpdateGenTagContent(match.gentag, nd_generated);\n\t}\n};\n\n/*\n#filter Enable Javascript `()=>{}` syntax for C++ lambda\nBefore:\n```C++\nstd::sort(a.begin(), a.end(), (int x, int y)=>{return x<y;});\n```\n*/\njsism.EnableJSLambdaSyntax = function(nd_root) {\n\t//()=>{} <=> [&](){}\n\tfor (let nd_func of nd_root.FindAll(N_FUNCTION, null)) {\n\t\tlet nd_before = nd_func.c;\n\t\tlet nd_after = nd_func.c.s.s;\n\t\tif (nd_after.isSymbol('=>')) {\n\t\t\tnd_after.ReplaceWith(nAir()).setCommentsBefore('').setCommentsAfter('');\n\t\t\tnd_before.ReplaceWith(nRaw(nSymbol(\"&\")).setFlags(23899));\n\t\t}\n\t}\n};\n\njsism.EnableJSLambdaSyntax.inverse = function(nd_root) {\n\t//()=>{} <=> [&](){}\n\tlet nd_template = nRaw(nSymbol(\"&\")).setFlags(23899);\n\tfor (let nd_func of nd_root.FindAll(N_FUNCTION, null)) {\n\t\tlet nd_before = nd_func.c;\n\t\tlet nd_after = nd_func.c.s.s;\n\t\tif (nd_before.Match(nd_template)) {\n\t\t\tnd_after.ReplaceWith(nSymbol('=>')).setCommentsBefore(' ');\n\t\t\tnd_before.ReplaceWith(nAir());\n\t\t}\n\t}\n};\n\n/*\n#filter Enable single-quoted strings for C/C++\nDo not use this filter if you need multi-char constants.\n\nBefore:\n```C++\nputs('hello world');\n```\n*/\njsism.EnableSingleQuotedStrings = function(nd_root) {\n\tfor (let nd_str of nd_root.FindAll(N_STRING)) {\n\t\tlet bk_flags = nd_str.flags;\n\t\tlet bk_data = nd_str.data;\n\t\tif (nd_str.data.startsWith(\"'\") && nd_str.GetStringValue().length > 1) {\n\t\t\tnd_str.flags &= ~STRING_SINGLE_QUOTED;\n\t\t} else {\n\t\t\t//avoid unescaping / re-escaping strings unnecessarily\n\t\t\tnd_str.data = bk_data;\n\t\t\tnd_str.flags = bk_flags;\n\t\t}\n\t}\n};\n",
		"cpp/line_sync", "'use strict';\n/*\n#filter Allow using `#line __AMA_LINE__` to synchronize object file line numbers to `foo.ama.cpp`\nThe filter simply replaces `__AMA_LINE__` with actual line numbers.\nBefore:\n```C++\n#pragma gen(some_generated_code)\n#line __AMA_LINE__\nint main(){\n\treturn 0;\n}\n```\n*/\nfunction Translate(nd_root) {\n\tfor (let nd_line of nd_root.FindAll(N_KEYWORD_STATEMENT, '#line')) {\n\t\tnd_line.c.ReplaceWith(nNumber((nd_line.ComputeLineNumber() + 2).toString()));\n\t}\n\treturn nd_root;\n}\n\nfunction Untranslate(nd_root) {\n\tfor (let nd_line of nd_root.FindAll(N_KEYWORD_STATEMENT, '#line')) {\n\t\tnd_line.c.ReplaceWith(nRef('__AMA_LINE__'));\n\t}\n\treturn nd_root;\n}\n\nTranslate.inverse = Untranslate;\nmodule.exports = Translate;\n",
		"cpp/move_operator", "'use strict';\n\n//COULDDO: auto-move last ref\n//default_options.prefix_operators = '<< ' + default_options.prefix_operators;\n\nfunction BidirTransform(nd_root, is_forward) {\n\tif (is_forward) {\n\t\tfor (let nd of nd_root.FindAll(N_PREFIX, '<<')) {\n\t\t\tnd.ReplaceWith(nCall(nDot(\"move\", nRef(\"std\")).setFlags(2), (nd.c.node_class == N_PAREN ? nd.c.c : nd.c)));\n\t\t}\n\t} else {\n\t\tfor (let match of nd_root.MatchAll(nCall(nDot(\"move\", nRef(\"std\")).setFlags(2), (Node.MatchAny('opr'))))) {\n\t\t\tlet nd_opr = match.opr;\n\t\t\tif (nd_opr.node_class != N_REF && nd_opr.node_class != N_DOT && nd_opr.node_class != N_CALL && nd_opr.node_class != N_ITEM) {\n\t\t\t\tnd_opr = nParen(nd_opr);\n\t\t\t}\n\t\t\tmatch.nd.ReplaceWith(nPrefix('<<', nd_opr));\n\t\t}\n\t}\n\treturn nd_root;\n}\n\n/*\n#filter Use prefix `<<` for `std::move`\nBefore:\n```C++\nstd::string MakeSomeString(){\n\tstd::string ret;\n\t...\n\treturn <<ret;\n}\n```\n*/\nfunction Translate(nd_root) {\n\treturn BidirTransform(nd_root, 1);\n}\n\nfunction Untranslate(nd_root) {\n\treturn BidirTransform(nd_root, 0);\n}\n\nTranslate.inverse = Untranslate;\nTranslate.setup = function(code, options) {\n\toptions.prefix_operators = '<< ' + options.prefix_operators;\n};\nmodule.exports = Translate;\n",
		"cpp/sane_export", "'use strict';\nconst path = require('path');\nrequire('class');\n\nfunction BidirTransform(nd_root, is_forward) {\n\tif (path.extname(nd_root.data).startsWith('.h')) {return nd_root;}\n\tlet from = is_forward ? 'public' : 'static';\n\tlet to = is_forward ? 'static' : 'public';\n\tfor (let nd_func of nd_root.FindAll(N_FUNCTION, null)) {\n\t\tlet nd_owner = nd_func.Owner();\n\t\tif (!(nd_owner.node_class == N_CLASS && nd_owner.data == 'namespace' || nd_owner.node_class == N_FILE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(nd_func.c.node_class == N_RAW && nd_func.c.c && nd_func.c.LastChild().node_class == N_REF)) {\n\t\t\t//don't do the static magic on method implementations\n\t\t\tcontinue;\n\t\t}\n\t\tif (nd_func.LastChild().node_class != N_SCOPE) {\n\t\t\t//don't do it on forward declarations\n\t\t\tcontinue;\n\t\t}\n\t\tlet nd_before = nd_func.c;\n\t\tlet nd_kw = nd_before.Find(N_REF, from);\n\t\tif (nd_kw) {\n\t\t\tlet nd_next = nd_kw.s;\n\t\t\tnd_kw.Unlink();\n\t\t\tif (nd_next) {\n\t\t\t\tnd_next.comments_before = nd_next.comments_before.replace(/^[ \\t\\r\\n]+/, '');\n\t\t\t}\n\t\t} else if (nd_before.node_class == N_RAW) {\n\t\t\t//inverse it\n\t\t\tif (!nd_before.Find(N_REF, to)) {\n\t\t\t\tlet nd_1st = nd_before.c;\n\t\t\t\tif (nd_1st && nd_1st.node_class == N_CALL_TEMPLATE && nd_1st.GetName() == 'template') {\n\t\t\t\t\tnd_1st.Insert(POS_AFTER, nRef(to).setCommentsAfter(' '));\n\t\t\t\t} else {\n\t\t\t\t\tnd_before.Insert(POS_FRONT, nRef(to).setCommentsAfter(' '));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nd_root;\n}\n\n/*\n#filter Default global functions to `static` unless specified as `public`\nBefore:\n```C++\nint square(int x){return x*x;}\npublic int main(int argc){\n\treturn square(argc);\n}\n```\n*/\nfunction Translate(nd_root) {\n\treturn BidirTransform(nd_root, 1);\n}\n\nfunction Untranslate(nd_root) {\n\treturn BidirTransform(nd_root, 0);\n}\n\nTranslate.inverse = Untranslate;\nmodule.exports = Translate;\n",
		"cpp/sane_for", "'use strict';\n/*\n#filter Extend C++ `for` syntax with `for(foo of bar)` and `for(i<foo)` \nBefore:\n```C++\nint main() {\n\tstd::vector<int> a;\n\tfor(int i<10){\n\t\ta.push_back(i);\n\t}\n\tfor(int i in a){\n\t\tstd::cout<<i;\n\t}\n\treturn 0;\n}\n```\n*/\nmodule.exports = function(nd_root) {\n\tfor (let nd_for of nd_root.FindAll(N_SCOPED_STATEMENT, 'for')) {\n\t\tlet nd_range = nd_for.c;\n\t\tif (nd_range.node_class == N_PAREN || nd_range.node_class == N_LABELED) {\n\t\t\tnd_range = nd_range.c;\n\t\t}\n\t\t//for-in\n\t\tlet nd_in_of = nd_range.Find(N_BINOP, 'in') || nd_range.Find(N_BINOP, 'of');\n\t\tif (nd_in_of) {\n\t\t\tnd_in_of.node_class = N_LABELED;\n\t\t\tnd_in_of.data = '';\n\t\t} else if (nd_range.node_class == N_BINOP && (nd_range.data == '<' || nd_range.data == '<=')) {\n\t\t\tlet nd_i = nd_range.c;\n\t\t\tlet nd_n = nd_range.c.s;\n\t\t\tlet nd_tmp = Node.GetPlaceHolder();\n\t\t\tnd_for.c.ReplaceWith(nd_tmp);\n\t\t\tnd_range.BreakSibling();\n\t\t\tnd_tmp.ReplaceWith(nRaw(nAssignment(nRaw(nRef(\"auto\"), (nd_i.Clone()).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\")), nSymbol(\";\"), (nd_range).setCommentsBefore(\" \"), nSymbol(\";\"), nPostfix(\"++\", (nd_i.Clone())).setCommentsBefore(\" \")).setFlags(10536));\n\t\t\tcontinue;\n\t\t} else if (nd_range.node_class == N_RAW && nd_range.c && nd_range.LastChild().node_class == N_BINOP && (nd_range.LastChild().data == '<' || nd_range.LastChild().data == '<=')) {\n\t\t\tlet nd_cmp = nd_range.LastChild().Unlink()\n\t\t\tlet nd_i = nd_cmp.c;\n\t\t\tlet nd_n = nd_cmp.c.s;\n\t\t\tlet nd_tmp = Node.GetPlaceHolder();\n\t\t\tnd_for.c.ReplaceWith(nd_tmp);\n\t\t\tnd_tmp.ReplaceWith(nRaw(nAssignment(nRaw((nd_range), (nd_i.Clone()).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\")), nSymbol(\";\"), (nd_cmp).setCommentsBefore(\" \"), nSymbol(\";\"), nPostfix(\"++\", (nd_i.Clone())).setCommentsBefore(\" \")).setFlags(10536));\n\t\t\tcontinue;\n\t\t}\n\t\t//parse for(:) as declaration\n\t\tif (nd_range.node_class == N_LABELED) {\n\t\t\tlet nd_def = nd_range.c;\n\t\t\tif (nd_def.node_class == N_REF) {\n\t\t\t\tnd_def.flags |= REF_WRITTEN;\n\t\t\t} else if (nd_def.node_class == N_RAW && nd_def.c && nd_def.LastChild().node_class == N_REF) {\n\t\t\t\tnd_def.LastChild().flags |= REF_WRITTEN | REF_DECLARED;\n\t\t\t}\n\t\t}\n\t}\n};\n",
		"cpp/sane_init", "'use strict';\nrequire('class');\nlet typing = undefined;\n/////////////\nfunction isTypeLike(nd_type) {\n\treturn nd_type.node_class == N_REF || nd_type.node_class == N_DOT || nd_type.node_class == N_CALL_TEMPLATE;\n}\nlet g_obj_init_transform = {\n\tfrom: nLabeled((Node.MatchAny('key')), (Node.MatchAny('value')).setCommentsBefore(\" \")),\n\tto: nAssignment((Node.MatchDot(nAir(), 'key')).setCommentsAfter(\" \"), (Node.MatchAny('value')))\n};\nfunction BidirTransform(nd_root, is_forward) {\n\t//`type foo{};` as the default\n\tfor (let nd_ref of nd_root.FindAll(N_REF, null)) {\n\t\tif (!(nd_ref.flags & REF_DECLARED)) {continue;}\n\t\tif (nd_ref.p.node_class != N_RAW) {continue;}\n\t\tlet nd_stmt = nd_ref.ParentStatement();\n\t\tif (nd_stmt.node_class != N_SEMICOLON || nd_stmt.c != nd_ref.p) {continue;}\n\t\tlet nd_owner = nd_stmt.Owner();\n\t\tif (nd_owner.node_class == N_CLASS && nd_owner.data == 'union') {continue;}\n\t\tif (is_forward) {\n\t\t\tif (!nd_ref.s && !nd_stmt.Find(N_REF, 'extern') && !nd_stmt.Find(N_REF, 'struct') && !nd_stmt.Find(N_REF, 'class')) {\n\t\t\t\tnd_ref.Insert(POS_AFTER, nScope());\n\t\t\t}\n\t\t} else {\n\t\t\tif (nd_ref.s && nd_ref.s.node_class == N_SCOPE && !nd_ref.s.c) {nd_ref.s.Unlink();}\n\t\t}\n\t}\n\tfor (let nd_scope of nd_root.FindAll(N_SCOPE, null)) {\n\t\t//`type{foo:bar}` <=> `type{.foo=bar}`\n\t\tif (!nd_scope.c) {continue;}\n\t\tif (!(nd_scope.p.node_class == N_RAW && nd_scope.Prev() && isTypeLike(nd_scope.Prev()))) {continue;}\n\t\t//no ;\n\t\tif (nd_scope.Find(N_SEMICOLON, null)) {continue;}\n\t\tif (!is_forward) {\n\t\t\t//console.log(nd_scope.toSource());\n\t\t\tlet nd_type_provider = nd_scope.Prev();\n\t\t\tlet all_properties = undefined;\n\t\t\t//name the unnamed initializers\n\t\t\tlet current_field_id = 0;\n\t\t\tfor (let ndi = nd_scope.c; ndi; ndi = ndi.s) {\n\t\t\t\tif (ndi.isSymbol(',')) {continue;}\n\t\t\t\tif (ndi.node_class != N_ASSIGNMENT) {\n\t\t\t\t\t//name it\n\t\t\t\t\tif (!all_properties) {\n\t\t\t\t\t\tif (!typing) {\n\t\t\t\t\t\t\ttyping = require('cpp/typing');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet type = typing.TryGettingClass(typing.ComputeType(nd_type_provider));\n\t\t\t\t\t\tif (type && type.node_class == N_CLASS) {\n\t\t\t\t\t\t\tall_properties = type.ParseClass().properties.filter(ppt => ppt.enumerable);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tall_properties = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (current_field_id < all_properties.length) {\n\t\t\t\t\t\tlet name = all_properties[current_field_id++].name;\n\t\t\t\t\t\t//console.log(current_field_id,name)\n\t\t\t\t\t\tlet nd_tmp = Node.GetPlaceHolder();\n\t\t\t\t\t\tndi.ReplaceWith(nd_tmp);\n\t\t\t\t\t\tndi = nd_tmp.ReplaceWith(nLabeled(nRef(name), ndi));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnd_scope.TranslateTemplates([g_obj_init_transform], is_forward);\n\t}\n\treturn nd_root;\n}\n\n/*\n#filter Zero-initialize otherwise-uninitialized C++ variables\nBefore:\n```C++\nstruct CFoo{\n\tint m_foo;\n};\nint g_foo;\nint main(){\n\tint foo;\n\treturn 0;\n}\n```\n*/\nfunction Translate(nd_root) {\n\treturn BidirTransform(nd_root, 1);\n}\n\nfunction Untranslate(nd_root) {\n\treturn BidirTransform(nd_root, 0);\n}\n\nTranslate.inverse = Untranslate;\nmodule.exports = Translate;\n",
		"cpp/sane_types", "'use strict';\nlet g_templates = {\n\tarray: {from: nItem((Node.MatchAny('TElement'))), to: nCallTemplate(nDot(\"vector\", nRef(\"std\")).setFlags(2), (Node.MatchAny('TElement')))},\n\tview: {from: nItem((Node.MatchAny('TElement')), nSymbol(\":\")), to: nCallTemplate(nDot(\"span\", nRef(\"std\")).setFlags(2), (Node.MatchAny('TElement')))},\n\tfixed_array: {from: nPostfix(nItem((Node.MatchAny('TElement')), (Node.MatchAny('size'))), '!'), to: nCallTemplate(nDot(\"array\", nRef(\"std\")).setFlags(2), (Node.MatchAny('TElement')), (Node.MatchAny('size')).setCommentsBefore(\" \"))},\n\tmap: {from: nCallTemplate(nRef(\"Map\"), (Node.MatchAny('TKey')), (Node.MatchAny('TValue')).setCommentsBefore(\" \")), to: nCallTemplate(nDot(\"unordered_map\", nRef(\"std\")).setFlags(2), (Node.MatchAny('TKey')), (Node.MatchAny('TValue')).setCommentsBefore(\" \"))},\n};\n\n/*\n#filter Mark `[]` as a type suffix, a required setup step for `require(\"sane_types\")`\nThe filter itself has no visible effect and must be used before `require(\"sane_types\")`.\n*/\nfunction FixArrayTypes(nd_root) {\n\tfor (let nd_mul of nd_root.FindAll(N_BINOP, '*')) {\n\t\t//[]\n\t\tif (nd_mul.c.s.isRawNode('[', ']')) {\n\t\t\tlet nd_subscripts = nd_mul.c.BreakSibling().c;\n\t\t\tlet nd_item = nItem(nPostfix(nd_mul.BreakChild(), '*'));\n\t\t\tif (nd_subscripts) {\n\t\t\t\tnd_item.Insert(POS_BACK, nd_subscripts);\n\t\t\t}\n\t\t\tnd_mul.ReplaceWith(nd_item);\n\t\t}\n\t}\n}\n\nfunction BidirTransform(nd_root, alt_templates, is_forward) {\n\tlet templates = g_templates;\n\tif (alt_templates) {\n\t\ttemplates = Object.create(g_templates)\n\t\tfor (let key in alt_templates) {\n\t\t\tif (typeof(alt_templates[key]) != 'object') {continue;}\n\t\t\tif (!(alt_templates[key].from instanceof Node && alt_templates[key].to instanceof Node)) {continue;}\n\t\t\ttemplates[key] = Object.create(templates[key] || null);\n\t\t\tfor (let key2 in alt_templates[key]) {\n\t\t\t\ttemplates[key][key2] = alt_templates[key][key2];\n\t\t\t}\n\t\t};\n\t}\n\tlet match_jobs = [];\n\tfor (let key in templates) {\n\t\tmatch_jobs.push(templates[key]);\n\t}\n\tif (is_forward) {\n\t\tFixArrayTypes(nd_root);\n\t}\n\treturn nd_root.TranslateTemplates(match_jobs, is_forward);\n};\n\n/*\n#filter Short names for C++ template types\nCorrespondence:\n- `foo[]` => `std::vector<foo>`\n- `foo[:]` => `std::span<foo>`\n- `foo[size]!` => `std::array<foo, size>`\n- `Map<foo, bar>` => `std::unordered_map<foo, bar>`\nBefore:\n```C++\nint main() {\n\tint[] a;\n\ta.push_back(10);\n\treturn 0;\n}\n```\n*/\nfunction Translate(nd_root, alt_templates) {\n\treturn BidirTransform(nd_root, alt_templates, 1);\n}\n\nfunction UntranslateSaneTypeNames(nd_root, alt_templates) {\n\treturn BidirTransform(nd_root, alt_templates, 0);\n}\n\nTranslate.inverse = UntranslateSaneTypeNames;\nTranslate.setup = function(code, options) {\n\toptions.postfix_operators = '! ' + options.postfix_operators;\n};\nmodule.exports = Translate;\nmodule.exports.FixArrayTypes = FixArrayTypes;\n",
		"cpp/short_types", "'use strict';\nlet g_templates = [\n\t{from: nRef('i8'), to: nRef('int8_t')},\n\t{from: nRef('i16'), to: nRef('int16_t')},\n\t{from: nRef('i32'), to: nRef('int32_t')},\n\t{from: nRef('i64'), to: nRef('int64_t')},\n\t{from: nRef('iptr'), to: nRef('intptr_t')},\n\t{from: nRef('u8'), to: nRef('uint8_t')},\n\t{from: nRef('u16'), to: nRef('uint16_t')},\n\t{from: nRef('u32'), to: nRef('uint32_t')},\n\t{from: nRef('u64'), to: nRef('uint64_t')},\n\t{from: nRef('uptr'), to: nRef('uintptr_t')},\n\t{from: nRef('f16'), to: nRef('__half')},\n\t{from: nRef('f32'), to: nRef('float')},\n\t{from: nRef('f64'), to: nRef('double')},\n]\n\nfunction BidirTransform(nd_root, alt_templates, is_forward) {\n\treturn nd_root.TranslateTemplates(g_templates, is_forward);\n};\n\n/*\n#filter Short numerical type names for C++\nBefore:\n```C++\nf32 powi(f32 a, u32 p){\n\treturn p == 0 ? 1.f : (p & 1 ? a : 1.f) * powi(a, p >> 1);\n}\niptr addr_powi = (iptr)(void*)powi;\n```\n*/\nfunction Translate(nd_root, alt_templates) {\n\treturn BidirTransform(nd_root, alt_templates, 1);\n}\n\nfunction Untranslate(nd_root, alt_templates) {\n\treturn BidirTransform(nd_root, alt_templates, 0);\n}\n\nTranslate.inverse = Untranslate;\nmodule.exports = Translate;\n",
		"cpp/to_ama", "const amacpp=require('cpp/amacpp');\nconst path=require('path');\nParseCurrentFile().then(amacpp.inverse).Save('.ama' + path.extname(__filename));\n//ignore the per-file script\nreturn;\n",
		"cpp/typing", "'use strict'\nconst depends = require('depends');\nconst classes = require('class');\nconst assert = require('assert');\nlet typing = module.exports;\n\ntyping.type_cache = new Map();\ntyping.def_cache = new Map();\n\ntyping.DropCache = function() {\n\ttyping.type_cache = new Map();\n\ttyping.def_cache = new Map();\n};\n\nfunction BasicType(name) {\n\tlet type = typing.type_cache.get(name);\n\tif (!type) {\n\t\ttype = nRef(name);\n\t\ttyping.type_cache.set(name, type);\n\t}\n\treturn type;\n}\n\ntyping.options = {\n\tstring_type: nPostfix(nRef('char'), '*'),\n\tregexp_type: nRef('RegExp'),\n\tbool_type: nRef('int'),\n\tnode_type: nPostfix(nDot(\"Node\", nRef(\"ama\").setFlags(5)).setFlags(2), '*'),\n\tnull_type: nPostfix(nRef('void'), '*'),\n\tnon_type_function_keywords: new Set([\n\t\t'private', 'public', 'protected',\n\t\t'final', 'const', 'constexpr',\n\t\t'static', 'virtual', 'override',\n\t\t'__attribute__', '__declspec', '__cdecl', '__stdcall', '__fastcall',\n\t\t'extern', 'function', 'inline', '__inline', 'def', 'fn'\n\t]),\n\tnon_type_postfixes: new Set(['++', '--']),\n\tnulls: new Set(['NULL', 'nullptr']),\n\tComputeNumberType: function(nd) {\n\t\tlet type = undefined;\n\t\tlet is_int = 1;\n\t\tlet n_L = 0;\n\t\tlet n_u = 0;\n\t\t//the code was C++\n\t\tfor (let i = 0; i < nd.data.length; i++) {\n\t\t\tlet ch = nd.data[i];\n\t\t\tif ( ch == 'p' || ch == 'P' || ch == '.' ) {\n\t\t\t\tis_int = 0;\n\t\t\t} else if ( ch == 'e' || ch == 'E' ) {\n\t\t\t\tif ( !nd.data.startsWith('0x') ) {\n\t\t\t\t\tis_int = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ch == 'L' ) {\n\t\t\t\tn_L += 1;\n\t\t\t}\n\t\t\tif ( ch == 'u' ) {\n\t\t\t\tn_u += 1;\n\t\t\t}\n\t\t}\n\t\tif ( is_int ) {\n\t\t\tif ( n_L >= 2 ) {\n\t\t\t\ttype = n_u ? BasicType('uint64_t') : BasicType('int64_t');\n\t\t\t} else if ( n_L == 1 ) {\n\t\t\t\ttype = n_u ? BasicType('uintptr_t') : BasicType('intptr_t');\n\t\t\t} else {\n\t\t\t\ttype = n_u ? BasicType('unsigned') : BasicType('int');\n\t\t\t}\n\t\t} else if ( nd.data.endsWith(\"f\") ) {\n\t\t\ttype = BasicType('float');\n\t\t} else {\n\t\t\ttype = BasicType('double');\n\t\t}\n\t\treturn type;\n\t}\n};\ntyping.rules = [];\n\nlet g_int_types = ['bool', 'char', 'int8_t', 'uint8_t', 'short', 'int16_t', 'uint16_t', 'int', 'long', 'unsigned', 'int32_t', 'uint32_t', 'int64_t', 'uint64_t'];\nlet g_float_types = ['__half', 'half', 'float', 'double'];\n\nfunction ComputeOperandTypePriority(type) {\n\tif (!type) {return 0;}\n\tif (type.node_class != N_REF) {return 255;}\n\tfor (let i = 0; i < g_int_types.length; i++) {\n\t\tif (g_int_types[i] == type.data) {\n\t\t\treturn 64 + i;\n\t\t}\n\t}\n\tfor (let i = 0; i < g_float_types.length; i++) {\n\t\tif (g_float_types[i] == type.data) {\n\t\t\treturn 128 + i;\n\t\t}\n\t}\n\treturn 192;\n}\n\ntyping.GetDefs = function(nd_scope) {\n\tlet defs = typing.def_cache.get(nd_scope);\n\tif (!defs) {\n\t\tdefs = new Map();\n\t\t//console.log('---')\n\t\tfor (let ndi = nd_scope; ndi; ndi = ndi.PreorderNext(nd_scope)) {\n\t\t\tif (ndi.node_class == N_SCOPE && ndi != nd_scope || ndi.node_class == N_PARAMETER_LIST) {\n\t\t\t\tndi = ndi.PreorderSkip();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ndi.node_class == N_REF && (ndi.flags & REF_DECLARED)) {\n\t\t\t\t//console.log(ndi.data)\n\t\t\t\tif (ndi.p.node_class == N_KEYWORD_STATEMENT && defs.get(ndi.data)) {\n\t\t\t\t\t//let non-forward declarations override forward ones\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdefs.set(ndi.data, ndi);\n\t\t\t}\n\t\t}\n\t\tif (nd_scope.p && (nd_scope.p.node_class == N_FUNCTION || nd_scope.p.node_class == N_PARAMETER_LIST)) {\n\t\t\tlet nd_paramlist = nd_scope.p.c;\n\t\t\tif (nd_scope.p.node_class == N_FUNCTION) {\n\t\t\t\tnd_paramlist = nd_paramlist.s;\n\t\t\t}\n\t\t\tif (nd_paramlist.node_class == N_PARAMETER_LIST) {\n\t\t\t\tfor (let ndi = nd_paramlist; ndi; ndi = ndi.PreorderNext(nd_paramlist)) {\n\t\t\t\t\tif (ndi.node_class == N_REF && (ndi.flags & REF_DECLARED)) {\n\t\t\t\t\t\t//console.log(ndi.data)\n\t\t\t\t\t\tdefs.set(ndi.data, ndi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttyping.def_cache.set(nd_scope, defs);\n\t}\n\treturn defs;\n};\n\ntyping.ListActiveScopes = function(nd_root) {\n\treturn depends.ListAllDependency(nd_root, true);\n};\n\n//only the type system cares about declarations, put it here\n//we are past auto_decl, we can focus on top-level names for N_REF\ntyping.LookupSymbol = function(nd_ref, want_all) {\n\t//cache defs in typing.type_cache: type cache gets invalidated by certain code changes anyway\n\tif (nd_ref.flags & REF_DECLARED) {\n\t\tif (want_all) {\n\t\t\treturn [nd_ref];\n\t\t} else {\n\t\t\treturn nd_ref;\n\t\t}\n\t}\n\tlet ret = [];\n\t//look up local scopes\n\tfor (let ndi = nd_ref; ndi; ndi = ndi.p) {\n\t\tif (ndi.node_class == N_SCOPE || ndi.node_class == N_FILE) {\n\t\t\tlet nd_def = typing.GetDefs(ndi).get(nd_ref.data);\n\t\t\tif (nd_def) {\n\t\t\t\tif (want_all) {\n\t\t\t\t\tret.push(nd_def);\n\t\t\t\t} else {\n\t\t\t\t\treturn nd_def;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//not found: we have to load dependencies\n\tfor (let nd_dep of typing.ListActiveScopes(nd_ref.Root())) {\n\t\tlet nd_def = typing.GetDefs(nd_dep).get(nd_ref.data);\n\t\tif (nd_def) {\n\t\t\tif (want_all) {\n\t\t\t\tret.push(nd_def);\n\t\t\t} else {\n\t\t\t\treturn nd_def;\n\t\t\t}\n\t\t}\n\t}\n\t//COULDDO: `using` handling\n\treturn want_all ? ret : undefined;\n};\n\ntyping.ComputeDeclaredType = function(nd_def) {\n\t//COULDDO: non-C++ forms of declaration\n\t//COULDDO: handle destructuring and other weird forms\n\tif (nd_def.p && nd_def.p.node_class == N_KEYWORD_STATEMENT && nd_def.p.c == nd_def) {\n\t\t//forward declaration: self-representing\n\t\treturn nd_def;\n\t}\n\tlet modifiers = [];\n\tlet type = undefined;\n\tlet nd_owner = nd_def.Owner();\n\tif (nd_owner && (nd_owner.node_class == N_CLASS && nd_owner.c.s.isAncestorOf(nd_def) ||\n\tnd_owner.node_class == N_FUNCTION && nd_owner.c.isAncestorOf(nd_def))) {\n\t\t//class / function\n\t\treturn nd_owner;\n\t}\n\tfor (let ndi = nd_def.p; ndi; ndi = ndi.p) {\n\t\tif (ndi.node_class == N_ITEM || ndi.node_class == N_PREFIX || ndi.node_class == N_POSTFIX) {\n\t\t\tmodifiers.push(ndi);\n\t\t} else if (ndi.node_class == N_RAW) {\n\t\t\t//just pick the last expr\n\t\t\tfor (let ndj = ndi.c; ndj; ndj = ndj.s) {\n\t\t\t\tif (ndj.isAncestorOf(nd_def)) {break;}\n\t\t\t\ttype = typing.ComputeType(ndj);\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (ndi.node_class == N_CLASS || ndi.node_class == N_FUNCTION) {\n\t\t\ttype = ndi;\n\t\t\tbreak;\n\t\t} else if (ndi.node_class == N_SEMICOLON || ndi.node_class == N_SCOPE) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (type && modifiers.length) {\n\t\t//C-style modifiers\n\t\t//COULDDO: we could have gotten the priorities wrong\n\t\ttype = type.Clone();\n\t\twhile (modifiers.length) {\n\t\t\tlet nd_modifier = modifiers.pop();\n\t\t\tif (nd_modifier.node_class == N_ITEM) {\n\t\t\t\tlet type_new = nd_modifier.Clone();\n\t\t\t\ttype_new.c.ReplaceWith(type);\n\t\t\t\ttype = type_new;\n\t\t\t} else if (nd_modifier.node_class == N_PREFIX) {\n\t\t\t\ttype = nPrefix(nd_modifier.data, type);\n\t\t\t} else if (nd_modifier.node_class == N_POSTFIX) {\n\t\t\t\ttype = nPostfix(type, nd_modifier.data);\n\t\t\t}\n\t\t}\n\t}\n\treturn type;\n};\n\nfunction isNamespace(nd_class) {\n\tfor (let ndi = nd_class; ndi; ndi = ndi.p) {\n\t\tif (ndi.node_class == N_FUNCTION) {return 0;}\n\t\tif (ndi.node_class == N_CLASS && ndi.data != 'namespace') {return 0;}\n\t}\n\treturn 1;\n}\n\ntyping.LookupClassesByNames = function(nd_root, names, options) {\n\tlet all_scopes = [];\n\tfor (let nd_dep of options.include_dependency ? depends.ListAllDependency(nd_root, true) : [nd_root]) {\n\t\tlet scopes = [nd_dep];\n\t\tfor (let i = names.length - 1; i >= 0; i--) {\n\t\t\tlet new_scopes = [];\n\t\t\tfor (let nd_scope of scopes) {\n\t\t\t\tfor (let nd_class of nd_scope.FindAllWithin(BOUNDARY_FUNCTION | BOUNDARY_CLASS, N_CLASS, names[i])) {\n\t\t\t\t\tif ((!options.must_be || nd_class.data == options.must_be) && nd_class.LastChild().node_class == N_SCOPE) {\n\t\t\t\t\t\tnew_scopes.push(nd_class.LastChild());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tscopes = new_scopes;\n\t\t\tif (!scopes.length) {break;}\n\t\t}\n\t\tfor (let nd_scope of scopes) {\n\t\t\tall_scopes.push(nd_scope);\n\t\t}\n\t}\n\treturn all_scopes;\n};\n\n///returns a binding of all template parameters\ntyping.MatchTemplateType = function(type_in, type_template, names) {\n\tlet is_param = new Set(names);\n\tlet nd_pattern = type_template.Clone();\n\tfor (let ndi = nd_pattern; ndi; ndi = ndi.PreorderNext(nd_pattern)) {\n\t\tif (ndi.node_class == N_REF && is_param.has(ndi.data)) {\n\t\t\tlet was_pattern = (nd_pattern == ndi);\n\t\t\tndi = ndi.ReplaceWith(Node.MatchAny(ndi.data));\n\t\t\tif (was_pattern) {\n\t\t\t\tnd_pattern = ndi;\n\t\t\t}\n\t\t\tndi = ndi.PreorderSkip();\n\t\t}\n\t}\n\treturn type_in.Match(nd_pattern);\n};\n\ntyping.ComputeReturnType = function(type_func) {\n\tlet type = undefined;\n\tlet nd_after = type_func.c.s.s;\n\tlet nd_before = type_func.c;\n\tif (nd_after.node_class == N_LABELED && nd_after.c.node_class == N_AIR) {\n\t\t//air :, a natural extension of the JS syntax, function():foo{}\n\t\ttype = typing.ComputeType(nd_after.c.s);\n\t} else if (nd_after.node_class == N_RAW && nd_after.c && nd_after.c.isSymbol('->') && nd_after.c.s) {\n\t\t//air ->, C++ lambda return type\n\t\ttype = typing.ComputeType(nd_after.c.s);\n\t} else if (nd_before.node_class == N_RAW) {\n\t\t//we could have `static __attribute__(foo) void __attribute__(bar) __cdecl f`\n\t\t//go back to front and filter out the calling conventions\n\t\tfor (let ndi = nd_before.LastChild(); ndi; ndi = ndi.Prev()) {\n\t\t\tif (ndi.node_class == N_REF && typing.options.non_type_function_keywords.has(ndi.data)) {\n\t\t\t\tif (type) {break;} else {continue;}\n\t\t\t}\n\t\t\tif (ndi.node_class == N_CALL && ndi.c.node_class == N_REF && ndi.node_class == N_CALL && ndi.c.node_class == N_REF && typing.options.non_type_function_keywords.has(ndi.c.data)) {\n\t\t\t\tif (type) {break;} else {continue;}\n\t\t\t}\n\t\t\ttype = ndi;\n\t\t\tif (type.node_class != N_REF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn type;\n};\n\ntyping.LookupDottedName = function(nd_site, name, nd_class) {\n\tlet nd_def = undefined;\n\tif (nd_class) {\n\t\t//base class: should use ParseClass\n\t\t//nd_def = typing.GetDefs(nd_class.LastChild()).get(name);\n\t\tlet class_defs = typing.def_cache.get(nd_class);\n\t\tif (!class_defs) {\n\t\t\tclass_defs = new Map();\n\t\t\ttyping.def_cache.set(nd_class, class_defs);\n\t\t\tlet desc = nd_class.ParseClass();\n\t\t\tfor (let ppt of desc.properties) {\n\t\t\t\tlet nd_def = ppt.node;\n\t\t\t\tif (!nd_def) {continue;}\n\t\t\t\tif (nd_def.node_class == N_CLASS) {\n\t\t\t\t\tnd_def = nd_def.c.s;\n\t\t\t\t} else if (nd_def.node_class == N_FUNCTION) {\n\t\t\t\t\tlet nd_func = nd_def;\n\t\t\t\t\tnd_def = undefined;\n\t\t\t\t\tfor (let ndi = nd_func; ndi; ndi = ndi.PreorderNext(nd_func)) {\n\t\t\t\t\t\tif (ndi.node_class == N_SCOPE || ndi.node_class == N_PARAMETER_LIST) {\n\t\t\t\t\t\t\tndi = ndi.PreorderSkip();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ndi.node_class == N_REF && (ndi.flags & REF_DECLARED)) {\n\t\t\t\t\t\t\tnd_def = ndi;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nd_def && nd_def.node_class == N_REF && (nd_def.flags & REF_DECLARED)) {\n\t\t\t\t\tclass_defs.set(ppt.name, nd_def);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnd_def = class_defs.get(name);\n\t}\n\tif (!nd_def && isNamespace(nd_class)) {\n\t\t//it got ugly: we need to search ALL same-named namespaces\n\t\t//don't merge namespaces internally: each file \"sees\" a different version of the same namespace\n\t\tlet names = [];\n\t\tfor (let ndi = nd_class; ndi; ndi = ndi.p) {\n\t\t\tif (ndi.node_class == N_CLASS) {names.push(ndi.GetName());}\n\t\t}\n\t\tfor (let nd_scope of typing.LookupClassesByNames(nd_site.Root(), names, {must_be: 'namespace',include_dependency: 1})) {\n\t\t\tnd_def = typing.GetDefs(nd_scope).get(name);\n\t\t\tif (nd_def) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn nd_def;\n};\n\ntyping.TryGettingClass = function(type_obj) {\n\tif (type_obj && type_obj.node_class == N_POSTFIX && type_obj.data == '*') {\n\t\ttype_obj = typing.ComputeType(type_obj.c);\n\t} else if (type_obj && type_obj.node_class == N_CALL_TEMPLATE && (type_obj.GetName() == 'unique_ptr' || type_obj.GetName() == 'shared_ptr') && type_obj.c.s) {\n\t\ttype_obj = typing.ComputeType(type_obj.c.s);\n\t}\n\t//we could enter an infinite loop here for:\n\t//`const Multilib &Multilib;`\n\tlet dedup = new Set();while (type_obj && !dedup.has(type_obj) && type_obj.node_class == N_POSTFIX && (type_obj.data == '&' || type_obj.data == 'const' || type_obj.data == 'volatile')) {\n\t\tdedup.add(type_obj);\n\t\ttype_obj = typing.ComputeType(type_obj.c);\n\t}\n\twhile (type_obj && !dedup.has(type_obj) && type_obj.node_class == N_CALL_TEMPLATE) {\n\t\tdedup.add(type_obj);\n\t\ttype_obj = typing.ComputeType(type_obj.c);\n\t}\n\treturn type_obj;\n};\n\ntyping.PointerType = function(type) {\n\tif (!type) {return type;}\n\treturn nPostfix(typing.AccessTypeAt(type, type), '*');\n};\n\ntyping.ComputeType = function(nd_expr) {\n\tlet type = typing.type_cache.get(nd_expr);\n\tif (type) {return type;}\n\tfor (let i = typing.rules.length - 1; i >= 0; i--) {\n\t\ttype = typing.rules[i](nd_expr);\n\t\tif (type) {\n\t\t\ttyping.type_cache.set(nd_expr, type);\n\t\t\treturn type;\n\t\t}\n\t}\n\t//avoid infinite recursion\n\ttyping.type_cache.set(nd_expr, nd_expr);\n\tswitch (nd_expr.node_class) {\n\tcase N_RAW: {\n\t\t//QoL: return declared type on parent N_RAW\n\t\tfor (let ndi = nd_expr.c; ndi; ndi = ndi.s) {\n\t\t\tif (ndi.node_class == N_REF && (ndi.flags & REF_DECLARED)) {\n\t\t\t\ttype = typing.ComputeDeclaredType(ndi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase N_SYMBOL:\n\tcase N_AIR: {\n\t\t//we don't really understand these, so we can't compute a type\n\t\t//and it's not worth caching\n\t\ttype = undefined;\n\t\tbreak;\n\t}\n\tcase N_FILE:\n\tcase N_SCOPE:\n\tcase N_SCOPED_STATEMENT:\n\tcase N_EXTENSION_CLAUSE:\n\tcase N_KEYWORD_STATEMENT:\n\tcase N_PARAMETER_LIST:\n\tcase N_CALL_CUDA_KERNEL:\n\tcase N_LABELED:\n\tcase N_SEMICOLON:\n\tcase N_DEPENDENCY: {\n\t\t//don't have a type in C++, but could generalize a bit to return something\n\t\t//COULDDO: generalize\n\t\ttype = undefined;\n\t\tbreak;\n\t}\n\tcase N_FUNCTION:\n\tcase N_CLASS: {\n\t\t//they are self-representing, don't cache\n\t\ttype = nd_expr;\n\t\tbreak;\n\t}\n\tcase N_PAREN: {\n\t\ttype = typing.ComputeType(nd_expr.c);\n\t\tbreak;\n\t}\n\tcase N_STRING: {\n\t\ttype = typing.options.string_type;\n\t\tbreak;\n\t}\n\tcase N_JS_REGEXP: {\n\t\ttype = typing.options.regexp_type;\n\t\tbreak;\n\t}\n\tcase N_NODEOF: {\n\t\ttype = typing.options.node_type;\n\t\tbreak;\n\t}\n\tcase N_NUMBER: {\n\t\ttype = typing.options.ComputeNumberType(nd_expr);\n\t\tbreak;\n\t}\n\tcase N_POSTFIX: {\n\t\tif (typing.options.non_type_postfixes.has(nd_expr.data)) {\n\t\t\t//COULDDO: try to find overloaded operators\n\t\t\t//here we cheat and return the operand\n\t\t\ttype = typing.ComputeType(nd_expr.c);\n\t\t\tbreak;\n\t\t} else {\n\t\t\t//we are self-representative\n\t\t\ttype = nd_expr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcase N_PREFIX: {\n\t\t//COULDDO: try to find overloaded operators\n\t\t//here we cheat and return the operand\n\t\ttype = typing.ComputeType(nd_expr.c);\n\t\tif (nd_expr.data == '&') {\n\t\t\ttype = typing.PointerType(type);\n\t\t}\n\t\tbreak;\n\t}\n\tcase N_CONDITIONAL:\n\tcase N_BINOP: {\n\t\tif (nd_expr.data == '||' || nd_expr.data == '&&') {\n\t\t\tif (typing.options.bool_type) {\n\t\t\t\ttype = typing.options.bool_type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//COULDDO: try to find overloaded operators\n\t\t//here we cheat and return one of the operands\n\t\tlet nd_a = nd_expr.node_class == N_CONDITIONAL ? nd_expr.c.s : nd_expr.c;\n\t\tlet type_a = typing.ComputeType(nd_a);\n\t\tlet type_b = typing.ComputeType(nd_a.s);\n\t\ttype = ComputeOperandTypePriority(type_b) > ComputeOperandTypePriority(type_a) ? type_b : type_a;\n\t\tbreak;\n\t}\n\tcase N_ASSIGNMENT: {\n\t\ttype = typing.ComputeType(nd_expr.c);\n\t\tbreak;\n\t}\n\tcase N_REF: {\n\t\t//find the declaration\n\t\tif (nd_expr.data == 'this') {\n\t\t\tlet nd_owner = nd_expr.Owner();\n\t\t\tif (nd_owner.node_class == N_FUNCTION) {\n\t\t\t\tlet nd_name = nd_owner.GetFunctionNameNode();\n\t\t\t\tif (nd_name && nd_name.node_class == N_DOT) {\n\t\t\t\t\ttype = typing.ComputeType(nd_name.c);\n\t\t\t\t} else {\n\t\t\t\t\tlet nd_owner_owner = nd_owner.Owner();\n\t\t\t\t\tif (nd_owner_owner.node_class == N_CLASS && nd_owner_owner.data != 'namespace') {\n\t\t\t\t\t\ttype = nd_owner_owner;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type) {\n\t\t\t\ttype = typing.PointerType(type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlet all_defs = typing.LookupSymbol(nd_expr, true);\n\t\tfor (let nd_def of all_defs) {\n\t\t\tlet type_def = typing.ComputeDeclaredType(nd_def);\n\t\t\tif (!type_def) {continue;}\n\t\t\t//try to find a non-self-representing def\n\t\t\ttype = type_def;\n\t\t\tif (type != nd_def) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!type) {\n\t\t\t//assume self-representing\n\t\t\tif (typing.options.nulls.has(nd_expr.data)) {\n\t\t\t\ttype = typing.null_type;\n\t\t\t} else {\n\t\t\t\ttype = nd_expr;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase N_DOT: {\n\t\t//try to look up the \"primary\" type first\n\t\t//COULDDO: substitute template parameters\n\t\tlet type_obj = typing.TryGettingClass(typing.ComputeType(nd_expr.c));\n\t\tif (type_obj && type_obj.node_class == N_CLASS) {\n\t\t\tlet nd_def = typing.LookupDottedName(nd_expr, nd_expr.data, type_obj);\n\t\t\tif (nd_def) {\n\t\t\t\ttype = typing.ComputeDeclaredType(nd_def);\n\t\t\t}\n\t\t}\n\t\t//assume self-representing type name when we fail to find the def\n\t\tif (!type && nd_expr.flags == DOT_CLASS) {\n\t\t\ttype = nd_expr;\n\t\t}\n\t\tbreak;\n\t}\n\tcase N_CALL: {\n\t\t//COULDDO: substitute template parameters\n\t\t//COULDDO: try to resolve overloading\n\t\tlet type_func = typing.ComputeType(nd_expr.c);\n\t\twhile (type_func && type_func.node_class == N_CALL_TEMPLATE) {\n\t\t\ttype_func = typing.ComputeType(type_func.c);\n\t\t}\n\t\tif (type_func && type_func.node_class == N_FUNCTION) {\n\t\t\ttype = typing.ComputeReturnType(type_func);\n\t\t}\n\t\tbreak;\n\t}\n\tcase N_CALL_TEMPLATE: {\n\t\tlet type_template = typing.ComputeType(nd_expr.c);\n\t\tif (type_template && type_template.node_class == N_FUNCTION) {\n\t\t\t//we are just a function, let the outer call worry about the return type\n\t\t\ttype = type_template;\n\t\t} else {\n\t\t\t//we are self-representing\n\t\t\ttype = nd_expr;\n\t\t}\n\t\tbreak;\n\t}\n\tcase N_ITEM: {\n\t\tif (!nd_expr.c.s || nd_expr.c.s.node_class == N_SYMBOL) {\n\t\t\t//self-representing array type\n\t\t\ttype = nd_expr;\n\t\t\tbreak;\n\t\t}\n\t\t//we should do this before sane_types: we want the untranslated *sane* types\n\t\tlet type_obj = typing.ComputeType(nd_expr.c);\n\t\t//recognize array and pointer\n\t\tif (type_obj) {\n\t\t\tif (type_obj.node_class == N_ITEM) {\n\t\t\t\ttype = type_obj.c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (type_obj.node_class == N_PREFIX && type_obj.data == '*') {\n\t\t\t\ttype = type_obj.c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (type_obj.node_class == N_CALL_TEMPLATE && type_obj.GetName() == 'vector' && type_obj.c.s) {\n\t\t\t\ttype = typing.ComputeType(type_obj.c.s);\n\t\t\t}\n\t\t}\n\t\t//recognize other hard-coded templates in hooks: don't put them here\n\t\tbreak;  \n\t}\n\t}\n\ttyping.type_cache.set(nd_expr, type);\n\t//console.log(nd_expr.toSource(), type);\n\treturn type;\n};\n\ntyping.AccessTypeAt = function(type, nd_site) {\n\tif (type.node_class == N_CLASS) {\n\t\tlet names = [];\n\t\tfor (let ndi = type; ndi; ndi = ndi.p) {\n\t\t\tif (ndi.node_class == N_CLASS) {\n\t\t\t\tnames.push(ndi.GetName());\n\t\t\t}\n\t\t}\n\t\tlet ret = nRef(names.pop());\n\t\twhile (names.length) {\n\t\t\tret = ret.dot(names.pop()).setFlags(DOT_CLASS);\n\t\t}\n\t\ttyping.type_cache.set(ret, type);\n\t\treturn ret;\n\t} else if (type.node_class == N_CALL_TEMPLATE) {\n\t\tlet ret = type.Clone();\n\t\tret.c.ReplaceWith(typing.AccessTypeAt(ret.c, nd_site));\n\t\ttyping.type_cache.set(ret, type);\n\t\treturn ret;\n\t}\n\t//COULDDO: N_REF case\n\tlet ret = type.Clone();\n\ttyping.type_cache.set(ret, type);\n\treturn ret.setCommentsBefore('').setCommentsAfter('');\n};\n\ntyping.DeduceAutoTypedDef = function(nd_def) {\n\tassert(nd_def.flags & REF_DECLARED);\n\tlet nd_scope = nd_def.Owning(N_SCOPE) || nd_def.Root();\n\tlet nd_owner = nd_def.Owner();\n\t//don't deduce fields\n\t//find all its assignments\n\tlet type_template = typing.ComputeDeclaredType(nd_def);\n\tlet nd_auto = type_template && type_template.Find(N_REF, 'auto');\n\tif (!nd_auto) {return;}\n\tlet has_null = 0;\n\tlet cands = [];\n\tfor (let nd_ref of nd_scope.FindAll(N_REF, nd_def.data)) {\n\t\tif (typing.LookupSymbol(nd_ref) != nd_def) {continue;}\n\t\tlet nd_stmt = nd_ref.ParentStatement();\n\t\twhile (nd_stmt.node_class == N_SEMICOLON) {\n\t\t\tnd_stmt = nd_stmt.c;\n\t\t}\n\t\tif (nd_stmt.node_class == N_ASSIGNMENT && nd_stmt.c.isAncestorOf(nd_ref)) {\n\t\t\tlet nd_value = nd_stmt.c.s;\n\t\t\tif (nd_value.node_class == N_REF && typing.options.nulls.has(nd_value.data)) {\n\t\t\t\thas_null = 1;\n\t\t\t} else {\n\t\t\t\tlet type_value = typing.ComputeType(nd_value);\n\t\t\t\tif (type_value) {\n\t\t\t\t\tlet match = typing.MatchTemplateType(type_value, type_template, ['auto']);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tcands.push(match.auto);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (has_null && !cands.length) {\n\t\tlet match = typing.MatchTemplateType(typing.options.null_type, type_template, ['auto']);\n\t\tif (match) {\n\t\t\tcands.push(match.auto);\n\t\t}\n\t}\n\tif (cands.length > 0) {\n\t\t//try promoting\n\t\tlet type = cands[0];\n\t\tlet best = ComputeOperandTypePriority(type);\n\t\tfor (let i = 1; i < cands.length; i++) {\n\t\t\tlet score = ComputeOperandTypePriority(cands[i]);\n\t\t\tif (best < score) {\n\t\t\t\tbest = score;\n\t\t\t\ttype = cands[i];\n\t\t\t}\n\t\t}\n\t\tnd_auto.ReplaceWith(typing.AccessTypeAt(type, nd_auto));\n\t}\n};\n\n/*\n#filter Replace C++ `auto` with the deduced type whenever possible\nThis filter is intended for source feedback, i.e., save the deduction result to a file later.\nThe deduction is backed by ama's simple typing engine so the result may not be available or correct.\n*/\ntyping.DeduceAuto = function(nd_root) {\n\tfor (let nd_def of nd_root.FindAll(N_REF, null)) {\n\t\tif (!(nd_def.flags & REF_DECLARED) || nd_def.data == 'auto') {continue;}\n\t\tif (!(nd_def.p && nd_def.p.node_class == N_RAW && nd_def.p.Find(N_REF, 'auto'))) {continue;}\n\t\ttyping.DeduceAutoTypedDef(nd_def);\n\t}\n\ttyping.DropCache();\n};\n",
		"cpp/unified_null", "'use strict';\n\nfunction BidirTransform(nd_root, is_forward) {\n\tif (is_forward) {\n\t\tfor (let nd of nd_root.FindAll(N_REF, 'NULL')) {\n\t\t\tnd.data = 'nullptr';\n\t\t}\n\t} else {\n\t\tfor (let nd of nd_root.FindAll(N_REF, 'nullptr')) {\n\t\t\tnd.data = 'NULL';\n\t\t}\n\t}\n\treturn nd_root;\n}\n\n/*\n#filter Use `NULL` for `nullptr`\nBefore:\n```C++\nvoid* g_ptr = NULL;\n```\n*/\nfunction Translate(nd_root) {\n\treturn BidirTransform(nd_root, 1);\n}\n\nfunction Untranslate(nd_root) {\n\treturn BidirTransform(nd_root, 0);\n}\n\nTranslate.inverse = Untranslate;\nmodule.exports = Translate;\n",
		"depends", "'use strict';\nconst fs = require('fs');\nconst path = require('path');\nconst assert = require('assert');\nlet depends = module.exports;\n\ndepends.oracle = function nullOracle(name, referrer) {\n\treturn /*full path or undefined*/;\n};\ndepends.c_include_paths = (process.env.INCLUDE || '').split(process.platform == 'win32' ? ';' : ':').filter(s => s);\n\ndepends.Resolve = function(nd) {\n\tassert(nd.node_class == N_DEPENDENCY);\n\tif ((nd.flags & DEP_TYPE_MASK) == DEP_C_INCLUDE) {\n\t\tlet fn = nd.c.GetStringValue();\n\t\tif (nd.flags & DEPF_C_INCLUDE_NONSTR) {\n\t\t\tfn = fn.replace(new RegExp('[<>]', 'g'), '');\n\t\t}\n\t\tif (!(nd.flags & DEPF_C_INCLUDE_NONSTR)) {\n\t\t\tlet fn_test = path.resolve(path.dirname(nd.Root().data), fn);\n\t\t\tif (fs.existsSync(fn_test)) {\n\t\t\t\treturn fn_test;\n\t\t\t}\n\t\t}\n\t\tfor (let dir of depends.c_include_paths) {\n\t\t\tlet fn_test = path.resolve(dir, fn);\n\t\t\tif (fs.existsSync(fn_test)) {\n\t\t\t\treturn fn_test;\n\t\t\t}\n\t\t}\n\t\treturn depends.oracle(fn, nd.Root().data);\n\t} else if ((nd.flags & DEP_TYPE_MASK) == DEP_JS_REQUIRE) {\n\t\t//reuse the builtin searcher __ResolveJSRequire\n\t\tif (nd.c && nd.c.node_class == N_STRING) {\n\t\t\treturn __ResolveJSRequire(__filename, nd.c.GetStringValue()) || depends.oracle(nd.c.GetStringValue(), nd.Root().data);\n\t\t}\n\t}\n\treturn undefined;\n};\n\ndepends.cache = new Map();\n\ndepends.LoadFile = function(fn, options) {\n\tfn = __path_toAbsolute(fn);\n\tlet nd_cached = depends.cache.get(fn);\n\tif (!nd_cached) {\n\t\tlet data = null;\n\t\ttry {\n\t\t\tdata = fs.readFileSync(fn);\n\t\t} catch (err) {\n\t\t\t//do nothing\n\t\t};\n\t\tif (!data) {return undefined;}\n\t\tnd_cached = ParseCode(data, options || __global.GetPipelineFromFilename(fn));\n\t\tnd_cached.data = fn;\n\t\tdepends.cache.set(fn, nd_cached);\n\t}\n\treturn nd_cached;\n};\n\nlet nd_add_template = nKeywordStatement(\"#pragma\", nCall(nRef(\"add\"), (Node.MatchAny(N_STRING, 'kind')), (Node.MatchAny(N_STRING, 'name')).setCommentsBefore(\" \")).setCommentsBefore(\" \"));\ndepends.dependency_cache = [new Map(), new Map()];\ndepends.ListAllDependency = function(nd_root, include_system_headers) {\n\tlet cache = depends.dependency_cache[0 | !!include_system_headers];\n\tif (cache.get(nd_root)) {\n\t\treturn cache.get(nd_root);\n\t}\n\tlet ret = new Set();\n\tlet Q = [nd_root];\n\tfor (let qi = 0; qi < Q.length; qi++) {\n\t\tlet nd_root = Q[qi];\n\t\tfor (let ndi of nd_root.FindAll(N_DEPENDENCY, null)) {\n\t\t\tif (!include_system_headers && (ndi.flags & DEP_TYPE_MASK) == DEP_C_INCLUDE && ( ndi.flags & DEPF_C_INCLUDE_NONSTR )) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet fn_dep = depends.Resolve(ndi);\n\t\t\tif (fn_dep && !ret.has(fn_dep)) {\n\t\t\t\tret.add(fn_dep);\n\t\t\t\tlet nd_root_dep = depends.LoadFile(fn_dep);\n\t\t\t\tif (nd_root_dep) {\n\t\t\t\t\tQ.push(nd_root_dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let match of nd_root.MatchAll(nd_add_template)) {\n\t\t\tif (!match.kind.GetStringValue().endsWith('_files')) {continue;}\n\t\t\tlet fn_dep = path.resolve(path.dirname(nd_root.data), match.name.GetStringValue());\n\t\t\tif (fs.existsSync(fn_dep) ) {\n\t\t\t\tif (!ret.has(fn_dep)) {\n\t\t\t\t\tret.add(fn_dep);\n\t\t\t\t\tlet ext = path.extname(fn_dep);\n\t\t\t\t\tif (ext != '.a' && ext != '.so' && ext != '.dll') {\n\t\t\t\t\t\tlet nd_root_dep = depends.LoadFile(fn_dep);\n\t\t\t\t\t\tif (nd_root_dep) {\n\t\t\t\t\t\t\tQ.push(nd_root_dep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error('unable to find', fn_dep);\n\t\t\t}\n\t\t}\n\t}\n\t//let qret = Q.map(ndi=>__path_toAbsolute(ndi.data));\n\tcache.set(nd_root, Q);\n\treturn Q;\n};\n\ndepends.ListLoadedFiles = function() {\n\tlet ret = [];\n\tfor (let name in __require_cache) {\n\t\tret.push(path.resolve(name));\n\t}\n\tdepends.cache.forEach((nd_root, name) => {\n\t\tret.push(path.resolve(name));\n\t});\n\treturn ret;\n};\n\ndepends.DropCache = function() {\n\tdepends.cache = new Map();\n\tdepends.dependency_cache = [new Map(), new Map()];\n};\n",
		"dump_ast", "'use strict';\n\n/*\n#filter Dump the AST (Abstract Syntax Tree).\n*/\nfunction Translate(nd_root) {\n\tconsole.log(JSON.stringify(nd_root, null, 1));\n}\n\nmodule.exports = Translate;\n",
		"fs", "//Node.js-compatible file system module.\n//\n//Provided methods:\n//- `fs.readFileSync(path)`\n//- `fs.existsSync(path)`\n//- `fs.writeFileSync(path, data)`\n//- `fs.statSync(path)`\n//- `fs.readdirSync(dir,{withFileTypes:true})`\n'use strict'\n//DO NOT use ama features: this is a \"chicken\" file which gets called when formatting other JS files\nlet fs = module.exports;\n\nlet Buffer = {\n\ttoString:__buffer_toString\n};\nBuffer.__proto__ = ArrayBuffer;\n\nfs.readFileSync = function(fn) {\n\tlet ret = __readFileSync(fn);\n\tif (ret) {\n\t\tret.__proto__ = Buffer;\n\t}\n\treturn ret;\n}\nfs.existsSync = __existsSync;\nfs.writeFileSync = __writeFileSync;\nfs.statSync = __statSync;\n\nfs.Dirent=function(item){\n\tObject.assign(this,item);\n}\n\nfs.Dirent.prototype.isDirectory=function(){return this.is_dir;}\nfs.Dirent.prototype.isFile=function(){return this.is_file;}\n\nfs.readdirSync=function(dir,options){\n\tif(!options||options.withFileTypes!==true){\n\t\tthrow new Error('{withFileTypes:true} is mandatory');\n\t}\n\treturn JSON.parse(__readdirSync(dir)).map(item=>new fs.Dirent(item));\n}\n",
		"fsext", "//Extra file system utility.\n//\n//Provided methods:\n//- `fsext.FindAllFiles(dir)`: recursively find files in dir and return an array of absolute paths\n//- `fsext.SyncTimestamp(fn_src, fn_tar)`: make the timestamps of `fn_src` and `fn_tar` identical\n'use strict'\n//DO NOT use ama features: this is a \"chicken\" file which gets called when formatting other JS files\nlet fsext = module.exports;\nconst fs=require('fs');\nconst path=require('path');\n\nfunction RecursiveFileSearch(ret,dir){\n\tfor(let ent of fs.readdirSync(dir,{withFileTypes:true})){\n\t\tif(ent.name==='.'||ent.name==='..'){continue;}\n\t\tent.name=path.join(dir,ent.name);\n\t\tif(ent.isFile()){\n\t\t\tret.push(ent.name);\n\t\t}else if(ent.isDirectory()){\n\t\t\tRecursiveFileSearch(ret,ent.name);\n\t\t}\n\t}\n\treturn ret;\n}\n\nfsext.FindAllFiles=function(dir){\n\treturn RecursiveFileSearch([],dir);\n}\n\n//bidirectional synchronization will only stop when the timestamps are exactly equal\n//so we need SyncTimestamp to achieve that\nfsext.SyncTimestamp=function(fn_src,fn_tar){\n\t__global.__SyncTimestamp(fn_src,fn_tar);\n}\n",
		"omnichecker", "//work in progress\n'use strict';\nlet omnichecker = module.exports;\nconst assert = require('assert');\nconst ParseCFor = require('cpp/c_for');\n\nfunction FindDef(nd_defroot) {\n\tfor (let ndj = nd_defroot; ndj; ndj = ndj.PreorderNext(nd_defroot)) {\n\t\tif (ndj.node_class == N_REF && (ndj.flags & REF_DECLARED)) {\n\t\t\treturn ndj;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nomnichecker.CreateTestingCode = function CreateTestingCode(nd_root, options) {\n\tif (!options) {\n\t\toptions = {};\n\t}\n\toptions = Object.assign(Object.create({\n\t\tlanguage: 'js',\n\t\ttemplates: [],\n\t\tproperties: [],\n\t\tdestructors: [],\n\t\tenable_warnings: 1,\n\t\tenable_shim: 1,\n\t}), options);\n\tassert(options.language == 'js');\n\t//setup a default property for function possibilities\n\toptions.properties.unshift({\n\t\tname: 'f',\n\t\ttype: 'array'\n\t})\n\tlet templates_by_class = __node_class_names.map(name => []);\n\tfor (let t of options.templates) {\n\t\tif (t.pattern.node_class == N_NODEOF) {\n\t\t\tif (t.pattern.c.node_class == N_CALL) {\n\t\t\t\ttemplates_by_class[__global[t.pattern.c.GetName()]].push(t);\n\t\t\t} else {\n\t\t\t\tthrow new Error('invalid template ' + JSON.stringify(t))\n\t\t\t}\n\t\t} else {\n\t\t\ttemplates_by_class[t.pattern.node_class].push(t);\n\t\t}\n\t}\n\tlet t_progress = new Map();\n\tlet all_ppts = new Set(options.properties.map(ppt => ppt.name));\n\tfunction dfsTranslate(nd, is_lvalue) {\n\t\tlet utag = nd.GetUniqueTag();\n\t\tlet templates = templates_by_class[nd.node_class];\n\t\tlet helper = {\n\t\t\tmatch: undefined,\n\t\t\ttranslate: dfsTranslate,\n\t\t\tset: function(name, value, nd_value) {\n\t\t\t\tif (!nd_value) {\n\t\t\t\t\tnd_value = this.translate(this.match.nd);\n\t\t\t\t}\n\t\t\t\tif (!all_ppts.has(name)) {throw new ReferenceError('undeclared property ' + JSON.stringify(name));}\n\t\t\t\treturn nCall((nRef('set_' + name)), nRef(\"ctx\"), (nd_value).setCommentsBefore(\" \"), (ParseCode(JSON.stringify(value))).setCommentsBefore(\" \"), (nString(this.match.nd.GetUniqueTag())).setCommentsBefore(\" \"));\n\t\t\t}\n\t\t};\n\t\tfor (let i = t_progress.get(utag) | 0; i < templates.length; i++) {\n\t\t\tlet match = nd.match(t.pattern);\n\t\t\tif (!match) {continue;}\n\t\t\t//allow self-recursion\n\t\t\tt_progress.set(utag, i + 1);\n\t\t\t//on-generation callback: {action:(match,helper)=>helper.set(name,value,helper.translate(match.nd))}\n\t\t\t//calling translate again on match.nd will skip the current hook\n\t\t\thelper.match = match;\n\t\t\treturn t.action(match, helper);\n\t\t}\n\t\tif (nd.node_class == N_FUNCTION || nd.node_class == N_CLASS) {\n\t\t\t//a function, a context\n\t\t\tlet nd_params = undefined;\n\t\t\tlet params_default = [];\n\t\t\tif (nd.node_class == N_FUNCTION) {\n\t\t\t\tlet params = [];\n\t\t\t\tlet id = 0;\n\t\t\t\tfor (let nd_param of nd.c.s.children) {\n\t\t\t\t\tif (nd_param.node_class == N_ASSIGNMENT) {\n\t\t\t\t\t\tlet nd_def = FindDef(nd_param.c);\n\t\t\t\t\t\tif (nd_def) {\n\t\t\t\t\t\t\tlet name = nd_def.GetName();\n\t\t\t\t\t\t\tparams.push(cons(nSemicolon(nCall(nRef(\"Declare\"), nRef(\"ctx\"), (nString(name)).setCommentsBefore(\" \"), (nString(nd_def.GetUniqueTag())).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\"), nScopedStatement(\"if\", nParen(nBinop(\"<\", nDot(\"length\", nRef(\"params\")).setCommentsAfter(\" \"), (nNumber(id.toString())).setCommentsBefore(\" \"))).setCommentsBefore(\" \"), nScope(nSemicolon(nCall(nRef(\"Assign\"), nRef(\"ctx\"), nItem(nRef(\"ctx\"), (nString(name))).setCommentsBefore(\" \"), nItem(nRef(\"params\"), (nNumber(id.toString()))).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t*\n\t\t\t\t\t\t\t*/);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparams_default.push(dfsTranslate(nd_param.c.s));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//default value: \n\t\t\t\t\t\tparams_default.push(nCall(nRef(\"DummyValue\"), nRef(\"ctx\"), (nString(utag)).setCommentsBefore(\" \")));\n\t\t\t\t\t}\n\t\t\t\t\tid += 1;\n\t\t\t\t}\n\t\t\t\tnd_params = nScope.apply(null, params);\n\t\t\t} else {\n\t\t\t\t//TODO: inherit base class contexts\n\t\t\t\t//we're not *that* dependent on classes in JS mode\n\t\t\t\tnd_params = nAir();\n\t\t\t}\n\t\t\tlet nd_default_params = nRaw.apply(null, params_default).setFlags(0x5d5b/*[]*/);\n\t\t\tlet utag_body = nd.LastChild().GetUniqueTag();\n\t\t\t//QueueCall declares the return value object\n\t\t\tlet nd_func = nDot(\"f\", nCall(nRef(\"QueueCall\"), nCall(nDot(\"assign\", nRef(\"Object\")), nFunction(nRef(\"function\"), nParameterList(nAssignment(nRef(\"params\").setFlags(4), nAir())), nAir(), nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"_ctx_outer\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nRef(\"ctx\"))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"try\", nAir(), nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"ctx\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nCall(nRef(\"GetScopeByTag\"), nRef(\"_ctx_outer\"), (nString(utag_body)).setCommentsBefore(\" \"), (nString(utag)).setCommentsBefore(\" \")))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"ctx_func\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nRef(\"ctx\"))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nRef(\"params\")).setCommentsBefore(\" \"), nScope(nSemicolon((nd_params)).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nRef(\"Reach\"), nRef(\"ctx\"), (nString(utag_body)).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n//reach memorization - it throws\\n\").setIndent(4), nSemicolon((dfsTranslate(nd.LastChild()))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \"), nExtensionClause(\"finally\", nRaw().setFlags(10536).setCommentsBefore(\" \"), nScope(nSemicolon(nCall(nRef(\"EndScope\"), nRef(\"ctx\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")), nScope(nLabeled(nRef(\"utag\"), (nString(utag)).setCommentsBefore(\" \"))).setCommentsBefore(\" \")), (nd_default_params).setCommentsBefore(\" \")))/*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*/;\n\t\t\tlet nd_def = nd.node_class == N_FUNCTION ? FindDef(nd.c) : nd.c.s;\n\t\t\t//TODO: C++ out-of-line definition\n\t\t\tif (nd_def) {\n\t\t\t\tlet name = nd_def.GetName();\n\t\t\t\tnd_func = cons(nSemicolon(nCall(nRef(\"Declare\"), nRef(\"ctx\"), (nString(name)).setCommentsBefore(\" \"), (nString(nd_def.GetUniqueTag())).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\"), nSemicolon(nCall(nRef(\"Assign\"), nRef(\"ctx\"), nItem(nRef(\"ctx\"), (nString(name))).setCommentsBefore(\" \"), nScope(nLabeled(nRef(\"f\"), nRaw(nScope(nLabeled(nRef(\"value\"), (nd_func).setCommentsBefore(\" \")), nSymbol(\",\"), nLabeled(nRef(\"addr\"), (nString(utag)).setCommentsBefore(\" \")))).setFlags(23899).setCommentsBefore(\" \"))).setCommentsBefore(\" \"), (nString(utag)).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*/;\n\t\t\t}\n\t\t\treturn nd_func;\n\t\t}\n\t\tif (nd.node_class == N_SCOPED_STATEMENT) {\n\t\t\t//COULDDO: condition hooks\n\t\t\tif (nd.data == 'if') {\n\t\t\t\t//actual if, but with exploration - record age-based exploration states\n\t\t\t\t//store exploration status by addr\n\t\t\t\t//CFG contexts need to age their parents\n\t\t\t\tlet nd_if = nScopedStatement(\"if\", nParen(nBinop(\"===\", nCall(nRef(\"Explore\"), nRef(\"ctx_func\"), nRef(\"ctx\").setCommentsBefore(\" \"), (nString(utag)).setCommentsBefore(\" \"), nNumber(\"2\").setCommentsBefore(\" \"), (dfsTranslate(nd.c)).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\").setCommentsBefore(\" \"))).setCommentsBefore(\" \"), nScope(nSemicolon(nCall(nRef(\"Reach\"), nRef(\"ctx\"), (nString(nd.c.s.GetUniqueTag())).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon((dfsTranslate(nd.c.s))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \"))/*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*/;\n\t\t\t\tlet nd_else = nd.c.s.s;\n\t\t\t\tif (nd_else) {\n\t\t\t\t\tassert(nd_else.data == 'else');\n\t\t\t\t\tnd_if.Insert(POS_BACK, nExtensionClause('else', nAir(), nScope(nSemicolon(nCall(nRef(\"Reach\"), nRef(\"ctx\"), (nString(nd_else.c.s.GetUniqueTag())).setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon((dfsTranslate(nd_else.c.s))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*/));\n\t\t\t\t}\n\t\t\t\treturn nd_if;\n\t\t\t} else if (nd.GetCFGRole() == CFG_LOOP) {\n\t\t\t\tlet nd_init = undefined;\n\t\t\t\tlet nd_cond_begin = undefined;\n\t\t\t\tlet nd_cond_end = undefined;\n\t\t\t\tlet nd_iter_begin = undefined;\n\t\t\t\tlet nd_iter_end = undefined;\n\t\t\t\tif (nd.data == 'for') {\n\t\t\t\t\tlet desc = ParseCFor(nd);\n\t\t\t\t\tif (desc) {\n\t\t\t\t\t\t//init / cond / iter\n\t\t\t\t\t\tnd_init = dfsTranslate(desc.init);\n\t\t\t\t\t\tnd_cond_begin = dfsTranslate(desc.cond);\n\t\t\t\t\t\tnd_iter_end = dfsTranslate(desc.iter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//assume range for\n\t\t\t\t\t\tnd_iter_begin = dfsTranslate(nd.c);\n\t\t\t\t\t}\n\t\t\t\t} else if (nd.data == 'do') {\n\t\t\t\t\tlet nd_while = nd.c.s.s;\n\t\t\t\t\tif (nd_while) {\n\t\t\t\t\t\tnd_cond_end = dfsTranslate(nd_while.c);\n\t\t\t\t\t}\n\t\t\t\t} else if (nd.data == 'while') {\n\t\t\t\t\tnd_cond_begin = dfsTranslate(nd.c);\n\t\t\t\t} else {\n\t\t\t\t\tif (options.enable_warnings) {\n\t\t\t\t\t\tconsole.error('unimplemented loop statement:', nd.data);\n\t\t\t\t\t}\n\t\t\t\t\tif (nd.c.node_class != N_AIR) {\n\t\t\t\t\t\tnd_cond_begin = dfsTranslate(nd.c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(!nd_cond_begin || !nd_cond_end);\n\t\t\t\tif (!nd_init) {nd_init = nAir();}\n\t\t\t\t//gadget for break / continue interception\n\t\t\t\t//2 indicates break, 1 indicates continue, 0 indicates nothing\n\t\t\t\t//ncb: nothing-continue-break\n\t\t\t\tlet nd_body = dfsTranslate(nd.c.s);\n\t\t\t\tif (nd_iter_begin) {\n\t\t\t\t\tnd_body = nScope(nd_iter_begin, nd_body);\n\t\t\t\t}\n\t\t\t\tnd_body = nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"ncbgadget\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"ncbgadget_i\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\"))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"for\", nRaw(nAssignment(nRef(\"ncbgadget\").setFlags(1).setCommentsAfter(\" \"), nNumber(\"2\")), nSymbol(\";\"), nBinop(\"==\", nPostfix(\"++\", nRef(\"ncbgadget_i\")).setCommentsAfter(\" \"), nNumber(\"0\").setCommentsBefore(\" \")).setCommentsBefore(\" \"), nSymbol(\";\"), nAssignment(nRef(\"ncbgadget\").setFlags(1).setCommentsAfter(\" \"), nNumber(\"1\")).setCommentsBefore(\" \")).setFlags(10536).setCommentsBefore(\" \"), nScope(nSemicolon((nd_body)).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nRef(\"ncbgadget\").setFlags(1).setCommentsAfter(\" \"), nNumber(\"0\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nBinop(\"==\", nRef(\"ncbgadget\").setCommentsAfter(\" \"), nNumber(\"2\").setCommentsBefore(\" \"))).setCommentsBefore(\" \"), nScope(nSemicolon(nKeywordStatement(\"break\", nAir()))).setCommentsBefore(\" \")).setCommentsBefore(\"\\n//continue is equivalent to do-nothing here\\n\").setIndent(4), nSemicolon((nd_iter_end || nAir())).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*/;\n\t\t\t\tif (nd.c.s.node_class != N_SCOPE) {\n\t\t\t\t\tnd_body.Insert(POS_FRONT, nSemicolon(nCall(nRef(\"Reach\"), nRef(\"ctx\"), (nString(nd.c.s.GetUniqueTag())).setCommentsBefore(\" \"))));\n\t\t\t\t}\n\t\t\t\tif (nd_cond_begin) {\n\t\t\t\t\tnd_body = nScopedStatement(\"while\", nParen(nBinop(\"===\", nCall(nRef(\"Explore\"), nRef(\"ctx_func\"), nRef(\"ctx\").setCommentsBefore(\" \"), (nString(utag)).setCommentsBefore(\" \"), nNumber(\"2\").setCommentsBefore(\" \"), (nd_cond_begin).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\").setCommentsBefore(\" \"))).setCommentsBefore(\" \"), (nd_body).setCommentsBefore(\" \"));\n\t\t\t\t} else if (nd_cond_end) {\n\t\t\t\t\tnd_body = nScopedStatement(\"do\", nAir(), nScope((nd_body)).setCommentsBefore(\" \"), nExtensionClause(\"while\", nParen(nBinop(\"===\", nCall(nRef(\"Explore\"), nRef(\"ctx_func\"), nRef(\"ctx\").setCommentsBefore(\" \"), (nString(utag)).setCommentsBefore(\" \"), nNumber(\"2\").setCommentsBefore(\" \"), (nd_cond_end).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\").setCommentsBefore(\" \"))).setCommentsBefore(\" \"), nAir()).setCommentsBefore(\" \"));\n\t\t\t\t} else {\n\t\t\t\t\t//TODO: explore cond: make sure it terminates once values stop changing\n\t\t\t\t\tnd_body = nScopedStatement(\"for\", nRaw(nSymbol(\";\"), nSymbol(\";\").setCommentsBefore(\" \")).setFlags(10536).setCommentsBefore(\" \"), (nd_body).setCommentsBefore(\" \"))\n\t\t\t\t}\n\t\t\t\tif (nd_init) {\n\t\t\t\t\tnd_body = nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"_ctx_outer\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nRef(\"ctx\"))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"try\", nAir(), nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"ctx\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nCall(nRef(\"GetScopeByTag\"), nRef(\"_ctx_outer\"), (nString(utag)).setCommentsBefore(\" \")))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon((nd_init)).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon((nd_body)).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \"), nExtensionClause(\"finally\", nRaw().setFlags(10536).setCommentsBefore(\" \"), nScope(nSemicolon(nCall(nRef(\"EndScope\"), nRef(\"ctx\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*\n\t\t\t\t\t*/;\n\t\t\t\t}\n\t\t\t\treturn nd_body;\n\t\t\t} else {\n\t\t\t\tif (options.enable_warnings) {\n\t\t\t\t\tconsole.error('unimplemented statement:', nd.data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nd.node_class == N_KEYWORD_STATEMENT) {\n\t\t\tif (nd.data == 'break' || nd.data == 'continue') {\n\t\t\t\treturn nKeywordStatement(nd.data);\n\t\t\t} else if (nd.data == 'return') {\n\t\t\t\t//the return value of Assign should be ignored\n\t\t\t\tlet nd_value = dfsTranslate(nd.c);\n\t\t\t\treturn nSemicolon(nKeywordStatement(\"return\", nCall(nRef(\"Return\"), nRef(\"ctx\"), (nd_value).setCommentsBefore(\" \"), (nString(utag)).setCommentsBefore(\" \")).setCommentsBefore(\" \")));\n\t\t\t} else {\n\t\t\t\tif (options.enable_warnings) {\n\t\t\t\t\tconsole.error('unimplemented statement:', nd.data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nd.node_class == N_CALL) {\n\t\t\treturn nCall(nRef(\"Call\"), nRef(\"ctx\"), (dfsTranslate(nd.c)).setCommentsBefore(\" \"), (nScope.apply(null, nd.children.slice(1).map(ndi=>dfsTranslate(ndi))).c).setCommentsBefore(\" \")); \n\t\t}\n\t\tif (nd.node_class == N_SCOPE) {\n\t\t\treturn nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"_ctx_outer\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nRef(\"ctx\"))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"try\", nAir(), nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"ctx\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nCall(nRef(\"GetScopeByTag\"), nRef(\"_ctx_outer\"), (nString(utag)).setCommentsBefore(\" \")))).setCommentsBefore(\"\\n\").setIndent(4), (nScope.apply(null, nd.children.map(ndi=>dfsTranslate(ndi))).c).setCommentsBefore(\"\\n\").setCommentsAfter(\"/*no ;*/\\n\").setIndent(4)).setCommentsBefore(\" \"), nExtensionClause(\"finally\", nRaw().setFlags(10536).setCommentsBefore(\" \"), nScope(nSemicolon(nCall(nRef(\"EndScope\"), nRef(\"ctx\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*\n\t\t\t*/;\n\t\t}\n\t\tif (nd.node_class == N_ASSIGNMENT) {\n\t\t\treturn nCall(nRef(\"Assign\"), nRef(\"ctx\"), (dfsTranslate(nd.c, 1)).setCommentsBefore(\" \"), (dfsTranslate(nd.c.s)).setCommentsBefore(\" \"), (nString(utag)).setCommentsBefore(\" \"));\n\t\t}\n\t\tif (nd.node_class == N_DOT) {\n\t\t\tlet nd_ret = nCall(nRef(\"Dot\"), (dfsTranslate(nd.c, 1)), (nString(utag)).setCommentsBefore(\" \"), (nString(nd.data)).setCommentsBefore(\" \"));\n\t\t\tif (!is_lvalue) {\n\t\t\t\tnd_ret = nd_ret.dot('value');\n\t\t\t}\n\t\t\treturn nd_ret;\n\t\t}\n\t\tif (nd.node_class == N_ITEM) {\n\t\t\tlet nd_ret = nCall(nRef(\"Item\"), (dfsTranslate(nd.c, 1)).setCommentsBefore(\"\\n\").setIndent(4), (nString(utag)).setCommentsBefore(\" \").setIndent(4), (nScope.apply(null, nd.children.slice(1).map(ndi=>dfsTranslate(ndi))).c).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t*\n\t\t\t*\n\t\t\t*/;\n\t\t\tif (!is_lvalue) {\n\t\t\t\tnd_ret = nd_ret.dot('value');\n\t\t\t}\n\t\t\treturn nd_ret;\n\t\t}\n\t\t//COULDDO: && / ||\n\t\tif (nd.node_class == N_REF) {\n\t\t\tlet nd_ret = undefined;\n\t\t\tif (nd.flags & REF_DECLARED) {\n\t\t\t\tnd_ret = nCall(nRef(\"Declare\"), nRef(\"ctx\"), (nString(nd.data)).setCommentsBefore(\" \"), (nString(utag)).setCommentsBefore(\" \"));\n\t\t\t} else {\n\t\t\t\tnd_ret = nItem(nRef(\"ctx\"), (nString(nd.data)));\n\t\t\t}\n\t\t\tif (!is_lvalue) {\n\t\t\t\tnd_ret = nd_ret.dot('value');\n\t\t\t}\n\t\t\treturn nd_ret;\n\t\t}\n\t\tlet is_lvalue_child = 0;\n\t\tif (nd.node_class == N_PREFIX && (nd.data == '&' || nd.data == '&&')) {\n\t\t\tis_lvalue_child = 1;\n\t\t}\n\t\treturn nCall(nRef(\"DummyValue\"), nRef(\"ctx\"), (nString(utag)).setCommentsBefore(\" \"), (nScope.apply(null, nd.children.map(ndi=>dfsTranslate(ndi, is_lvalue_child))).c).setCommentsBefore(\" \"));\n\t}\n\tlet nd_gen = dfsTranslate(nd_root);\n\tif (options.enable_shim) {\n\t\tlet code_init = [nSemicolon(nCall(nRef(\"Init\")))];\n\t\tlet big_merger = [];\n\t\tfor (let ppt of options.properties) {\n\t\t\tif (ppt.default_value != undefined) {\n\t\t\t\tcode_init.push(nSemicolon(nAssignment(nItem(nDot(\"default_value\", nRef(\"Sandbox\")), (nString(ppt.name))).setCommentsAfter(\" \"), (ParseCode(JSON.stringify(ppt.default_value))))));\n\t\t\t}\n\t\t\t//create per-property setter / merger: set_foo, merge_foo\n\t\t\tlet set_foo = 'set_' + ppt.name;\n\t\t\tlet merge_foo = 'merge_' + ppt.name;\n\t\t\tlet type = (ppt.type || 'array');\n\t\t\tif (type == 'array') {\n\t\t\t\tcode_init.push(cons(nFunction(nRaw(nRef(\"function\"), (nRef(set_foo)).setCommentsBefore(\" \")), nParameterList(nAssignment(nRef(\"ctx\").setFlags(4), nAir()), nAssignment(nRef(\"tar\").setFlags(4), nAir()).setCommentsBefore(\" \"), nAssignment(nRef(\"value\").setFlags(4), nAir()).setCommentsBefore(\" \"), nAssignment(nRef(\"addr\").setFlags(4), nAir()).setCommentsBefore(\" \")), nAir(), nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"cands\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nItem(nRef(\"tar\"), (nString(ppt.name))))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nPrefix(\"!\", nRef(\"cands\"))).setCommentsBefore(\" \"), nScope(nSemicolon(nAssignment(nRef(\"cands\").setFlags(1).setCommentsAfter(\" \"), nRaw().setFlags(23899))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nItem(nRef(\"tar\").setFlags(5), (nString(ppt.name))).setCommentsAfter(\" \"), nRef(\"cands\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"found\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\"))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"for\", nRaw(nAssignment(nRaw(nRef(\"let\"), nRef(\"i\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\")), nSymbol(\";\"), nBinop(\"<\", nRef(\"i\").setCommentsAfter(\" \"), nDot(\"length\", nRef(\"cands\")).setCommentsBefore(\" \")).setCommentsBefore(\" \"), nSymbol(\";\"), nPostfix(\"++\", nRef(\"i\")).setCommentsBefore(\" \")).setFlags(10536).setCommentsBefore(\" \"), nScope(nScopedStatement(\"if\", nParen(nBinop(\"===\", nDot(\"value\", nItem(nRef(\"cands\"), nRef(\"i\"))).setCommentsAfter(\" \"), nRef(\"value\").setCommentsBefore(\" \"))).setCommentsBefore(\" \"), nScope(nSemicolon(nAssignment(nRef(\"found\").setFlags(1).setCommentsAfter(\" \"), nNumber(\"1\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nKeywordStatement(\"break\", nAir())).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nPrefix(\"!\", nRef(\"found\"))).setCommentsBefore(\" \"), nScope(nSemicolon(nCall(nDot(\"push\", nRef(\"cands\")), nScope(nLabeled(nRef(\"value\"), nRef(\"value\").setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSymbol(\",\").setIndent(4), nLabeled(nRef(\"source\"), nRef(\"addr\").setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSymbol(\",\").setCommentsAfter(\"\\n\").setIndent(4)))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nRef(\"BumpAge\"), nRef(\"ctx\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nKeywordStatement(\"return\", nRef(\"tar\").setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\"), nFunction(nRaw(nRef(\"function\"), (nRef(merge_foo)).setCommentsBefore(\" \")), nParameterList(nAssignment(nRef(\"ctx\").setFlags(4), nAir()), nAssignment(nRef(\"tar\").setFlags(4), nAir()).setCommentsBefore(\" \"), nAssignment(nRef(\"src\").setFlags(4), nAir()).setCommentsBefore(\" \")), nAir(), nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"cands\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nItem(nRef(\"tar\"), (nString(ppt.name))))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nPrefix(\"!\", nRef(\"cands\"))).setCommentsBefore(\" \"), nScope(nSemicolon(nAssignment(nRef(\"cands\").setFlags(1).setCommentsAfter(\" \"), nRaw().setFlags(23899))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nItem(nRef(\"tar\").setFlags(5), (nString(ppt.name))).setCommentsAfter(\" \"), nRef(\"cands\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"dedup\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nPrefix(\"new\", nCall(nRef(\"Set\"), nCall(nDot(\"map\", nRef(\"cands\")), nRaw(nRef(\"item\"), nSymbol(\"=>\"), nDot(\"value\", nRef(\"item\"))))).setCommentsBefore(\" \")))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"changed\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nNumber(\"0\"))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"for\", nParen(nRaw(nRef(\"let\"), nBinop(\"of\", nRef(\"item\").setCommentsAfter(\" \"), nRef(\"src\").setCommentsBefore(\" \")).setCommentsBefore(\" \"))).setCommentsBefore(\" \"), nScope(nScopedStatement(\"if\", nParen(nCall(nDot(\"has\", nRef(\"dedup\")), nDot(\"value\", nRef(\"item\")))).setCommentsBefore(\" \"), nScope(nSemicolon(nKeywordStatement(\"continue\", nAir()))).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nDot(\"push\", nRef(\"cands\")), nRef(\"item\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nRef(\"changed\").setFlags(1).setCommentsAfter(\" \"), nNumber(\"1\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nRef(\"changed\")).setCommentsBefore(\" \"), nScope(nSemicolon(nCall(nRef(\"BumpAge\"), nRef(\"ctx\")))).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nKeywordStatement(\"return\", nRef(\"tar\").setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*/);\n\t\t\t} else if (type == 'max') {\n\t\t\t\tcode_init.push(cons(nFunction(nRaw(nRef(\"function\"), (nRef(set_foo)).setCommentsBefore(\" \")), nParameterList(nAssignment(nRef(\"ctx\").setFlags(4), nAir()), nAssignment(nRef(\"tar\").setFlags(4), nAir()).setCommentsBefore(\" \"), nAssignment(nRef(\"value\").setFlags(4), nAir()).setCommentsBefore(\" \"), nAssignment(nRef(\"addr\").setFlags(4), nAir()).setCommentsBefore(\" \")), nAir(), nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"cur\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nItem(nRef(\"tar\"), (nString(ppt.name))))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nBinop(\"===\", nRef(\"cur\").setCommentsAfter(\" \"), nRef(\"undefined\").setCommentsBefore(\" \"))).setCommentsBefore(\" \"), nScope(nSemicolon(nAssignment(nRef(\"cur\").setFlags(1).setCommentsAfter(\" \"), nScope(nLabeled(nRef(\"value\"), nBinop(\"||\", nItem(nDot(\"default_value\", nRef(\"Sandbox\")), (nString(ppt.name))).setCommentsAfter(\" \"), nNumber(\"0\").setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSymbol(\",\").setIndent(4), nLabeled(nRef(\"addr\"), nRef(\"undefined\").setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nItem(nRef(\"tar\").setFlags(5), (nString(ppt.name))).setCommentsAfter(\" \"), nRef(\"cur\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"if\", nParen(nBinop(\"<\", nDot(\"value\", nRef(\"cur\")).setCommentsAfter(\" \"), nRef(\"value\").setCommentsBefore(\" \"))).setCommentsBefore(\" \"), nScope(nSemicolon(nAssignment(nDot(\"value\", nRef(\"cur\")).setCommentsAfter(\" \"), nRef(\"value\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nAssignment(nDot(\"addr\", nRef(\"cur\")).setCommentsAfter(\" \"), nRef(\"addr\"))).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nRef(\"BumpAge\"), nRef(\"ctx\"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nKeywordStatement(\"return\", nRef(\"tar\").setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\"), nFunction(nRaw(nRef(\"function\"), (nRef(merge_foo)).setCommentsBefore(\" \")), nParameterList(nAssignment(nRef(\"ctx\").setFlags(4), nAir()), nAssignment(nRef(\"tar\").setFlags(4), nAir()).setCommentsBefore(\" \"), nAssignment(nRef(\"src\").setFlags(4), nAir()).setCommentsBefore(\" \")), nAir(), nScope(nKeywordStatement(\"return\", nCall((nRef(set_foo)), nRef(\"ctx\"), nRef(\"tar\").setCommentsBefore(\" \"), nDot(\"value\", nRef(\"src\")).setCommentsBefore(\" \"), nDot(\"addr\", nRef(\"src\")).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4))/*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*\n\t\t\t\t*/);\n\t\t\t} else {\n\t\t\t\tthrow new Error('invalid property type: ' + type)\n\t\t\t}\n\t\t\tbig_merger.push(@(if (src[nCall(nRef(\"nRef\"), nDot(\"name\", nRef(\"ppt\")))] != undefined) {{nCall(nRef(\"nRef\"), nRef(\"merge_foo\"))(ctx, tar, src[nCall(nRef(\"nRef\"), nDot(\"name\", nRef(\"ppt\")))]));}});\n\t\t}\n\t\tcode_init.push(nFunction(\"MergeValue\", nRaw(nRef(\"function\"), nRef(\"MergeValue\").setFlags(5).setCommentsBefore(\" \")), nParameterList(nAssignment(nRef(\"ctx\").setFlags(4), nAir()), nAssignment(nRef(\"tar\").setFlags(4), nAir()).setCommentsBefore(\" \"), nAssignment(nRef(\"src\").setFlags(4), nAir()).setCommentsBefore(\" \")), nAir(), nScope(nSemicolon((nScope.apply(null, big_merger))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\")/*\n\t\t*\n\t\t*\n\t\t*\n\t\t*/);\n\t\tfor (let dtor of options.destructors) {\n\t\t\t//TODO\n\t\t}\n\t\tnd_gen = cons(nSemicolon(nCall(nDot(\"Init\", nRef(\"Sandbox\")))).setCommentsBefore(\"\\n\"), cons(nSemicolon(nRaw((nScope.apply(null, code_init).c), (nd_gen).setCommentsBefore(\"/*no `;`*/\\n\"))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"while\", nParen(nPrefix(\"!\", nCall(nDot(\"empty\", nDot(\"queue\", nRef(\"Sandbox\")))))).setCommentsBefore(\" \"), nScope(nSemicolon(nAssignment(nRaw(nRef(\"let\"), nRef(\"item\").setFlags(5).setCommentsBefore(\" \")).setCommentsAfter(\" \"), nCall(nDot(\"shift\", nDot(\"queue\", nRef(\"Sandbox\")))))).setCommentsBefore(\"\\n\").setIndent(4), nScopedStatement(\"try\", nAir(), nScope(nSemicolon(nCall(nDot(\"f\", nRef(\"item\")), nDot(\"params\", nRef(\"item\")))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \"), nExtensionClause(\"catch\", nParen(nRef(\"e\")).setCommentsBefore(\" \"), nScope(nScopedStatement(\"if\", nParen(nBinop(\"===\", nRef(\"e\").setCommentsAfter(\" \"), nDot(\"AlreadyMemorized\", nRef(\"Sandbox\")).setCommentsBefore(\" \"))).setCommentsBefore(\" \"), nScope(nSemicolon(nKeywordStatement(\"continue\", nAir())).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \"), nExtensionClause(\"else\", nAir(), nScope(nSemicolon(nKeywordStatement(\"throw\", nRef(\"e\").setCommentsBefore(\" \"))).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4), nSemicolon(nCall(nDot(\"push\", nDot(\"queue\", nRef(\"Sandbox\"))), nRef(\"item\"))).setCommentsBefore(\"\\n//re-queue if still exploring\\n\").setCommentsAfter(\"\\n\").setIndent(4)).setCommentsBefore(\" \")).setCommentsBefore(\"\\n\").setIndent(4)))/*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*\n\t\t*/;\n\t\t//TODO: wrap up - return the errors\n\t}\n\tfor (let nd_binop of nd_gen.FindAll(N_BINOP)) {\n\t\tif (nd_binop.data == '==') {nd_binop.data = '===';} else\n\t\tif (nd_binop.data == '!=') {nd_binop.data = '!==';}\n\t}\n\treturn nd_gen;\n};\n",
		"path", "//Node.js-compatible path handling module.\n//\n//Provided methods:\n//- `path.join(...)`\n//- `path.resolve(...)`\n//- `path.parse(path)`\n//- `path.dirname(path)`\n//- `path.basename(path)`\n//- `path.extname(path)`\n//- `path.isAbsolute(path)`\n//- `path.relative(path_a, path_b)`\n'use strict'\n//DO NOT use ama features: this is a \"chicken\" file which gets called when formatting other JS files\nlet path = module.exports;\n\npath.join = function(...args) {\n\treturn __path_normalize(args.join('/'));\n}\n\npath.resolve = function(...args) {\n\tlet ret=[];\n\tfor(let fn of args){\n\t\tif(__path_isAbsolute(fn)){ret.length=0;}\n\t\tret.push(fn);\n\t}\n\treturn __path_toAbsolute(ret.join('/'));\n}\n\npath.parse = function(s) {\n\treturn JSON.parse(__path_parse(s));\n}\n\npath.dirname = function(s) {\n\treturn path.parse(s).dir;\n}\n\npath.basename = function(s) {\n\treturn path.parse(s).base;\n}\n\npath.extname = function(s) {\n\treturn path.parse(s).ext;\n}\n\npath.isAbsolute = __path_isAbsolute;\npath.relative = __path_relative;\n",
		"pipe", "//Run external commands.\n//\n//Provided methods:\n//- `pipe.run(command)`\n'use strict'\n//DO NOT use ama features: this is a \"chicken\" file which gets called when formatting other JS files\nconst path = require('path');\nconst fs = require('fs');\nlet pipe = module.exports;\n\npipe.run = __system;\npipe.runPiped = function(cmd){\n\tlet tmp_name = path.join(process.platform==='win32'?process.env.TEMP:'/tmp', 'ama_'+Date.now().toString()+'.txt');\n\tlet exitCode = __system([cmd, ' > ', tmp_name].join(''));\n\treturn {stdout:fs.existsSync(tmp_name)?fs.readFileSync(tmp_name).toString():'', exitCode:exitCode};\n}\n",
		NULL, NULL
	};
	void GeneratedJSBindings() {
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "node_class"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_node_class), "get_node_class", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_node_class), "set_node_class", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "indent_level"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_indent_level), "get_indent_level", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_indent_level), "set_indent_level", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "tmp_flags"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_tmp_flags), "get_tmp_flags", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_tmp_flags), "set_tmp_flags", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "flags"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_flags), "get_flags", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_flags), "set_flags", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "data"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_data), "get_data", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_data), "set_data", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "comments_before"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_comments_before), "get_comments_before", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_comments_before), "set_comments_before", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "comments_after"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_comments_after), "get_comments_after", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_comments_after), "set_comments_after", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "c"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_c), "get_c", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_c), "set_c", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "s"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_s), "get_s", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_s), "set_s", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "p"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_p), "get_p", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_p), "set_p", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_DefinePropertyGetSet(jsctx, ama::g_node_proto, JS_NewAtom(jsctx, "v"), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeGet_v), "get_v", 0, JS_CFUNC_getter, 0), JS_NewCFunction2(jsctx, (JSCFunction*)(NodeSet_v), "set_v", 1, JS_CFUNC_setter, 0), JS_PROP_C_W_E);
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "LastChildSP", JS_NewCFunction(jsctx, (NodeCall_LastChildSP), "Node.LastChildSP", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "setData", JS_NewCFunction(jsctx, (NodeCall_setData), "Node.setData", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "setFlags", JS_NewCFunction(jsctx, (NodeCall_setFlags), "Node.setFlags", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "setCommentsBefore", JS_NewCFunction(jsctx, (NodeCall_setCommentsBefore), "Node.setCommentsBefore", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "setCommentsAfter", JS_NewCFunction(jsctx, (NodeCall_setCommentsAfter), "Node.setCommentsAfter", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "setIndent", JS_NewCFunction(jsctx, (NodeCall_setIndent), "Node.setIndent", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "AdjustIndentLevel", JS_NewCFunction(jsctx, (NodeCall_AdjustIndentLevel), "Node.AdjustIndentLevel", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "FreeASTStorage", JS_NewCFunction(jsctx, (NodeCall_FreeASTStorage), "Node.FreeASTStorage", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "DestroyForSymbol", JS_NewCFunction(jsctx, (NodeCall_DestroyForSymbol), "Node.DestroyForSymbol", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Clone", JS_NewCFunction(jsctx, (NodeCall_Clone), "Node.Clone", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Unlink", JS_NewCFunction(jsctx, (NodeCall_Unlink), "Node.Unlink", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "ReplaceWith", JS_NewCFunction(jsctx, (NodeCall_ReplaceWith), "Node.ReplaceWith", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "ReplaceUpto", JS_NewCFunction(jsctx, (NodeCall_ReplaceUpto), "Node.ReplaceUpto", 2));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Insert", JS_NewCFunction(jsctx, (NodeCall_Insert), "Node.Insert", 2));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Root", JS_NewCFunction(jsctx, (NodeCall_Root), "Node.Root", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "RootStatement", JS_NewCFunction(jsctx, (NodeCall_RootStatement), "Node.RootStatement", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "ParentStatement", JS_NewCFunction(jsctx, (NodeCall_ParentStatement), "Node.ParentStatement", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "FirstChild", JS_NewCFunction(jsctx, (NodeCall_FirstChild), "Node.FirstChild", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "LastChild", JS_NewCFunction(jsctx, (NodeCall_LastChild), "Node.LastChild", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Prev", JS_NewCFunction(jsctx, (NodeCall_Prev), "Node.Prev", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Next", JS_NewCFunction(jsctx, (NodeCall_Next), "Node.Next", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Parent", JS_NewCFunction(jsctx, (NodeCall_Parent), "Node.Parent", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "isRawNode", JS_NewCFunction(jsctx, (NodeCall_isRawNode), "Node.isRawNode", 2));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "isMethodCall", JS_NewCFunction(jsctx, (NodeCall_isMethodCall), "Node.isMethodCall", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "isSymbol", JS_NewCFunction(jsctx, (NodeCall_isSymbol), "Node.isSymbol", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "isRef", JS_NewCFunction(jsctx, (NodeCall_isRef), "Node.isRef", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "isAncestorOf", JS_NewCFunction(jsctx, (NodeCall_isAncestorOf), "Node.isAncestorOf", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Owning", JS_NewCFunction(jsctx, (NodeCall_Owning), "Node.Owning", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Owner", JS_NewCFunction(jsctx, (NodeCall_Owner), "Node.Owner", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "CommonAncestor", JS_NewCFunction(jsctx, (NodeCall_CommonAncestor), "Node.CommonAncestor", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Find", JS_NewCFunction(jsctx, (NodeCall_Find), "Node.Find", 2));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "FindAll", JS_NewCFunction(jsctx, (NodeCall_FindAll), "Node.FindAll", 2));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "FindAllWithin", JS_NewCFunction(jsctx, (NodeCall_FindAllWithin), "Node.FindAllWithin", 3));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "FindAllBefore", JS_NewCFunction(jsctx, (NodeCall_FindAllBefore), "Node.FindAllBefore", 4));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "GetStringValue", JS_NewCFunction(jsctx, (NodeCall_GetStringValue), "Node.GetStringValue", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "GetName", JS_NewCFunction(jsctx, (NodeCall_GetName), "Node.GetName", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "dot", JS_NewCFunction(jsctx, (NodeCall_dot), "Node.dot", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "toSource", JS_NewCFunction(jsctx, (NodeCall_toSource), "Node.toSource", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "dump", JS_NewCFunction(jsctx, (NodeCall_dump), "Node.dump", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "InsertDependency", JS_NewCFunction(jsctx, (NodeCall_InsertDependency), "Node.InsertDependency", 2));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "InsertCommentBefore", JS_NewCFunction(jsctx, (NodeCall_InsertCommentBefore), "Node.InsertCommentBefore", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "MergeCommentsBefore", JS_NewCFunction(jsctx, (NodeCall_MergeCommentsBefore), "Node.MergeCommentsBefore", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "MergeCommentsAfter", JS_NewCFunction(jsctx, (NodeCall_MergeCommentsAfter), "Node.MergeCommentsAfter", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "MergeCommentsAndIndentAfter", JS_NewCFunction(jsctx, (NodeCall_MergeCommentsAndIndentAfter), "Node.MergeCommentsAndIndentAfter", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Validate", JS_NewCFunction(jsctx, (NodeCall_Validate), "Node.Validate", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "ValidateEx", JS_NewCFunction(jsctx, (NodeCall_ValidateEx), "Node.ValidateEx", 2));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "ValidateChildCount", JS_NewCFunction(jsctx, (NodeCall_ValidateChildCount), "Node.ValidateChildCount", 2));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "BreakSibling", JS_NewCFunction(jsctx, (NodeCall_BreakSibling), "Node.BreakSibling", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "BreakChild", JS_NewCFunction(jsctx, (NodeCall_BreakChild), "Node.BreakChild", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "BreakSelf", JS_NewCFunction(jsctx, (NodeCall_BreakSelf), "Node.BreakSelf", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "toSingleNode", JS_NewCFunction(jsctx, (NodeCall_toSingleNode), "Node.toSingleNode", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "PreorderNext", JS_NewCFunction(jsctx, (NodeCall_PreorderNext), "Node.PreorderNext", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "PreorderSkip", JS_NewCFunction(jsctx, (NodeCall_PreorderSkip), "Node.PreorderSkip", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "PostorderFirst", JS_NewCFunction(jsctx, (NodeCall_PostorderFirst), "Node.PostorderFirst", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "PostorderNext", JS_NewCFunction(jsctx, (NodeCall_PostorderNext), "Node.PostorderNext", 1));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "Unparse", JS_NewCFunction(jsctx, (NodeCall_Unparse), "Node.Unparse", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "FormatFancyMessage", JS_NewCFunction(jsctx, (NodeCall_FormatFancyMessage), "Node.FormatFancyMessage", 2));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "ComputeLineNumber", JS_NewCFunction(jsctx, (NodeCall_ComputeLineNumber), "Node.ComputeLineNumber", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "GetCFGRole", JS_NewCFunction(jsctx, (NodeCall_GetCFGRole), "Node.GetCFGRole", 0));
		JS_SetPropertyStr(jsctx, ama::g_node_proto, "isChildCFGDependent", JS_NewCFunction(jsctx, (NodeCall_isChildCFGDependent), "Node.isChildCFGDependent", 1));
		ama::g_node_class_names.resize(31);
		ama::g_builder_names.resize(31);
		JSValueConst global = JS_GetGlobalObject(ama::jsctx);
		ama::g_node_class_names[N_NONE] = "N_NONE";
		ama::g_builder_names[N_NONE] = "nNone";
		ama::g_node_class_names[N_RAW] = "N_RAW";
		ama::g_builder_names[N_RAW] = "nRaw";
		ama::g_node_class_names[N_SYMBOL] = "N_SYMBOL";
		ama::g_builder_names[N_SYMBOL] = "nSymbol";
		ama::g_node_class_names[N_REF] = "N_REF";
		ama::g_builder_names[N_REF] = "nRef";
		ama::g_node_class_names[N_NUMBER] = "N_NUMBER";
		ama::g_builder_names[N_NUMBER] = "nNumber";
		ama::g_node_class_names[N_STRING] = "N_STRING";
		ama::g_builder_names[N_STRING] = "nString";
		ama::g_node_class_names[N_NODEOF] = "N_NODEOF";
		ama::g_builder_names[N_NODEOF] = "nNodeof";
		ama::g_node_class_names[N_SCOPE] = "N_SCOPE";
		ama::g_builder_names[N_SCOPE] = "nScope";
		ama::g_node_class_names[N_FUNCTION] = "N_FUNCTION";
		ama::g_builder_names[N_FUNCTION] = "nFunction";
		ama::g_node_class_names[N_CLASS] = "N_CLASS";
		ama::g_builder_names[N_CLASS] = "nClass";
		ama::g_node_class_names[N_POSTFIX] = "N_POSTFIX";
		ama::g_builder_names[N_POSTFIX] = "nPostfix";
		ama::g_node_class_names[N_DOT] = "N_DOT";
		ama::g_builder_names[N_DOT] = "nDot";
		ama::g_node_class_names[N_ITEM] = "N_ITEM";
		ama::g_builder_names[N_ITEM] = "nItem";
		ama::g_node_class_names[N_CALL] = "N_CALL";
		ama::g_builder_names[N_CALL] = "nCall";
		ama::g_node_class_names[N_CALL_TEMPLATE] = "N_CALL_TEMPLATE";
		ama::g_builder_names[N_CALL_TEMPLATE] = "nCallTemplate";
		ama::g_node_class_names[N_CALL_CUDA_KERNEL] = "N_CALL_CUDA_KERNEL";
		ama::g_builder_names[N_CALL_CUDA_KERNEL] = "nCallCudaKernel";
		ama::g_node_class_names[N_DEPENDENCY] = "N_DEPENDENCY";
		ama::g_builder_names[N_DEPENDENCY] = "nDependency";
		ama::g_node_class_names[N_BINOP] = "N_BINOP";
		ama::g_builder_names[N_BINOP] = "nBinop";
		ama::g_node_class_names[N_PREFIX] = "N_PREFIX";
		ama::g_builder_names[N_PREFIX] = "nPrefix";
		ama::g_node_class_names[N_ASSIGNMENT] = "N_ASSIGNMENT";
		ama::g_builder_names[N_ASSIGNMENT] = "nAssignment";
		ama::g_node_class_names[N_SCOPED_STATEMENT] = "N_SCOPED_STATEMENT";
		ama::g_builder_names[N_SCOPED_STATEMENT] = "nScopedStatement";
		ama::g_node_class_names[N_EXTENSION_CLAUSE] = "N_EXTENSION_CLAUSE";
		ama::g_builder_names[N_EXTENSION_CLAUSE] = "nExtensionClause";
		ama::g_node_class_names[N_PARAMETER_LIST] = "N_PARAMETER_LIST";
		ama::g_builder_names[N_PARAMETER_LIST] = "nParameterList";
		ama::g_node_class_names[N_CONDITIONAL] = "N_CONDITIONAL";
		ama::g_builder_names[N_CONDITIONAL] = "nConditional";
		ama::g_node_class_names[N_LABELED] = "N_LABELED";
		ama::g_builder_names[N_LABELED] = "nLabeled";
		ama::g_node_class_names[N_AIR] = "N_AIR";
		ama::g_builder_names[N_AIR] = "nAir";
		ama::g_node_class_names[N_FILE] = "N_FILE";
		ama::g_builder_names[N_FILE] = "nFile";
		ama::g_node_class_names[N_SEMICOLON] = "N_SEMICOLON";
		ama::g_builder_names[N_SEMICOLON] = "nSemicolon";
		ama::g_node_class_names[N_PAREN] = "N_PAREN";
		ama::g_builder_names[N_PAREN] = "nParen";
		ama::g_node_class_names[N_KEYWORD_STATEMENT] = "N_KEYWORD_STATEMENT";
		ama::g_builder_names[N_KEYWORD_STATEMENT] = "nKeywordStatement";
		ama::g_node_class_names[N_JS_REGEXP] = "N_JS_REGEXP";
		ama::g_builder_names[N_JS_REGEXP] = "nJsRegexp";
		JS_SetPropertyStr(ama::jsctx, global, "TMPF_IS_NODE", JS_NewInt32(ama::jsctx, TMPF_IS_NODE));
		JS_SetPropertyStr(ama::jsctx, global, "TMPF_GC_MARKED", JS_NewInt32(ama::jsctx, TMPF_GC_MARKED));
		JS_SetPropertyStr(ama::jsctx, global, "FILE_SPACE_INDENT", JS_NewInt32(ama::jsctx, FILE_SPACE_INDENT));
		JS_SetPropertyStr(ama::jsctx, global, "SCOPE_FROM_INDENT", JS_NewInt32(ama::jsctx, SCOPE_FROM_INDENT));
		JS_SetPropertyStr(ama::jsctx, global, "REF_WRITTEN", JS_NewInt32(ama::jsctx, REF_WRITTEN));
		JS_SetPropertyStr(ama::jsctx, global, "REF_RW", JS_NewInt32(ama::jsctx, REF_RW));
		JS_SetPropertyStr(ama::jsctx, global, "REF_DECLARED", JS_NewInt32(ama::jsctx, REF_DECLARED));
		JS_SetPropertyStr(ama::jsctx, global, "LITERAL_PARSED", JS_NewInt32(ama::jsctx, LITERAL_PARSED));
		JS_SetPropertyStr(ama::jsctx, global, "STRING_SINGLE_QUOTED", JS_NewInt32(ama::jsctx, STRING_SINGLE_QUOTED));
		JS_SetPropertyStr(ama::jsctx, global, "DOT_PTR", JS_NewInt32(ama::jsctx, DOT_PTR));
		JS_SetPropertyStr(ama::jsctx, global, "DOT_CLASS", JS_NewInt32(ama::jsctx, DOT_CLASS));
		JS_SetPropertyStr(ama::jsctx, global, "DEP_C_INCLUDE", JS_NewInt32(ama::jsctx, DEP_C_INCLUDE));
		JS_SetPropertyStr(ama::jsctx, global, "DEP_JS_REQUIRE", JS_NewInt32(ama::jsctx, DEP_JS_REQUIRE));
		JS_SetPropertyStr(ama::jsctx, global, "DEP_TYPE_MASK", JS_NewInt32(ama::jsctx, DEP_TYPE_MASK));
		JS_SetPropertyStr(ama::jsctx, global, "DEPF_C_INCLUDE_NONSTR", JS_NewInt32(ama::jsctx, DEPF_C_INCLUDE_NONSTR));
		JS_SetPropertyStr(ama::jsctx, global, "PARAMLIST_TEMPLATE", JS_NewInt32(ama::jsctx, PARAMLIST_TEMPLATE));
		JS_SetPropertyStr(ama::jsctx, global, "PARAMLIST_UNWRAPPED", JS_NewInt32(ama::jsctx, PARAMLIST_UNWRAPPED));
		JS_SetPropertyStr(ama::jsctx, global, "MAX_INDENT", JS_NewInt32(ama::jsctx, MAX_INDENT));
		JS_SetPropertyStr(ama::jsctx, global, "POS_BEFORE", JS_NewInt32(ama::jsctx, POS_BEFORE));
		JS_SetPropertyStr(ama::jsctx, global, "POS_AFTER", JS_NewInt32(ama::jsctx, POS_AFTER));
		JS_SetPropertyStr(ama::jsctx, global, "POS_FRONT", JS_NewInt32(ama::jsctx, POS_FRONT));
		JS_SetPropertyStr(ama::jsctx, global, "POS_BACK", JS_NewInt32(ama::jsctx, POS_BACK));
		JS_SetPropertyStr(ama::jsctx, global, "POS_REPLACE", JS_NewInt32(ama::jsctx, POS_REPLACE));
		JS_SetPropertyStr(ama::jsctx, global, "BOUNDARY_FUNCTION", JS_NewInt32(ama::jsctx, BOUNDARY_FUNCTION));
		JS_SetPropertyStr(ama::jsctx, global, "BOUNDARY_CLASS", JS_NewInt32(ama::jsctx, BOUNDARY_CLASS));
		JS_SetPropertyStr(ama::jsctx, global, "BOUNDARY_NODEOF", JS_NewInt32(ama::jsctx, BOUNDARY_NODEOF));
		JS_SetPropertyStr(ama::jsctx, global, "BOUNDARY_SCOPE", JS_NewInt32(ama::jsctx, BOUNDARY_SCOPE));
		JS_SetPropertyStr(ama::jsctx, global, "BOUNDARY_MATCH", JS_NewInt32(ama::jsctx, BOUNDARY_MATCH));
		JS_SetPropertyStr(ama::jsctx, global, "BOUNDARY_ONE_LEVEL", JS_NewInt32(ama::jsctx, BOUNDARY_ONE_LEVEL));
		JS_SetPropertyStr(ama::jsctx, global, "BOUNDARY_ANY", JS_NewInt32(ama::jsctx, BOUNDARY_ANY));
		JS_SetPropertyStr(ama::jsctx, global, "BOUNDARY_DEFAULT", JS_NewInt32(ama::jsctx, BOUNDARY_DEFAULT));
		JS_SetPropertyStr(ama::jsctx, global, "CFG_BASIC", JS_NewInt32(ama::jsctx, CFG_BASIC));
		JS_SetPropertyStr(ama::jsctx, global, "CFG_BRANCH", JS_NewInt32(ama::jsctx, CFG_BRANCH));
		JS_SetPropertyStr(ama::jsctx, global, "CFG_LOOP", JS_NewInt32(ama::jsctx, CFG_LOOP));
		JS_SetPropertyStr(ama::jsctx, global, "CFG_JUMP", JS_NewInt32(ama::jsctx, CFG_JUMP));
		JS_SetPropertyStr(ama::jsctx, global, "CFG_DECL", JS_NewInt32(ama::jsctx, CFG_DECL));
		JS_SetPropertyStr(ama::jsctx, global, "MSG_COLORED", JS_NewInt32(ama::jsctx, MSG_COLORED));
		JS_SetPropertyStr(ama::jsctx, global, "MSG_WARNING", JS_NewInt32(ama::jsctx, MSG_WARNING));
	}
}
#pragma gen_end(js_bindings)
