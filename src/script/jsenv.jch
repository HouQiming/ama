// //// JC version: 3
#include "./quickjs/src/quickjs.h"
#include '../ast/node.jch'
#pragma add("jc_files", "./jsenv.jc");
#pragma add('h_files', './quickjs/src/quickjs.h');
#pragma add('h_files', './quickjs/src/cutils.h');
#pragma add('h_files', './quickjs/src/list.h');
#pragma add('h_files', './quickjs/src/quickjs.h');
#pragma add('h_files', './quickjs/src/libregexp.h');
#pragma add('h_files', './quickjs/src/libregexp-opcode.h');
#pragma add('h_files', './quickjs/src/libunicode.h');
#pragma add('h_files', './quickjs/src/libunicode-table.h');
#pragma add('h_files', './quickjs/src/quickjs-opcode.h');
#pragma add('h_files', './quickjs/src/quickjs-atom.h');
#pragma add('c_files', './quickjs/src/quickjs.c');
#pragma add('c_files', './quickjs/src/libregexp.c');
#pragma add('c_files', './quickjs/src/libunicode.c');
#pragma add('c_files', './quickjs/src/cutils.c');

namespace ama {
	extern JSContext*+! jsctx;
	extern JSRuntime*+! g_runtime_handle;
	extern char[+]! std_module_dir;
	void! DumpError(JSContext*+! ctx);
	inline char[|]! UnwrapString(JSValueConst! val) {
		size_t! len = 0uLL;
		char*! ptr = JS_ToCStringLen(ama::jsctx, &len, val);
		return new char[|]!(ptr, intptr_t(len));
	}
	inline JSValueConst! WrapString(char[...]! s) {
		return JS_NewStringLen(ama::jsctx, s.data(), s.length);
	}
	inline! JSValueConst! WrapStringNullable(any s) {
		return s == NULL ? JS_NULL : WrapString(s);
	}
	inline int32_t! UnwrapInt32(JSValueConst! val, int32_t! dflt) {
		mutable int32_t! ret = 0;
		if( JS_IsUndefined(val) || JS_ToInt32(jsctx, &ret, val) < 0 ) {
			ret = dflt;
		}
		return ret;
	}
	extern uint32_t! g_node_classid;
	extern JSValue! g_node_proto;
	extern std::unordered_map<ama::Node*, JSValue>! g_js_node_map;
	inline ama::Node*+! UnwrapNode(JSValueConst! val) {
		return (ama::Node*+)(JS_GetOpaque(val, g_node_classid));
	}
	JSValueConst! WrapNode(ama::Node*! nd);
	inline JSValueConst! WrapNodeArray(ama::Node*+[...]! nds) {
		JSValueConst! ret = JS_NewArray(jsctx);
		for(intptr_t! i = 0L; i < intptr_t(nds.length); i += 1) {
			JS_SetPropertyUint32(jsctx, ret, uint32_t(uintptr_t(i)), ama::WrapNode(nds[i]));
		}
		return ret;
	}
	inline ama::Node*+[+]! UnwrapNodeArray(JSValueConst! val) {
		mutable int64_t! lg = 0LL;
		JS_ToInt64(jsctx, &lg, JS_GetPropertyStr(jsctx, val, 'length'));
		ama::Node*+[+]! ret = new ama::Node*+[+]!(intptr_t(lg));
		for(intptr_t! i = 0L; i < intptr_t(lg); i += 1) {
			ret[i] = UnwrapNode(JS_GetPropertyUint32(jsctx, val, uint32_t(uintptr_t(i))));
		}
		return <<ret;
	}
};
