// //// JC version: 3
#include <jc_platform.h>
#include <json.jch>
#include <path.jch>
#include <fs.jch>
#include <console.jch>
#include <env.jch>
#include <unicode.jch>
#include <unicode/case.jch>
#if defined(_WIN32)
	#include <windows.h>
	#pragma add('ldflags', 'kernel32.lib');
#else
	#include <dlfcn.h>
	#pragma add('ldflags', '-ldl');
#endif
#include "./quickjs/src/quickjs.h"
#include "../ast/node.jch"
#include "../ast/nodegc.jch"
#include "../codegen/gen.jch"
#include "../parser/simppair.jch"
#include "../parser/scoping.jch"
#include "../parser/depends.jch"
#include "../parser/postfix.jch"
#include "../parser/operator.jch"
#include "../parser/decl.jch"
#include "../parser/cleanup.jch"
#include "../parser/findama.jch"
#include "../exec/engine.jch"
#include "./nodeof_to_ast.jch"
#include "./jsenv.jch"
#include "./jsapi.jch"
#include "./jsgen.jch"

ama::Node*+! ama::Node::Unparse(ama::Node*+! this) {
	switch( this.node_class ) {
		default: {
			return this;
		}
		case ama::N_RAW: {
			return ama::UnparseRaw(this);
		}
		case ama::N_BINOP: {
			return ama::UnparseBinop(this);
		}
		case ama::N_CALL: {
			return ama::UnparseCall(this);
		}
		case ama::N_LABELED: {
			return ama::UnparseLabel(this);
		}
		case ama::N_PREFIX: {
			return ama::UnparsePrefix(this);
		}
	}
}

namespace ama {
	private JSValueConst! g_require_cache = JS_NULL;
	private char[+]! GetScriptJSCode(char[...]! fn) {
		char[+]! their_extname = unicode::toLowerASCII(path::extname(fn));
		char[+]?^! s_code = fs::readFileSync(fn);
		if( s_code == NULL ) {
			//console::error('failed to read', fn);
			return new char[+]!();
		}
		if( their_extname == '.json' ) {
			return '(function(exports,module){module.exports=JSON.parse(' + JSON.stringify(s_code) + ')})';
		} else {
			return '(function(exports,module,__filename,__dirname){let require=__require.bind(null,__filename);' + s_code + '\n})\n';
		}
	}
	private char[+]! ResolveJSRequire(char[...]! fn_base, char[...]! fn_required) {
		char[+]! dir_base = path::dirname(path::resolve(fn_base));
		char[+]! fn_final = path::resolve(dir_base, fn_required);
		char[|]! fn_commonjs = NULL;
		if( !fn_required.startsWith(".") && !fn_required.startsWith("/") ) {
			//it's a standard module
			//COULDDO: internal asset strings - faster and simpler than zip
			fn_commonjs = ama::FindCommonJSModuleByPath(path.join(ama::std_module_dir, fn_required));
			if( fn_commonjs == NULL ) {
				fn_commonjs = ama::FindCommonJSModuleByPath(path.join(ama::std_module_dir_global, fn_required));
			}
			if( fn_commonjs == NULL ) {
				fn_commonjs = ama::FindCommonJSModule(new char[|]!(fn_required), new char[|]!(dir_base));
			}
			if( fn_commonjs != NULL ) {
				fn_final = new char[+]!(fn_commonjs);
			}
		} else {
			fn_commonjs = ama::FindCommonJSModuleByPath(new char[|]!(fn_final));
			if( fn_commonjs != NULL ) {
				fn_final = new char[+]!(fn_commonjs);
			}
		}
		return <<fn_final;
	}
	private JSValueConst! JSResolveJSRequire(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 2 ) {
			return JS_ThrowReferenceError(ctx, "need base name and required name");
		}
		const char[|]! fn_base = ama::UnwrapString(argv[0L]);
		const char[|]! fn_required = ama::UnwrapString(argv[1L]);
		return ama::WrapString(ResolveJSRequire(fn_base, fn_required));
	}
	private JSValueConst! JSRequire(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		//custom CommonJS module loader
		const char[|]! fn_base = ama::UnwrapString(argv[0L]);
		const char[|]! fn_required = ama::UnwrapString(argv[1L]);
		char[+]! fn_final = ResolveJSRequire(fn_base, fn_required);
		/////////////
		JSValueConst! obj_module = JS_GetPropertyStr(ctx, g_require_cache, fn_final.str());
		if( JS_IsUndefined(obj_module) ) {
			obj_module = JS_NewObject(ama::jsctx);
			const JSValueConst! obj_exports = JS_NewObject(ctx);
			JS_SetPropertyStr(ctx, obj_module, 'exports', obj_exports);
			JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), obj_module);
			JS_SetPropertyStr(ctx, obj_module, 'filename', ama::WrapString(fn_final));
			//////////////
			//char[+]! loader_key = path.extname(fn_final) + ' loader';
			//JSValue! custom_loader = JS_GetPropertyStr(ctx, g_require_cache, loader_key.str());
			char[+]! ext = path.extname(fn_final);
			JSValueConst[4L]! module_args = new JSValueConst[4L]! {
				obj_exports, //
				obj_module, ama::WrapString(fn_final), ama::WrapString(path::dirname(fn_final))
			};
			if( ext == '.so' || ext == '.dll' || ext == '.dylib' || ext == '.amaso' ) {
				JSValue! js_fn_final = ama::WrapString(fn_final);
				JSValueConst! ret = JS_Invoke(ama::jsctx, JS_GetGlobalObject(ama::jsctx), JS_NewAtom(ama::jsctx, "__RequireNativeLibrary"), 4, module_args.data());
				if( JS_IsException(ret) ) {
					JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), JS_UNDEFINED);
					return ret;
				}
				JS_FreeValue(ctx, ret);
			} else {
				//////////////
				const char[+]! s_fixed_code = GetScriptJSCode(fn_final);
				if( !s_fixed_code.length ) {
					JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), JS_UNDEFINED);
					return JS_ThrowReferenceError(ctx, 'module `%s` not found', fn_required.str());
				}
				JSValueConst! ret = JS_Eval(
					ctx, (char*)(s_fixed_code.data()),
					uint64_t(uintptr_t(s_fixed_code.length)), fn_final.str(), JS_EVAL_TYPE_GLOBAL
				);
				//console.log(fn_final,raw.JS_IsException(ret))
				if( JS_IsException(ret) ) {
					JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), JS_UNDEFINED);
					return ret;
				}
				const JSValueConst! ret_module = JS_Call(ctx, JS_DupValue(ctx, ret), JS_GetGlobalObject(ctx), 4, module_args.data());
				if( JS_IsException(ret_module) ) {
					JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), JS_UNDEFINED);
					return ret_module;
				}
				JS_FreeValue(ctx, ret);
			}
			//after SetPropertyStr obj_module may have gotten freed
			//}
			//set it in the end so that one can re-require a module after an exception
			//JS_FreeValue(ctx,obj_module2)
		}
		return JS_GetPropertyStr(ctx, obj_module, 'exports');
	}
	private JSValueConst! JSGetEnv(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a name");
		}
		char[+]^+! ret = ENV::get(ama::UnwrapString(argv[0]));
		if( !ret ) { return JS_UNDEFINED; }
		return ama::WrapString(ret);
	}
	void! DumpASTAsJSON(ama::Node*+! nd) {
		LazyInitScriptEnv();
		console.log((char*)(JS_ToCString(ama::jsctx, JS_JSONStringify(ama::jsctx, ama::WrapNode(nd), JS_NULL, JS_NewInt32(ama::jsctx, 2)))));
	}
	ama::Node*+! ParseCode(char*! code, JSValue! options) {
		//for external code that calls ParseCode as an API
		LazyInitScriptEnv();
		options = ama::InheritOptions(options);
		ama::Node*+! nd_root = ama::ParseSimplePairing(code, options);
		if( ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_pointed_brackets'), 1) ) {
			ama::ParsePointedBrackets(nd_root);
		}
		if( ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_indent_as_scope'), 0) ) {
			ama::ConvertIndentToScope(nd_root, options);
		}
		ama::DelimitCLikeStatements(nd_root, options);
		//from here on, N_RAW no longer includes the root scope
		nd_root = ama::CleanupDummyRaws(nd_root);
		nd_root.node_class = ama::N_FILE;
		ama::ParseDependency(nd_root, options);
		ama::ParsePostfix(nd_root, ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_air_object'), 1));
		ama::SanitizeCommentPlacement(nd_root);
		nd_root = ama::CleanupDummyRaws(nd_root);
		if( ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_keyword_statements'), 1) ) {
			ama::ParseKeywordStatements(nd_root, options);
		}
		if( ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_scoped_statements'), 1) ) {
			ama::ParseScopedStatements(nd_root, options);
		}
		ama::ParseAssignment(nd_root, options);
		int! has_c_conditional = ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_c_conditional'), 1);
		int! has_labels = ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_labels'), 1);
		if( has_c_conditional || has_labels ) {
			ama::ParseColons(nd_root, has_c_conditional);
		}
		//nd_root.Validate();
		if( ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_operators'), 1) ) {
			ama::ParseOperators(nd_root, options);
		}
		if( ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'parse_declarations'), 1) ) {
			ama::ParseDeclarations(nd_root, options);
		}
		//DumpASTAsJSON(nd_root);
		ama::NodifySemicolonAndParenthesis(nd_root);
		nd_root = ama::CleanupDummyRaws(nd_root);
		ama::SanitizeCommentPlacement(nd_root);
		return nd_root;
	}
	private JSValueConst! JSParseCurrentFile(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv, int! magic, JSValue*+! func_data) {
		JSValue! options;
		if( argc < 1 ) {
			options = JS_NULL;
		} else {
			options = argv[0];
		}
		//extension-aware option preparation, default inheritance if necessary
		JSValueConst[2L]! prepare_option_args = new JSValueConst[2L]! {
			JS_DupValue(ama::jsctx, func_data[1]),
			JS_DupValue(ama::jsctx, options)
		};
		options = JS_Invoke(ama::jsctx, JS_GetGlobalObject(ama::jsctx), JS_NewAtom(ama::jsctx, "__PrepareOptions"), 2, prepare_option_args.data());
		options = ama::InheritOptions(options);
		//JS_DupValue(ama::jsctx, func_data[1])
		char*! file_data = (char*)(JSON.parse<uintptr_t>(ama::UnwrapString(func_data[0])));
		ama::Node*+! nd_root = ParseCode(file_data, options);
		nd_root.data = ama::UnwrapString(func_data[1]);
		return ama::WrapNode(nd_root);
	}
	private JSValueConst! JSParseCode(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		JSValue! options;
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a code string");
		}
		if( argc < 2 ) {
			options = JS_NULL;
		} else {
			options = argv[1];
		}
		return ama::WrapNode(ParseCode(JS_ToCString(ama::jsctx, argv[0]), options));
	}
	private JSValueConst! JSGenerateCode(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		return ama::WrapString(ama::GenerateCode(ama::UnwrapNode(this_val), argc > 0 ? argv[0] : JS_NULL));
	}
	int! RunScriptOnFile(char[...]! script, char*! file_name, char*! file_data) {
		//we must not hold any Node* here: the script could gc them and native-only pointers can get freed
		LazyInitScriptEnv();
		char![+]! s_fixed_code = '(function(__filename,__dirname,ParseCurrentFile){let require=__require.bind(null,__filename);' + script + '\n})\n';
		JSValueConst! ret = JS_Eval(
			ama::jsctx, s_fixed_code.data(),
			s_fixed_code.length, file_name, JS_EVAL_TYPE_GLOBAL
		);
		if( JS_IsException(ret) ) {
			ama::DumpError(ama::jsctx);
			return 0;
		}
		////////////
		//the most light weight method to pass a pointer...
		JSValueConst[2L]! func_data = new JSValueConst[2L]! {
			JS_NewString(ama::jsctx, JSON.stringify(uintptr_t(file_data)).c_str()),
			JS_NewString(ama::jsctx, file_name)
		};
		JSValueConst[3L]! module_args = new JSValueConst[3L]! {
			JS_NewString(ama::jsctx, file_name),
			ama::WrapString(path::dirname(file_name)),
			JS_NewCFunctionData(
				ama::jsctx, JSParseCurrentFile,
				1, 0, 2, func_data.data()
			)
		};
		JSValueConst! ret_script = JS_Call(ama::jsctx, JS_DupValue(ama::jsctx, ret), JS_GetGlobalObject(ama::jsctx), 3, module_args.data());
		if( JS_IsException(ret_script) ) {
			ama::DumpError(ama::jsctx);
			return 0;
		}
		return 1;
	}
	int! ProcessAmaFile(char*! fn, char[...]! extra_script) {
		LazyInitScriptEnv();
		char[+]^+! file_data = fs.readFileSync(fn);
		if( file_data == NULL ) {
			console.error('unable to load', fn);
			return ama::PROCESS_AMA_NOT_FOUND;
		}
		char![+]! script_i = ama::FindAma(file_data);
		if( extra_script.length ) {
			script_i = <<JC::string_concat(extra_script, script_i);
		}
		if( !ama::RunScriptOnFile(script_i, fn, file_data.c_str()) ) {
			return ama::PROCESS_AMA_SCRIPT_FAILED;
		}
		return ama::PROCESS_AMA_SUCCESS;
	}
	private JSValueConst! JSProcessAmaFile(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a file name");
		}
		return JS_NewInt32(ctx, ProcessAmaFile(JS_ToCString(ctx, argv[0]), argc < 2 ? (new char[|]!('')) : ama::UnwrapString(argv[1])));
	}
	private JSValueConst! JSCreateNode(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv, int! magic) {
		mutable ama::Node*+! c = (ama::Node*+)(NULL);
		char[|]! data = NULL;
		for(mutable int! i = argc - 1; i >= 0; --i) {
			if( data == NULL && JS_IsString(argv[i]) ) {
				data = ama::UnwrapString(argv[i]);
				continue;
			}
			const ama::Node*+! ndi = ama::UnwrapNode(argv[intptr_t(i)]);
			if( !ndi ) {
				return JS_ThrowTypeError(ctx, 'child %d is not a node', i);
			}
			c = ama::cons(ndi, c);
		}
		ama::Node*+! nd = ama::CreateNode(magic, c).setData(data);
		if( magic == ama::N_STRING ) {
			nd.flags = ama::LITERAL_PARSED;
		}
		return ama::WrapNode(nd);
	}
	private JSValueConst! JSCreateNodeRaw(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		//mutable ama::Node*+! c = (ama::Node*+)(NULL);
		//for(mutable int! i = argc - 1; i >= 1; --i) {
		//	const ama::Node*+! ndi = ama::UnwrapNode(argv[intptr_t(i)]);
		//	if( !ndi ) {
		//		return JS_ThrowTypeError(ctx, 'child %d is not a node', i);
		//	}
		//	c = ama::cons(ndi, c);
		//}
		if( argc < 2 ) {
			return JS_ThrowReferenceError(ctx, "need a class and a node");
		}
		return ama::WrapNode(ama::CreateNode(ama::UnwrapInt32(argv[0], ama::N_NONE), ama::UnwrapNode(argv[1])));
	}
	//COULDDO: move to JS, base on process.stdfoo.write instead
	private JSValueConst! JSConsoleWrite(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv, int! magic) {
		for(intptr_t! i = 0L; i < intptr_t(argc); i += 1) {
			if( magic == 1 ) {
				if( i ) {
					printf(" ");
				}
			} else {
				if( i ) {
					fprintf(stderr, " ");
				}
			}
			//////
			JSValueConst! arg_i = argv[i];
			JSValueConst! str = JS_IsString(arg_i) ? arg_i : JS_JSONStringify(
				ctx, arg_i,
				JS_NULL,
				JS_NewInt32(ctx, 0)
			);
			if( JS_IsException(str) ) {
				return str;
			}
			char*! s = JS_ToCString(ctx, str);
			if( magic == 1 ) {
				printf("%s", s);
			} else {
				fprintf(stderr, "%s", s);
			}
		}
		if( magic == 1 ) {
			printf("\n");
		} else {
			fprintf(stderr, "\n");
		}
		return JS_UNDEFINED;
	}
	private void! NodeFinalizer(JSRuntime*+! rt, JSValueConst! val) {
		ama::Node*+! nd = ama::UnwrapNode(val);
		ama::g_js_node_map.erase(nd);
	}
	`typedef ama::Node*(*NodeFilter)(ama::Node*);`
	`typedef ama::Node*(*NodeFilterWithOption)(ama::Node*,JSValueConst);`
	private class NodeFilterDesc {
		char*! name = NULL;
		NodeFilter! f = NULL;
		NodeFilterWithOption! fo = NULL;
	};
	private NodeFilterDesc![+]! g_filters = new NodeFilterDesc![+] {
		new NodeFilterDesc!{
			name: 'NodeofToASTExpression',
			f: ama::NodeofToASTExpression
		},
		new NodeFilterDesc!{
			name: 'CleanupDummyRaws',
			f: ama::CleanupDummyRaws
		},
		new NodeFilterDesc!{
			name: 'ParseOperators',
			fo: ama::ParseOperators
		},
		new NodeFilterDesc!{
			name: 'AutoFormat',
			f: ama::AutoFormat
		},
		new NodeFilterDesc!{
			name: 'StripBinaryOperatorSpaces',
			f: ama::StripBinaryOperatorSpaces
		}
	};
	private JSValueConst! JSApplyNodeFilter(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv, int! magic) {
		if( g_filters[magic].fo ) {
			JSValue! options = argc >= 1 ? argv[0] : JS_UNDEFINED;
			options = ama::InheritOptions(options);
			return ama::WrapNode(g_filters[magic].fo(ama::UnwrapNode(this_val), options));
		} else {
			return ama::WrapNode(g_filters[magic].f(ama::UnwrapNode(this_val)));
		}
	}
	private JSValueConst! JSReadFileSync(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a path");
		}
		char[+]^+! data = fs.readFileSync(ama::UnwrapString(argv[0]));
		if( !data ) {
			return JS_NULL;
		}
		return JS_NewArrayBufferCopy(ctx, (uint8_t*+)(data.data()), data.size());
	}
	private JSValueConst! JSWriteFileSync(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 2 ) {
			return JS_ThrowReferenceError(ctx, "need a path and a string");
		}
		size_t! len = 0uLL;
		char*! ptr = JS_ToCStringLen(ama::jsctx, &len, argv[1]);
		intptr_t! n_written = fs.writeFileSync(ama::UnwrapString(argv[0]), new char[...]!(ptr, intptr_t(len)));
		return JS_NewInt64(ctx, n_written);
	}
	private JSValueConst! JSExistsSync(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a path");
		}
		return JS_NewBool(ctx, fs.existsSync(ama::UnwrapString(argv[0])));
	}
	private JSValueConst! JSPathNormalize(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a path");
		}
		return ama::WrapString(path.normalize(ama::UnwrapString(argv[0])));
	}
	private JSValueConst! JSPathToAbsolute(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a path");
		}
		return ama::WrapString(path.toAbsolute(ama::UnwrapString(argv[0])));
	}
	private JSValueConst! JSBufferToString(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		size_t! size = 0;
		const uint8_t*! ptr = JS_GetArrayBuffer(ctx, &size, this_val);
		if( !ptr ) {
			return JS_ThrowReferenceError(ctx, 'the buffer has to be an ArrayBuffer');
		}
		if( argc > 0 && !JS_IsUndefined(argv[0]) ) {
			char*! encoding = JS_ToCString(ctx, argv[0]);
			if( strcmp(encoding, 'latin1') == 0 || strcmp(encoding, 'binary') == 0 || strcmp(encoding, 'ascii') == 0 ) {
				char[+]! ret = new char[+]!();
				for(size_t! i = 0; i < size; i++) {
					unicode::AppendUTF8Char(ret, int(uint32_t(ptr[i])));
				}
				return JS_NewStringLen(ctx, (char*)(ret.data()), ret.size());
			} else if( strcmp(encoding, 'hex') == 0 ) {
				const char*! hex = "0123456789abcdef";
				char[+]! ret = new char[+]!();
				for(size_t! i = 0; i < size; i++) {
					ret.push(hex[int(uint32_t(ptr[i])) >> 4], hex[int(uint32_t(ptr[i])) & 15]);
				}
				return JS_NewStringLen(ctx, (char*)(ret.data()), ret.size());
			} else if( strcmp(encoding, 'utf8') != 0 && strcmp(encoding, 'utf-8') != 0 ) {
				return JS_ThrowReferenceError(ctx, 'unsupported encoding %s', encoding);
			}
		}
		return JS_NewStringLen(ctx, (char*)(ptr), size);
	}
	private JSValueConst! JSGetPlaceHolder(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		return ama::WrapNode(ama::GetPlaceHolder());
	}
	private JSValueConst! JSPathParse(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a path");
		}
		return ama::WrapString(JSON.stringify(path.parse(ama::UnwrapString(argv[0]))));
	}
	private JSValueConst! JSPathIsAbsolute(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a path");
		}
		return JS_NewBool(ctx, path.isAbsolute(ama::UnwrapString(argv[0])));
	}
	private JSValueConst! JSPathRelative(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 2 ) {
			return JS_ThrowReferenceError(ctx, "need 2 paths");
		}
		return ama::WrapString(path.relative(ama::UnwrapString(argv[0]), ama::UnwrapString(argv[1])));
	}
	private JSValueConst! JSSystem(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a command");
		}
		return JS_NewInt32(ctx, system(JS_ToCString(ctx, argv[0])));
	}
	private JSValueConst! JSNodeGC(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		return JS_NewInt64(ctx, ama::gc());
	}
	private void! SetupConfigDirs() {
		///////////
		char*! home_dir = getenv("HOME");
		if( !home_dir ) {
			home_dir = "/";
		}
		ama::std_module_dir = <<path.join(home_dir, '.ama_modules');
		#if defined(_WIN32)
			char*! program_files = getenv("ProgramFiles");
			if( !program_files ) {
				program_files = "\\";
			}
			ama::std_module_dir_global = <<path.join(program_files, 'ama\\ama_modules');
		#else
			ama::std_module_dir_global = '/usr/share/ama_modules';
		#endif
	}
	private uint32_t! g_native_library_classid = 0u;
	private JSValueConst! NativeLibraryConstructor(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a file name");
		}
		void*+! hmodule = NULL;
		#if defined(_WIN32)
			hmodule = (void*+)(LoadLibraryA(JS_ToCString(ctx, argv[0])));
		#else
			hmodule = dlopen(JS_ToCString(ctx, argv[0]), RTLD_NOW);
		#endif
		if( !hmodule ) {
			return JS_ThrowReferenceError(ctx, "failed to load module %s", JS_ToCString(ctx, argv[0]));
		}
		JS_SetOpaque(this_val, hmodule);
		return this_val;
	}
	private void! NativeLibraryFinalizer(JSRuntime*+! rt, JSValueConst! val) {
		void*+! hmodule = JS_GetOpaque(val, g_native_library_classid);
		if( hmodule ) {
			JS_SetOpaque(val, NULL);
			#if defined(_WIN32)
				FreeLibrary(hmodule);
			#else
				dlclose(hmodule);
			#endif
		}
	}
	`typedef int32_t(*NativeLibraryFunction)(JSValue);`
	private JSValueConst! NativeLibraryRun(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		if( argc < 1 ) {
			return JS_ThrowReferenceError(ctx, "need a symbol name and an optional argument");
		}
		void*+! hmodule = JS_GetOpaque(this_val, g_native_library_classid);
		if( !hmodule ) {
			return JS_ThrowReferenceError(ctx, "panic: module already unloaded");
		}
		void*+! addr = NULL;
		#if defined(_WIN32)
			addr = (void*+)(GetProcAddress(HMODULE(hmodule), JS_ToCString(ctx, argv[0])));
		#else
			addr = dlsym(hmodule, JS_ToCString(ctx, argv[0]));
		#endif
		int32_t! ret_code = NativeLibraryFunction(addr)(argc < 2 ? JS_UNDEFINED : argv[1]);
		return JS_NewInt32(ctx, ret_code);
	}
	void! InitScriptEnv() {
		ama::g_runtime_handle = JS_NewRuntime();
		ama::jsctx = JS_NewContext(ama::g_runtime_handle);
		///////////
		JS_NewClassID(&ama::g_node_classid);
		mutable JSClassDef! class_def = new JSClassDef!();
		class_def.class_name = 'Node';
		class_def.finalizer = NodeFinalizer;
		JS_NewClass(ama::g_runtime_handle, ama::g_node_classid, &class_def);
		ama::g_node_proto = JS_NewObject(ama::jsctx);
		///////////
		SetupConfigDirs();
		ama::GeneratedJSBindings();
		JSValueConst! global = JS_GetGlobalObject(ama::jsctx);
		JS_SetPropertyStr(ama::jsctx, global, '__global', global);
		JSValue! js_node_class_names_array = JS_NewArray(ama::jsctx);
		JS_SetPropertyStr(ama::jsctx, global, '__node_class_names', js_node_class_names_array);
		JSValue! js_node_builder_names_array = JS_NewArray(ama::jsctx);
		JS_SetPropertyStr(ama::jsctx, global, '__node_builder_names', js_node_builder_names_array);
		for(int! i = 0; i < ama::g_node_class_names.length; i += 1) {
			JS_SetPropertyStr(ama::jsctx, global, ama::g_node_class_names[i], JS_NewInt32(ama::jsctx, i));
			JS_SetPropertyStr(ama::jsctx, global, ama::g_builder_names[i], JS_NewCFunctionMagic(
				ama::jsctx, JSCreateNode,
				ama::g_builder_names[i], 0, JS_CFUNC_generic_magic, i
			));
			JS_SetPropertyUint32(ama::jsctx, js_node_class_names_array, i, JS_NewString(ama::jsctx, ama::g_node_class_names[i]));
			JS_SetPropertyUint32(ama::jsctx, js_node_builder_names_array, i, JS_NewString(ama::jsctx, ama::g_builder_names[i]));
		}
		#if defined(_WIN32)
			JS_SetPropertyStr(ama::jsctx, global, '__platform', ama::WrapString("win32"));
		#elif defined(__APPLE__)
			JS_SetPropertyStr(ama::jsctx, global, '__platform', ama::WrapString("darwin"));
		#else
			JS_SetPropertyStr(ama::jsctx, global, '__platform', ama::WrapString("linux"));
		#endif
		JS_SetPropertyStr(ama::jsctx, global, '__std_module_dir', ama::WrapString(ama::std_module_dir));
		JS_SetPropertyStr(ama::jsctx, global, '__std_module_dir_global', ama::WrapString(ama::std_module_dir_global));
		JS_SetPropertyStr(
			ama::jsctx, global, 'CreateNode', JS_NewCFunction(
				ama::jsctx, JSCreateNodeRaw,
				'CreateNode', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, 'ParseCode', JS_NewCFunction(
				ama::jsctx, JSParseCode,
				'ParseCode', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__ResolveJSRequire', JS_NewCFunction(
				ama::jsctx, JSResolveJSRequire,
				'ResolveJSRequire', 2
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__require', JS_NewCFunction(
				ama::jsctx, JSRequire,
				'require', 2
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__getenv', JS_NewCFunction(
				ama::jsctx, JSGetEnv,
				'getenv', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__readFileSync', JS_NewCFunction(
				ama::jsctx, JSReadFileSync,
				'readFileSync', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__writeFileSync', JS_NewCFunction(
				ama::jsctx, JSWriteFileSync,
				'writeFileSync', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__existsSync', JS_NewCFunction(
				ama::jsctx, JSExistsSync,
				'existsSync', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__path_normalize', JS_NewCFunction(
				ama::jsctx, JSPathNormalize,
				'normalize', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__path_toAbsolute', JS_NewCFunction(
				ama::jsctx, JSPathToAbsolute,
				'toAbsolute', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__buffer_toString', JS_NewCFunction(
				ama::jsctx, JSBufferToString,
				'toString', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__path_parse', JS_NewCFunction(
				ama::jsctx, JSPathParse,
				'parse', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__path_isAbsolute', JS_NewCFunction(
				ama::jsctx, JSPathIsAbsolute,
				'isAbsolute', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__path_relative', JS_NewCFunction(
				ama::jsctx, JSPathRelative,
				'relative', 2
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__system', JS_NewCFunction(
				ama::jsctx, JSSystem,
				'__system', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, 'ProcessAmaFile', JS_NewCFunction(
				ama::jsctx, JSProcessAmaFile,
				'ProcessAmaFile', 1
			)
		);
		JS_SetPropertyStr(ama::jsctx, global, 'Node', ama::g_node_proto);
		JS_SetPropertyStr(
			ama::jsctx, ama::g_node_proto, 'GetPlaceHolder', JS_NewCFunction(
				ama::jsctx, JSGetPlaceHolder,
				'GetPlaceHolder', 0
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, ama::g_node_proto, 'gc', JS_NewCFunction(
				ama::jsctx, JSNodeGC,
				'gc', 0
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, ama::g_node_proto, 'toSource', JS_NewCFunction(
				ama::jsctx, JSGenerateCode,
				'toSource', 1
			)
		);
		for(int! i = 0; i < g_filters.length; i += 1) {
			JS_SetPropertyStr(
				ama::jsctx, ama::g_node_proto, g_filters[i].name, JS_NewCFunctionMagic(
					ama::jsctx, JSApplyNodeFilter,
					g_filters[i].name, g_filters[i].fo ? 2 : 1, JS_CFUNC_generic_magic, i
				)
			);
		}
		g_require_cache = JS_NewObjectProto(ama::jsctx, JS_NULL);
		JS_SetPropertyStr(
			ama::jsctx, global, '__require_cache', g_require_cache
		);
		///////////
		JSValueConst! obj_console = JS_NewObject(ama::jsctx);
		JS_SetPropertyStr(ama::jsctx, global, 'console', obj_console);
		JS_SetPropertyStr(
			ama::jsctx, obj_console, 'log', JS_NewCFunctionMagic(
				ama::jsctx, JSConsoleWrite,
				'log', 0, JS_CFUNC_generic_magic, 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, obj_console, 'error', JS_NewCFunctionMagic(
				ama::jsctx, JSConsoleWrite,
				'error', 0, JS_CFUNC_generic_magic, 2
			)
		);
		/////////////
		//setup the native extension system
		JS_NewClassID(&ama::g_native_library_classid);
		mutable JSClassDef! class_def_nl = new JSClassDef!();
		class_def_nl.class_name = 'NativeLibrary';
		class_def_nl.finalizer = NativeLibraryFinalizer;
		JS_NewClass(ama::g_runtime_handle, ama::g_native_library_classid, &class_def_nl);
		JSValue! native_library_proto = JS_NewObject(ama::jsctx);
		JSValue! native_library_ctor = JS_NewCFunction2(
			ama::jsctx, NativeLibraryConstructor,
			'log', 1, JS_CFUNC_constructor, 0
		);
		JS_SetPropertyStr(ama::jsctx, global, 'NativeLibrary', native_library_ctor);
		JS_SetPropertyStr(ama::jsctx, native_library_ctor, 'prototype', native_library_proto);
		JS_SetPropertyStr(ama::jsctx, native_library_proto, 'run', JS_NewCFunction(ama::jsctx, NativeLibraryRun, 'run', 1));
		/////////////
		//run the JS part of the initialization
		char[|]! fn_initjs = ama::FindCommonJSModuleByPath(path.join(ama::std_module_dir, '_init.js'));
		if( fn_initjs == NULL ) {
			fn_initjs = ama::FindCommonJSModuleByPath(path.join(ama::std_module_dir_global, '_init.js'));
		}
		if( fn_initjs == NULL ) {
			//we NEED that
			console.error('panic: failed to find ${AMA_MODULES}/_init.js, things could break');
		} else {
			char[+]^+! bootstrap_code = fs.readFileSync(fn_initjs);
			mutable JSValueConst! ret = JS_Eval(
				ama::jsctx, bootstrap_code.str(),
				bootstrap_code.length, fn_initjs.str(), JS_EVAL_TYPE_GLOBAL
			);
			if( JS_IsException(ret) ) {
				ama::DumpError(ama::jsctx);
			}
		}
	}
	void! LazyInitScriptEnv() {
		if( ama::g_runtime_handle ) { return; }
		InitScriptEnv();
	}
	ama::Node*+! Unparse(ama::Node*+! this);
};
