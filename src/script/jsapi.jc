// //// JC version: 3
#include <json.jch>
#include <path.jch>
#include <fs.jch>
#include <console.jch>
#include <unicode/case.jch>
#include "./quickjs/src/quickjs.h"
#include "../ast/node.jch"
#include "../codegen/gen.jch"
#include "../parser/simppair.jch"
#include "../parser/scoping.jch"
#include "../parser/depends.jch"
#include "../parser/postfix.jch"
#include "./jsenv.jch"
#include "./jsapi.jch"

private macro GenerateJSPrototype() = function(auto my_call, auto nd_node, auto nd_g_node_proto, auto nd_classid):auto {
	if( !nd_node.def ) {
		return undefined;
	}
	let class_name = nd_node.data;
	let class_full_name = nd_node.toSource();
	let classid = nd_classid.toSource();
	let code_func = [];
	let code = [];
	let nd_class_scope = nd_node.def.ParentStatement().LastChild();
	let proto = nd_g_node_proto.toSource();
	char*! ClassifyType(let nd_type) {
		let s_src = nd_type.toSource();
		if( s_src.indexOf('Node') >= 0 ) {
			if( s_src.indexOf('[') >= 0 ) {
				return 'Node[]';
			} else {
				return 'Node';
			}
		} else if( s_src.indexOf('char[') >= 0 ) {
			if( s_src.indexOf('^') >= 0 || s_src.indexOf('[|]') >= 0 ) {
				return 'string^';
			} else {
				return 'string';
			}
		} else if( s_src.indexOf('char*') >= 0 ) {
			return 'charptr';
		} else if( s_src.indexOf('void*') >= 0 ) {
			return 'void*';
		} else if( s_src.indexOf('JSValue') >= 0 ) {
			return 'JSValue';
		} else if( s_src.indexOf('float') >= 0 || s_src.indexOf('double') >= 0 ) {
			return 'float';
		} else {
			return 'int';
		}
	}
	auto WrapValue(let nd_type, char*! jc_expr) {
		let s_type = ClassifyType(nd_type);
		if( s_type == 'Node' ) {
			return ['ama::WrapNode(', jc_expr, ')'].join('');
		} else if( s_type == 'void*' ) {
			return ['ama::WrapPointer(', jc_expr, ')'].join('');
		} else if( s_type == 'Node[]' ) {
			return ['ama::WrapNodeArray(', jc_expr, ')'].join('');
		} else if( s_type == 'string' ) {
			return ['ama::WrapString(', jc_expr, ')'].join('');
		} else if( s_type == 'string^' ) {
			return ['ama::WrapStringNullable(', jc_expr, ')'].join('');
		} else if( s_type == 'charptr' ) {
			return ['JS_NewString(jsctx,', jc_expr, ')'].join('');
		} else if( s_type == 'int' ) {
			//we don't have i64 in Node
			return ['JS_NewInt32(jsctx,', jc_expr, ')'].join('');
		} else if( s_type == 'float' ) {
			return ['JS_NewFloat64(jsctx,', jc_expr, ')'].join('');
		} else if( s_type == 'JSValue' ) {
			return jc_expr;
		} else {
			throw new Error('bad type ' + s_type);
		}
	}
	let res_counter = 0;
	let UnwrapValue(let nd_type, char*! js_value) {
		let ret = {
			validation: '',
			jc_expr: ''
		};
		let s_type = ClassifyType(nd_type);
		if( s_type == 'Node' ) {
			//we don't validate here: if it's not a node, we DO want a NULL
			ret.jc_expr = ['ama::UnwrapNode(', js_value, ')'].join('');
		} else if( s_type == 'void*' ) {
			ret.jc_expr = ['ama::UnwrapPointer(', js_value, ')'].join('');
		} else if( s_type == 'Node[]' ) {
			ret.validation = [
				'if !JS_IsArray(', js_value, '):{return JS_ThrowTypeError(jsctx, "array expected for `', js_value, '`");}'
			].join('');
			ret.jc_expr = ['ama::UnwrapNodeArray(', js_value, ')'].join('');
		} else if( s_type == 'string' || s_type == 'string^' ) {
			ret.validation = [
				'if !JS_IsString(', js_value, '):{return JS_ThrowTypeError(jsctx, "string expected for `', js_value, '`");}'
			].join('');
			ret.jc_expr = [nd_type.toSource().indexOf('[+]') >= 0 ? 'ama::UnwrapStringResizable(' : 'ama::UnwrapString(', js_value, ')'].join('');
		} else if( s_type == 'charptr' ) {
			ret.validation = [
				'if !JS_IsString(', js_value, '):{return JS_ThrowTypeError(jsctx, "string expected for `', js_value, '`");}'
			].join('');
			ret.jc_expr = ['JS_ToCString(jsctx, ', js_value, ')'].join('');
		} else if( s_type == 'JSValue' ) {
			ret.validation = '';
			ret.jc_expr = js_value;
		} else if( s_type == 'int' ) {
			//we don't have i64 in Node
			ret.validation = [
				'res', res_counter, '=0;',
				'if JS_ToInt32(jsctx, &res', res_counter, ', ', js_value, ')<0:{return JS_ThrowTypeError(jsctx, "int expected for `', js_value, '`");}'
			].join('');
			ret.jc_expr = 'res' + res_counter.toString();
			res_counter += 1;
		} else if( s_type == 'float' ) {
			//we don't have i64 in Node
			ret.validation = [
				'res', res_counter, '=0.0;',
				'if JS_ToFloat64(jsctx, &res', res_counter, ', ', js_value, ')<0:{return JS_ThrowTypeError(jsctx, "float expected for `', js_value, '`");}'
			].join('');
			ret.jc_expr = 'res' + res_counter.toString();
			res_counter += 1;
		} else {
			throw new Error('bad type ' + s_type);
		}
		return ret;
	}
	nd_class_scope.FindAllWithin(BOUNDARY_SCOPE | BOUNDARY_FUNCTION | BOUNDARY_PROTOTYPE, N_DECLARATION, NULL).forEach(inline(auto nd_i) {
		let nd_def = nd_i.c;
		let nd_value = nd_i.c.s;
		if( !nd_value || nd_value.node_class == N_NULL || nd_value.node_class == N_NUMBER ) {
			if( class_name == 'Node' && nd_def.data == 'type' ) {
				return;
			}
			let nd_type = nd_def.c;
			if( nd_type.toSource().startsWith('uv_') ) {
				return;
			}
			if( nd_def.getTag('nojs') ) {
				return;
			}
			let unwrap_code = UnwrapValue(nd_type, 'val');
			//all fields are nullable
			//nd_type.toSource().indexOf('?')>=0
			if( unwrap_code.validation && ClassifyType(nd_type) != 'int' && ClassifyType(nd_type) != 'float' ) {
				//it's nullable, hack the NULL case
				unwrap_code.validation = [
					'if JS_IsNull(val):{',
					(
						'nd.' + nd_def.data
					),
					'=NULL;',
					'}else{',
					unwrap_code.validation
				].join('');
				unwrap_code.jc_expr = unwrap_code.jc_expr + ';}';
			}
			code_func.push(
				'function ', class_name, 'Get_', nd_def.data, '(JSContext*+ jsctx, JSValueConst this_val){',
				'auto nd=(', class_full_name, '*)(JS_GetOpaque(this_val, ', classid, '));',
				'return ', WrapValue(nd_type, 'nd.' + nd_def.data), ';',
				'}',
				'function ', class_name, 'Set_', nd_def.data, '(JSContext*+ jsctx, JSValueConst this_val, JSValueConst val){',
				'auto nd=(', class_full_name, '*)(JS_GetOpaque(this_val, ', classid, '));',
				unwrap_code.validation
			);
			if( nd_def.data == 'sys_flags' || nd_def.data == 'node_class' ) {
				code_func.push(
					'nd.' + nd_def.data, '=(', nd_def.c.toSource(), ')(', unwrap_code.jc_expr, ')', ';'
				);
			} else {
				code_func.push(
					'nd.' + nd_def.data, '=', unwrap_code.jc_expr, ';'
				);
			}
			code_func.push(
				'return JS_UNDEFINED;',
				'}'
			);
			code.push(
				'JS_DefinePropertyGetSet(jsctx,',
				proto, ',',
				//we don't plan to free these atoms
				'JS_NewAtom(jsctx,', JSON.stringify(nd_def.data), '),',
				'JS_NewCFunction2(jsctx,(JSCFunction*+)(', class_name, 'Get_', nd_def.data, '),"get_', nd_def.data, '",0,JS_CFUNC_getter,0),',
				'JS_NewCFunction2(jsctx,(JSCFunction*+)(', class_name, 'Set_', nd_def.data, '),"set_', nd_def.data, '",1,JS_CFUNC_setter,0),',
				'JS_PROP_C_W_E',
				');'
			);
		}
	});
	nd_class_scope.FindAllWithin(BOUNDARY_SCOPE | BOUNDARY_FUNCTION, N_EXTERN, NULL).forEach(inline(auto nd_i) {
		let nd_def = nd_i.c;
		if( class_name == 'Node' ) {
			if( nd_def.data == 'CloneEx' || nd_def.data == 'CloneCB' ) {
				return;
			}
		}
		if( nd_def.data == '__init__' || nd_def.data == '__done__' ) {
			return;
		}
		if( nd_def.getTag('nojs') ) {
			return;
		}
		let nd_ret_type = nd_i.c.s.c.s;
		if( nd_ret_type ) {
			if( nd_ret_type.getTag('nojs') ) {
				return;
			}
		}
		code_func.push(
			'function ', class_name, 'Call_', nd_def.data, '(JSContext*+ jsctx, JSValueConst this_val, int argc, JSValueConst*+ argv){',
			'auto nd=(', class_full_name, '*)(JS_GetOpaque(this_val, ', classid, '));'
		);
		if( class_name == 'Node' ) {
			if( nd_def.data == 'Insert' ) {
				code_func.push('if nd==NULL:{return JS_ThrowTypeError(jsctx, "cannot insert at a null node");}');
				code_func.push('if JS_IsNull(argv[1])||JS_IsUndefined(argv[1]):{return JS_ThrowTypeError(jsctx, "cannot insert a null node");}');
			}
		}
		let nd_paramlist = nd_i.c.s.c;
		let code_call = ['nd.', nd_def.data, '('];
		//translate argv, skip the JC this
		let i = 0;
		for(let ndi = nd_paramlist.c; ndi; ndi = ndi.s) {
			let nd_def = ndi;
			if( nd_def.node_class == N_DECLARATION ) {
				nd_def = nd_def.c;
			}
			if( nd_def.data == 'this' ) {
				continue;
			}
			let unwrap_code = UnwrapValue(nd_def.c, '(' + i.toString() + '<argc?argv[' + i.toString() + 'L]:JS_UNDEFINED)');
			if( ClassifyType(nd_def.type) != 'int' && ClassifyType(nd_def.type) != 'float' && unwrap_code.validation ) {
				//it's nullable, hack the NULL case
				code_func.push(
					'if argc>', i.toString(), '&&!JS_IsNull(argv[', i.toString(), 'L]):{',
					unwrap_code.validation,
					'}'
				);
				unwrap_code.jc_expr = ['argc>', i.toString(), '&&!JS_IsNull(argv[', i.toString(), 'L])?', unwrap_code.jc_expr, ':NULL'].join('');
			} else {
				code_func.push(unwrap_code.validation);
			}
			if( i ) {
				code_call.push(',');
			}
			code_call.push(unwrap_code.jc_expr);
			i += 1;
		}
		code_call.push(')');
		let s_call = code_call.join('');
		//wrap the return value 
		if( nd_ret_type && !(new Set(['auto', 'void'])).has(nd_ret_type.StripTypeQualifiers().toSource()) ) {
			code_func.push('return ', WrapValue(nd_ret_type, s_call), ';');
		} else {
			code_func.push(s_call, '; return JS_UNDEFINED;');
		}
		code_func.push(
			'}'
		);
		code.push(
			'JS_SetPropertyStr(jsctx,', proto, ',', JSON.stringify(nd_def.data), ',',
			'JS_NewCFunction(jsctx,(', class_name, 'Call_', nd_def.data, '),', JSON.stringify(class_name + '.' + nd_def.data), ',', i.toString(), ')',
			');'
		);
	});
	my_call.RootStatement().InsertBefore(compiler.ParseCode(code_func.join('')).c || nEmpty());
	return compiler.ParseCode(code.join('')).c || nEmpty();
}

private macro GenerateNodeConstantCode() = function(auto my_call) {
	const auto path = require('path');
	let nd_node_jch = compiler.Load(path.resolve(__dirname, '../ast/node.jch'));
	let node_constants = nd_node_jch.Find(N_CLASS, 'ama').LastChild().FindAllWithin(
		BOUNDARY_CLASS | BOUNDARY_FUNCTION | BOUNDARY_PROTOTYPE, N_DEF, NULL
	).filter(inline(auto nd) { return nd.p.node_class == N_DECLARATION; });
	let nds = [];
	//JS global constants
	for(let nd : node_constants) {
		if( nd.data.startsWith('N_') ) {
			function toCamelCase(auto s) {
				if( s == 'N' ) { return 'n'; }
				return s.substr(0, 1) + s.substr(1).toLowerCase();
			}
			let builder_name = nd.data.split('_').map(inline(auto s) { return toCamelCase(s); }).join('');
			nds.push(
				.(JS_SetPropertyStr(ama::jsctx, global, .(nString(nd.data)), JS_NewInt32(ama::jsctx, .(nRef(nd.data))))),
				.(JS_SetPropertyStr(ama::jsctx, global, .(nString(builder_name)), JS_NewCFunctionMagic(
					ama::jsctx, JSCreateNode,
					.(nString(builder_name)), 0, JS_CFUNC_generic_magic, .(nRef(nd.data))
				))),
				.(JS_SetPropertyUint32(ama::jsctx, js_node_class_names_array, .(nRef(nd.data)), JS_NewStringLen(ama::jsctx, .(nString(nd.data)), .(nNumber(nd.data.length.toString()))))),
				.(JS_SetPropertyUint32(ama::jsctx, js_node_builder_names_array, .(nRef(nd.data)), JS_NewStringLen(ama::jsctx, .(nString(builder_name)), .(nNumber(builder_name.length.toString())))))
			);
		} else if( nd.p.c.s.node_class != N_FUNCTION ) {
			nds.push(
				.(JS_SetPropertyStr(ama::jsctx, global, .(nString(nd.data)), JS_NewInt32(ama::jsctx, .(nRef(nd.data)))))
			);
		}
	}
	//JS node builders are created in JS
	return nScope.apply(NULL, nds).c;
}

namespace ama {
	private JSValueConst! g_require_cache = JS_NULL;
	private char[+]! GetScriptJSCode(char[...]! fn) {
		char[+]! their_extname = unicode::toLowerASCII(path::extname(fn));
		char[+]?^! s_code = fs::readFileSync(fn);
		if( s_code == NULL ) {
			//console::error('failed to read', fn);
			return new char[+]!();
		}
		if( their_extname == '.json' ) {
			return '(function(exports,module){module.exports=JSON.parse(' + JSON.stringify(s_code) + ')})';
		} else {
			return '(function(exports,module,__filename,__dirname){let require=__require.bind(null,__filename);' + s_code + '\n})\n';
		}
	}
	private JSValueConst! JSRequire(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		//custom CommonJS module loader
		const char[|]! fn_base = ama::UnwrapString(argv[0L]);
		const char[|]! fn_required = ama::UnwrapString(argv[1L]);
		char[+]! dir_base = path::dirname(path::resolve(fn_base));
		char[+]! fn_final = path::resolve(dir_base, fn_required);
		char[|]! fn_commonjs = NULL;
		if( !fn_required.startsWith(".") && !fn_required.startsWith("/") ) {
			//it's a standard module
			//COULDDO: internal asset strings - faster and simpler than zip
			fn_commonjs = ama::FindCommonJSModuleByPath(path.join(ama::std_module_dir, fn_required));
			if( fn_commonjs == NULL ) {
				fn_commonjs = ama::FindCommonJSModule(fn_required, new char[|]!(dir_base));
			}
			if( fn_commonjs != NULL ) {
				fn_final = new char[+]!(fn_commonjs);
			}
		} else {
			fn_commonjs = ama::FindCommonJSModuleByPath(new char[|]!(fn_final));
			if( fn_commonjs != NULL ) {
				fn_final = new char[+]!(fn_commonjs);
			}
		}
		/////////////
		JSValueConst! obj_module = JS_GetPropertyStr(ctx, g_require_cache, fn_final.str());
		if( JS_IsUndefined(obj_module) ) {
			obj_module = JS_NewObject(ama::jsctx);
			const JSValueConst! obj_exports = JS_NewObject(ctx);
			JS_SetPropertyStr(ctx, obj_module, 'exports', obj_exports);
			JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), obj_module);
			//char![+]! loader_key = path.extname(fn_final) + ' loader';
			//JSValue! custom_loader = JS_GetPropertyStr(ctx, g_obj_compiler, loader_key.str());
			JSValueConst[4L]! module_args = new JSValueConst[4L]! {
				obj_exports, //
				obj_module, ama::WrapString(fn_final), ama::WrapString(path::dirname(fn_final))
			};
			//if( !JS_IsUndefined(custom_loader) ) {
			//	//use custom_loader
			//	const JSValueConst! ret_module = JS_Call(ctx, JS_DupValue(ctx, custom_loader), JS_GetGlobalObject(ctx), 4, module_args.data());
			//	if( JS_IsException(ret_module) ) {
			//		JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), JS_UNDEFINED);
			//		return ret_module;
			//	}
			//} else {
			const char[+]! s_fixed_code = GetScriptJSCode(fn_final);
			if( !s_fixed_code.length ) {
				JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), JS_UNDEFINED);
				return JS_ThrowReferenceError(ctx, 'module `%s` not found', fn_required.str());
			}
			JSValueConst! ret = JS_Eval(
				ctx, (char*)(s_fixed_code.data()),
				uint64_t(uintptr_t(s_fixed_code.length)), fn_final.str(), JS_EVAL_TYPE_GLOBAL
			);
			//console.log(fn_final,raw.JS_IsException(ret))
			if( JS_IsException(ret) ) {
				JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), JS_UNDEFINED);
				return ret;
			}
			const JSValueConst! ret_module = JS_Call(ctx, JS_DupValue(ctx, ret), JS_GetGlobalObject(ctx), 4, module_args.data());
			if( JS_IsException(ret_module) ) {
				JS_SetPropertyStr(ctx, g_require_cache, fn_final.str(), JS_UNDEFINED);
				return ret_module;
			}
			JS_FreeValue(ctx, ret);
			//after SetPropertyStr obj_module may have gotten freed
			//}
			//set it in the end so that one can re-require a module after an exception
			//JS_FreeValue(ctx,obj_module2)
		}
		return JS_GetPropertyStr(ctx, obj_module, 'exports');
	}
	private JSValueConst! JSParseCurrentFile(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv, int! magic, JSValue*+! func_data) {
		JSValue! options;
		if( argc < 1 ) {
			options = JS_NewObjectProto(ama::jsctx, JS_NULL);
		} else {
			options = argv[1];
		}
		char*! file_data = (char*)(JSON.parse<uintptr_t>(ama::UnwrapString(func_data[0])));
		ama::Node*+! nd_root = ama::ParseSimplePairing(file_data, options);
		nd_root.data = ama::UnwrapString(func_data[1]);
		ama::DelimitCLikeStatements(nd_root);
		ama::ParseDependency(nd_root, options);
		ama::ParsePostfix(nd_root);
		return ama::WrapNode(nd_root);
	}
	int! RunScriptOnFile(char[...]! script, char*! file_name, char*! file_data) {
		char![+]! s_fixed_code = '(function(__filename,__dirname,ParseCurrentFile){let require=__require.bind(null,__filename);' + script + '\n})\n';
		JSValueConst! ret = JS_Eval(
			ama::jsctx, s_fixed_code.data(),
			s_fixed_code.length, file_name, JS_EVAL_TYPE_GLOBAL
		);
		if( JS_IsException(ret) ) {
			ama::DumpError(ama::jsctx);
			return 0;
		}
		////////////
		//the most light weight method to pass a pointer...
		JSValueConst[2L]! func_data = new JSValueConst[2L]! {
			JS_NewString(ama::jsctx, JSON.stringify(uintptr_t(file_data)).c_str()),
			JS_NewString(ama::jsctx, file_name)
		};
		JSValueConst[3L]! module_args = new JSValueConst[3L]! {
			JS_NewString(ama::jsctx, file_name),
			ama::WrapString(path::dirname(file_name)),
			JS_NewCFunctionData(
				ama::jsctx, JSParseCurrentFile,
				1, 0, 2, func_data.data()
			)
		};
		JSValueConst! ret_script = JS_Call(ama::jsctx, JS_DupValue(ama::jsctx, ret), JS_GetGlobalObject(ama::jsctx), 3, module_args.data());
		if( JS_IsException(ret_script) ) {
			ama::DumpError(ama::jsctx);
			return 0;
		}
		return 1;
	}
	private JSValueConst! JSCreateNode(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv, int! magic) {
		mutable ama::Node*+! c = (ama::Node*+)(NULL);
		char[|]! data = NULL;
		for(mutable int! i = argc - 1; i >= 0; --i) {
			if( i == 0 && JS_IsString(argv[i]) ) {
				data = ama::UnwrapString(argv[i]);
				continue;
			}
			const ama::Node*+! ndi = ama::UnwrapNode(argv[intptr_t(i)]);
			if( !ndi ) {
				return JS_ThrowTypeError(ctx, 'child %d is not a node', i);
			}
			c = ama::cons(ndi, c);
		}
		return ama::WrapNode(ama::CreateNode(magic, c).setData(data));
	}
	private JSValueConst! JSCreateNodeRaw(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv) {
		mutable ama::Node*+! c = (ama::Node*+)(NULL);
		for(mutable int! i = argc - 1; i >= 1; --i) {
			const ama::Node*+! ndi = ama::UnwrapNode(argv[intptr_t(i)]);
			if( !ndi ) {
				return JS_ThrowTypeError(ctx, 'child %d is not a node', i);
			}
			c = ama::cons(ndi, c);
		}
		return ama::WrapNode(ama::CreateNode(ama::UnwrapInt32(argv[0], ama::N_NONE), c));
	}
	private JSValueConst! g_qjs_JSON = JS_NULL;
	private uint32_t! g_stringify_atom = 0u;
	//COULDDO: move to JS, base on process.stdfoo.write instead
	private JSValueConst! JSConsoleWrite(JSContext*+! ctx, JSValueConst! this_val, int! argc, JSValue*+! argv, int! magic) {
		for(intptr_t! i = 0L; i < intptr_t(argc); i += 1) {
			if( magic == 1 ) {
				if( i ) {
					printf(" ");
				}
			} else {
				if( i ) {
					fprintf(stderr, " ");
				}
			}
			//////
			JSValueConst! arg_i = argv[i];
			//ama::Node*+! nd = ama::UnwrapNode(arg_i);
			//if( nd ) {
			//	const char[+]! s_node = '/*node ' + JSON::stringify(ama::UniqueID(intptr_t(nd))) + '*/' + nd.toSource();
			//	if( magic == 1 ) {
			//		console::write(s_node);
			//	} else {
			//		console::writeError(s_node);
			//	}
			//	continue;
			//}
			if( JS_IsFunction(ctx, arg_i) ) {
				//do nothing, it will get toString-ed later
			} else if( JS_IsObject(arg_i) ) {
				//JSON.stringify objects, including arrays
				arg_i = JS_Invoke(ctx, g_qjs_JSON, g_stringify_atom, 1, argv + i);
				if( JS_IsException(arg_i) ) {
					return arg_i;
				}
			}
			JSValueConst! str = JS_ToString(ctx, arg_i);
			if( JS_IsException(str) ) {
				return str;
			}
			char*! s = JS_ToCString(ctx, str);
			if( magic == 1 ) {
				printf("%s", s);
			} else {
				fprintf(stderr, "%s", s);
			}
		}
		if( magic == 1 ) {
			printf("\n");
		} else {
			fprintf(stderr, "\n");
		}
		return JS_UNDEFINED;
	}
	private void! NodeFinalizer(JSRuntime*+! rt, JSValueConst! val) {
		ama::Node*+! nd = ama::UnwrapNode(val);
		ama::g_js_node_map.erase(nd);
	}
	void! InitScriptEnv() {
		ama::g_runtime_handle = JS_NewRuntime();
		ama::jsctx = JS_NewContext(ama::g_runtime_handle);
		///////////
		JS_NewClassID(&ama::g_node_classid);
		mutable JSClassDef! class_def = new JSClassDef!();
		class_def.class_name = 'Node';
		class_def.finalizer = NodeFinalizer;
		JS_NewClass(ama::g_runtime_handle, ama::g_node_classid, &class_def);
		ama::g_node_proto = JS_NewObject(ama::jsctx);
		GenerateJSPrototype(ama::Node, ama::g_node_proto, ama::g_node_classid);
		///////////
		JSValueConst! global = JS_GetGlobalObject(ama::jsctx);
		JS_SetPropertyStr(ama::jsctx, global, '__global', global);
		JSValue! js_node_class_names_array = JS_NewArray(ama::jsctx);
		JS_SetPropertyStr(ama::jsctx, global, '__node_class_names', js_node_class_names_array);
		JSValue! js_node_builder_names_array = JS_NewArray(ama::jsctx);
		JS_SetPropertyStr(ama::jsctx, global, '__node_builder_names', js_node_builder_names_array);
		GenerateNodeConstantCode();
		JS_SetPropertyStr(
			ama::jsctx, global, 'CreateNode', JS_NewCFunction(
				ama::jsctx, JSCreateNodeRaw,
				'CreateNode', 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, global, '__require', JS_NewCFunction(
				ama::jsctx, JSRequire,
				'require', 2
			)
		);
		JS_SetPropertyStr(ama::jsctx, global, 'Node', ama::g_node_proto);
		g_qjs_JSON = JS_GetPropertyStr(ama::jsctx, global, 'JSON');
		g_stringify_atom = JS_NewAtom(ama::jsctx, 'stringify');
		g_require_cache = JS_NewObjectProto(ama::jsctx, JS_NULL);
		JS_SetPropertyStr(
			ama::jsctx, global, '__require_cache', g_require_cache
		);
		///////////
		JSValueConst! obj_console = JS_NewObject(ama::jsctx);
		JS_SetPropertyStr(ama::jsctx, global, 'console', obj_console);
		JS_SetPropertyStr(
			ama::jsctx, obj_console, 'log', JS_NewCFunctionMagic(
				ama::jsctx, JSConsoleWrite,
				'log', 0, JS_CFUNC_generic_magic, 1
			)
		);
		JS_SetPropertyStr(
			ama::jsctx, obj_console, 'error', JS_NewCFunctionMagic(
				ama::jsctx, JSConsoleWrite,
				'error', 0, JS_CFUNC_generic_magic, 2
			)
		);
		/////////////
		char[...]! bootstrap_code = @asset('./js_init.js');
		mutable JSValueConst! ret = JS_Eval(
			ama::jsctx, bootstrap_code.data(),
			bootstrap_code.length, '<js_init.js>', JS_EVAL_TYPE_GLOBAL
		);
		if( JS_IsException(ret) ) {
			ama::DumpError(ama::jsctx);
		}
	}
};
