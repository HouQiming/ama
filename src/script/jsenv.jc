// //// JC version: 3
#include <stdio.h>
#include <fs.jch>
#include <path.jch>
#include <json.jch>
#include "./jsenv.jch"

namespace ama {
	JSContext*+! jsctx = NULL;
	JSRuntime*+! g_runtime_handle = NULL;
	uint32_t! g_node_classid = 0u;
	JSValue! g_node_proto = JS_NULL;
	char[+]! std_module_dir;
	char[+]! std_module_dir_global;
	char*[+]! g_builder_names;
	char*[+]! g_node_class_names;
	std::unordered_map<ama::Node*, JSValue>! g_js_node_map;
	JSValueConst! WrapNode(ama::Node*! nd) {
		if( !nd ) {
			return JS_NULL;
		}
		JSValue! ret = g_js_node_map[nd];
		if( !JS_IsObject(ret) ) {
			ret = JS_NewObjectProtoClass(jsctx, g_node_proto, g_node_classid);
			JS_SetOpaque(ret, (void*+)(nd));
			JS_PreventExtensions(jsctx, ret);
			g_js_node_map[nd] = ret;
			return ret;
		} else {
			return JS_DupValue(jsctx, ret);
		}
	}
	void! DumpError(JSContext*+! ctx) {
		JSValueConst! ret = JS_GetException(ctx);
		fprintf(stderr, "%s\n", JS_ToCString(ctx, ret));
		JSValueConst! err_stack = JS_GetPropertyStr(ctx, ret, 'stack');
		fprintf(stderr, "%s", JS_ToCString(ctx, err_stack));
		fflush(stderr);
		JS_FreeValue(ctx, err_stack);
	}
	private class PackageJSON {
		char[|]! main = NULL;
	};
	private char[|]! CommonJSLoadAsFile(char[|]! fn) {
		if( fs::existsSync(fn) ) {
			return fn;
		}
		if( fs::existsSync(fn + '.js') ) {
			return new char[|]!(fn + '.js');
		}
		if( fs::existsSync(fn + '.json') ) {
			return new char[|]!(fn + '.json');
		}
		return NULL;
	}
	char[|]! FindCommonJSModuleByPath(char[|]! fn) {
		if( fs.DirExists(fn) ) {
			if( fs::existsSync(fn + '.js') ) {
				return new char[|]!(fn + '.js');
			}
			if( fs::existsSync(fn + '.json') ) {
				return new char[|]!(fn + '.json');
			}
			char[|]! fn_index = fn;
			char[+]^+! s_package_json = fs.readFileSync(path.join(fn, 'package.json'));
			if( s_package_json != NULL ) {
				PackageJSON! package_json = JSON.parse<PackageJSON>(s_package_json);
				if( package_json.main != NULL ) {
					char[|]! fn_main = path.join(fn, package_json.main);
					char[|]! ret = CommonJSLoadAsFile(fn_main);
					if( ret != NULL ) {
						return ret;
					}
					fn_index = fn_main;
				}
			}
			if( fs.existsSync(fn_index + '/index.js') ) {
				return new char[|]!(fn_index + '/index.js');
			}
			if( fs.existsSync(fn_index + '/index.json') ) {
				return new char[|]!(fn_index + '/index.json');
			}
			return NULL;
		}
		return CommonJSLoadAsFile(fn);
	}
	char[|]! FindCommonJSModule(char[|]! fn_required, char[|]! dir_base) {
		char[|]! ret = NULL;
		char[|]! dir = dir_base;
		for(;;) {
			if( path.basename(dir) != 'node_modules' ) {
				ret = FindCommonJSModuleByPath(path.join(dir, 'node_modules', fn_required));
				if( ret != NULL ) {
					return ret;
				}
			}
			char[+]! dir_upper = path.dirname(dir);
			if( dir == dir_upper ) {
				break;
			}
			dir = new char[|]!(dir_upper);
		}
		return NULL;
	}
	Map<char[|], int>! GetPrioritizedList(JSValueConst! options, char*! name) {
		char[|]! s_binops = ama::UnwrapString(JS_GetPropertyStr(ama::jsctx, options, name));
		Map<char[|], int>! ret = new Map<char[|], int>!();
		int! priority = 1;
		for(char[...]&! s_binop : s_binops.split(' ')) {
			if( s_binop.endsWith('\n') ) {
				ret[new char[|]!(s_binop.subarray(0, s_binop.length - 1))] = priority;
				priority += 1;
			} else {
				ret[new char[|]!(s_binop)] = priority;
			}
		}
		return <<ret;
	}
	JSValue! InheritOptions(JSValueConst! options) {
		return JS_Invoke(ama::jsctx, JS_GetGlobalObject(ama::jsctx), JS_NewAtom(ama::jsctx, "__InheritOptions"), 1, &options);
	}
};
