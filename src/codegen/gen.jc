// //// JC version: 3
#include <console.jch>
#include <json.jch>
#include '../ast/node.jch'
#include '../script/jsenv.jch'
#include '../parser/literal.jch'
#include "../parser/charset.jch"
#include './gen.jch'

namespace ama {
	private const uint32_t[+]! g_identifier = ama::CharSet('0-9A-Za-z_#-');
	void! ama::CodeGenerator::GenerateSpaceBefore(ama::CodeGenerator*+! this, ama::Node*+! nd_next) {
		if( !nd_next.comments_before.startsWith('\n') ) {
			this->code.push_back(' ');
		}
	}
	void! ama::CodeGenerator::GenerateDefault(ama::CodeGenerator*+! this, ama::Node*+! nd) {
		switch( nd.node_class ) {
			default: {
				this.code.push(
					'/* unsupported node class ', JSON.stringify(nd.node_class), ' */ ',
					JSON.stringify(nd), ' /* with children */ ('
				);
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					this.Generate(ndi);
					this.code.push(' ');
				}
				this.code.push(')');
				break;
			}
			case ama::N_FILE: case ama::N_RAW: {
				char! ch_opening = char(nd.flags & 0xff);
				if( ch_opening ) {
					this->code.push_back(ch_opening);
				}
				intptr_t! bk_indent = this.scope_indent_level;
				if( nd.flags & 0xffff ) {
					this.scope_indent_level += nd.indent_level;
				}
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					//if( ndi.node_class != ama::N_SYMBOL && !(ndi.node_class == ama::N_RAW && (ndi.flags & 0xffff) != 0) && 
					//this->code.length > 0 && ama::isInCharSet(g_identifier, uint8_t(this->code.back())) && !ndi.comments_before.length ) {
					//	this->code.push(' ');
					//}
					this->Generate(ndi);
				}
				this.in_new_line = 0;
				this.GenerateComment(this.scope_indent_level, nd.comments_after);
				this.scope_indent_level = bk_indent;
				char! ch_closing = char(nd.flags >> 8 & 0xff);
				if( ch_closing ) {
					this->code.push_back(ch_closing);
				}
				break;
			}
			case ama::N_SCOPE: {
				this->code.push_back('{');
				intptr_t! bk_indent = this.scope_indent_level;
				this.scope_indent_level += nd.indent_level;
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					this->Generate(ndi);
					if( !this.code.endsWith('}') && !this.code.endsWith(';') ) {
						this->code.push_back(';');
					}
					//if( ndi.isExpr() && !(ndi.s && ndi.s.node_class == ama::N_SYMBOL && ndi.s.data == ";") ) {
					//	this->code.push_back(';');
					//}
				}
				this.GenerateComment(this.scope_indent_level, nd.comments_after);
				this.scope_indent_level = bk_indent;
				this->code.push_back('}');
				break;
			}
			case ama::N_STRING: {
				if( nd.flags & ama::LITERAL_PARSED ) {
					if( nd.flags & ama::STRING_SINGLE_QUOTED ) {
						this->code.push(ama::escapeJSString(nd.data));
					} else {
						this->code.push(JSON::stringify(nd.data));
					}
					break;
				}
			}
			case ama::N_SYMBOL: case ama::N_REF: case ama::N_NUMBER: {
				this->code.push(nd.data);
				break;
			}
			case ama::N_TYPED_VAR: {
				this->Generate(nd.c);
				if( !this.code.endsWith(' ') && !nd.c.s.comments_before.startsWith(' ') ) {
					this.code.push_back(' ');
				}
				this->Generate(nd.c.s);
				break;
			}
			case ama::N_DOT: {
				//this->RebuildOperand(nd, nd.c, ama::OPERAND_POSTFIX);
				this->Generate(nd.c);
				if( nd.flags & ama::DOT_CLASS ) {
					this->code.push('::');
				} else if( nd.flags & ama::DOT_PTR ) {
					this->code.push('->');
				} else {
					this->code.push('.');
				}
				this->code.push(nd.data);
				break;
			}
			case ama::N_CALL: case ama::N_CALL_TEMPLATE: case ama::N_CALL_CUDA_KERNEL: {
				if( nd.c ) {
					this->Generate(nd.c);
				} else {
					this->code.push('/* missing callee */');
				}
				if( nd.node_class == ama::N_CALL_CUDA_KERNEL ) {
					this->code.push('<<<');
				} else if( nd.node_class == ama::N_CALL_TEMPLATE ) {
					this->code.push_back('<');
				} else {
					this->code.push_back('(');
				}
				intptr_t! bk_indent = this.scope_indent_level;
				this.scope_indent_level += nd.indent_level;
				for(ama::Node*+! ndi = nd.c.s; ndi; ndi = ndi.s) {
					this->Generate(ndi);
					if( ndi.s ) {
						this->code.push_back(',');
						this.GenerateSpaceBefore(ndi.s);
					}
				}
				this.GenerateComment(this.scope_indent_level, nd.comments_after);
				this.scope_indent_level = bk_indent;
				if( nd.node_class == ama::N_CALL_CUDA_KERNEL ) {
					this->code.push('>>>');
				} else if( nd.node_class == ama::N_CALL_TEMPLATE ) {
					this->code.push_back('>');
				} else {
					this->code.push_back(')');
				}
				break;
			}
			case ama::N_PARAMETER_LIST: {
				this->code.push_back('(');
				intptr_t! bk_indent = this.scope_indent_level;
				this.scope_indent_level += nd.indent_level;
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					this->Generate(ndi);
					if( ndi.s ) {
						this->code.push_back(',');
						this.GenerateSpaceBefore(ndi.s);
					}
				}
				this.GenerateComment(this.scope_indent_level, nd.comments_after);
				this.scope_indent_level = bk_indent;
				this->code.push_back(')');
				break;
			}
			//case ama::N_RAW_DECLARATION: {
			//	for(ama::Node*+! ndi : nd) {
			//		this->Generate(ndi);
			//	}
			//	break;
			//}
			case ama::N_DEPENDENCY: {
				if( (nd.flags & ama::DEP_TYPE_MASK) == ama::DEP_C_INCLUDE ) {
					this.code.push('#include ');
					if( nd.flags & ama::DEPF_C_INCLUDE_NONSTR ) {
						this.code.push(nd.c.GetStringValue());
					} else {
						this->Generate(nd.c);
					}
					this.code.push('\n');
				} else if( (nd.flags & ama::DEP_TYPE_MASK) == ama::DEP_JS_REQUIRE ) {
					this.code.push('require(');
					this->Generate(nd.c);
					this.code.push(')');
				}
				break;
			}
			case ama::N_BINOP: {
				this->Generate(nd.c);
				this.code.push(' ', nd.data);
				this.GenerateSpaceBefore(nd.c.s);
				this->Generate(nd.c.s);
				break;
			}
			case ama::N_UNARY: {
				if( nd.flags & ama::UNARY_POSTFIX ) {
					this->Generate(nd.c);
					this.code.push(nd.data);
				} else {
					this.code.push(nd.data);
					this->Generate(nd.c);
				}
				break;
			}
			case ama::N_ASSIGNMENT: {
				this->Generate(nd.c);
				if( nd.c.s.isAir() ) {
					//do nothing
				} else {
					this.code.push(' ');
					if( nd.data != NULL ) {
						this.code.push(nd.data);
					}
					this.code.push('=');
					this.GenerateSpaceBefore(nd.c.s);
					this->Generate(nd.c.s);
				}
				break;
			}
			case ama::N_CLASS: case ama::N_SCOPED_STATEMENT: case ama::N_EXTENSION_CLAUSE: {
				this.code.push(nd.data);
				//*** PASS THROUGH ***
			}
			case ama::N_FUNCTION: {
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					if( ndi.node_class == ama::N_EXTENSION_CLAUSE ) {
						this.GenerateSpaceBefore(ndi);
					}
					this->Generate(ndi);
				}
				break;
			}
			case ama::N_NODEOF: {
				this.code.push('.');
				this->Generate(nd.c);
				break;
			}
			case ama::N_CONDITIONAL: {
				this->Generate(nd.c);
				this.code.push(' ', '?');
				this.GenerateSpaceBefore(nd.c.s);
				this->Generate(nd.c.s);
				this.code.push(' ', ':');
				this.GenerateSpaceBefore(nd.c.s.s);
				this->Generate(nd.c.s.s);
				break;
			}
			case ama::N_LABELED: {
				this->Generate(nd.c);
				this.code.push(':');
				this.GenerateSpaceBefore(nd.c.s);
				this->Generate(nd.c.s);
				break;
			}
			case ama::N_AIR: {
				//nothing
				break;
			}
		}
		//case N_ITEM:
	}
	void! ama::CodeGenerator::GenerateIndent(ama::CodeGenerator*+! this, intptr_t! expected_indent_level) {
		while( this.current_indent_level < expected_indent_level ) {
			if( (this.current_indent_level % this.tab_width) == 0 && (this.current_indent_level + this.tab_width) <= expected_indent_level ) {
				this.code.push_back('\t');
				this.current_indent_level /= this.tab_width;
				this.current_indent_level += 1;
				this.current_indent_level *= this.tab_width;
			} else {
				this.code.push_back(' ');
				this.current_indent_level += 1L;
			}
		}
	}
	void! ama::CodeGenerator::GenerateComment(ama::CodeGenerator*+! this, intptr_t! expected_indent_level, char[...]! comment) {
		if( this.hook_comment != NULL ) {
			if( this.hook_comment(this, comment.data(), comment.length, expected_indent_level) != 0 ) { return; }
		}
		if( comment.indexOf('\n') < 0 ) {
			this.code.push(comment);
			return;
		}
		for(char&! ch : comment) {
			if( ch == '\n' ) {
				this.in_new_line = int8_t(1);
				this.current_indent_level = 0L;
			} else if( this->in_new_line ) {
				if( ch == ' ' ) {
					this.current_indent_level += 1L;
				} else if( ch == '\t' ) {
					this.current_indent_level /= this.tab_width;
					this.current_indent_level += 1;
					this.current_indent_level *= this.tab_width;
				} else {
					this.GenerateIndent(expected_indent_level);
					this.in_new_line = int8_t(0);
				}
			}
			this.code.push(ch);
		}
		if( this.in_new_line ) {
			this.GenerateIndent(expected_indent_level);
		}
	}
	void! ama::CodeGenerator::Generate(ama::CodeGenerator*+! this, ama::Node*+! nd) {
		if( !nd ) {
			this.code.push('/*NULL*/');
			return;
		}
		intptr_t! expected_indent_level = this.scope_indent_level + intptr_t(nd.indent_level);
		//expected_indent_level should be normally redundant
		this.GenerateComment(expected_indent_level, nd.comments_before);
		if( this.hook != NULL && this.hook(this, nd) != 0 ) {
			//the hook generated it
		} else {
			this.GenerateDefault(nd);
		}
		//the "normal" content of a node should not contain newline
		if( !nd.hasBrackets() ) {
			this.in_new_line = 0;
			this.GenerateComment(expected_indent_level, nd.comments_after);
		}
	}
	char[+]! GenerateCode(ama::Node*+! nd, JSValueConst! options) {
		ama::CodeGenerator! ctx = new ama::CodeGenerator!();
		ctx.tab_width = ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'tab_width'), 4);
		ctx.Generate(nd);
		return <<ctx.code;
	}
	char[+]! ama::Node::toSource(ama::Node*! this) {
		JSValueConst! tmp_options = JS_NewObjectProto(ama::jsctx, JS_NULL);
		char[+]! ret = GenerateCode((ama::Node*+)(this), tmp_options);
		JS_FreeValue(ama::jsctx, tmp_options);
		return <<ret;
	}
};
