// //// JC version: 3
#include <console.jch>
#include <json.jch>
#include '../ast/node.jch'
#include '../script/jsenv.jch'
#include '../parser/literal.jch'
#include "../parser/charset.jch"
#include './gen.jch'

namespace ama {
	void! ama::CodeGenerator::GenerateSpaceBefore(ama::CodeGenerator*+! this, ama::Node*+! nd_next) {
		if( this.auto_space && !(nd_next.comments_before.length && uint8_t(nd_next.comments_before[0]) <= uint8_t(' ')) ) {
			this->code.push_back(' ');
		}
	}
	void! ama::CodeGenerator::GenerateSpaceAfter(ama::CodeGenerator*+! this, ama::Node*+! nd_last) {
		if( this.auto_space && !(nd_last.comments_after.length && uint8_t(nd_last.comments_after[nd_last.comments_after.length - 1]) <= uint8_t(' ')) ) {
			this->code.push_back(' ');
		}
	}
	void! ama::CodeGenerator::GenerateSpaceBetween(ama::CodeGenerator*+! this, ama::Node*+! nd_last, ama::Node*+! nd_next) {
		if( this.auto_space && !(nd_next.comments_before.length && uint8_t(nd_next.comments_before[0]) <= uint8_t(' ')) ) {
			this->GenerateSpaceAfter(nd_last);
		}
	}
	void! ama::CodeGenerator::GenerateDefault(ama::CodeGenerator*+! this, ama::Node*+! nd) {
		switch( nd.node_class ) {
			default: {
				this.code.push(
					'/* unsupported node class ', JSON.stringify(nd.node_class), ' */ ',
					JSON.stringify(nd), ' /* with children */ ('
				);
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					this.Generate(ndi);
					this.code.push(' ');
				}
				this.code.push(')');
				break;
			}
			case ama::N_FILE: case ama::N_RAW: {
				char! ch_opening = char(nd.flags & 0xff);
				if( ch_opening ) {
					this->code.push_back(ch_opening);
				}
				intptr_t! bk_indent = this.scope_indent_level;
				if( nd.flags & 0xffff ) {
					this.scope_indent_level += nd.indent_level;
				}
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					this->Generate(ndi);
					if( ndi.s && (ndi.isSymbol(",") || ndi.isSymbol(";")) ) {
						this->GenerateSpaceBetween(ndi, ndi.s);
					}
				}
				this.scope_indent_level = bk_indent;
				char! ch_closing = char(nd.flags >> 8 & 0xff);
				if( ch_closing ) {
					this->code.push_back(ch_closing);
				}
				break;
			}
			case ama::N_SCOPE: {
				this->code.push_back('{');
				intptr_t! bk_indent = this.scope_indent_level;
				this.scope_indent_level += nd.indent_level;
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					this->Generate(ndi);
				}
				this.scope_indent_level = bk_indent;
				this->code.push_back('}');
				break;
			}
			case ama::N_STRING: {
				if( nd.flags & ama::LITERAL_PARSED ) {
					if( nd.flags & ama::STRING_SINGLE_QUOTED ) {
						this->code.push(ama::escapeJSString(nd.data));
					} else {
						this->code.push(JSON::stringify(nd.data));
					}
					break;
				}
			}
			case ama::N_JS_REGEXP: case ama::N_SYMBOL: case ama::N_REF: case ama::N_NUMBER: {
				this->code.push(nd.data);
				break;
			}
			case ama::N_TYPED_VAR: {
				this->Generate(nd.c);
				this.GenerateSpaceBetween(nd.c, nd.c.s);
				this->Generate(nd.c.s);
				break;
			}
			case ama::N_DOT: {
				//this->RebuildOperand(nd, nd.c, ama::OPERAND_POSTFIX);
				this->Generate(nd.c);
				if( nd.flags == ama::DOT_CLASS ) {
					this->code.push('::');
				} else if( nd.flags == ama::DOT_PTR ) {
					this->code.push('->');
				} else {
					this->code.push('.');
				}
				this->code.push(nd.data);
				break;
			}
			case ama::N_CALL: case ama::N_CALL_TEMPLATE: case ama::N_CALL_CUDA_KERNEL: case ama::N_ITEM: {
				if( nd.c ) {
					this->Generate(nd.c);
				} else {
					this->code.push('/* missing callee */');
				}
				if( nd.node_class == ama::N_CALL_CUDA_KERNEL ) {
					this->code.push('<<<');
				} else if( nd.node_class == ama::N_CALL_TEMPLATE ) {
					this->code.push_back('<');
				} else if( nd.node_class == ama::N_ITEM ) {
					this->code.push_back('[');
				} else {
					if( nd.flags & ama::CALL_IS_UNARY_OPERATOR ) {
						if( nd.c.s ) {
							this.GenerateSpaceBefore(nd.c.s);
						}
					} else {
						this->code.push_back('(');
					}
				}
				intptr_t! bk_indent = this.scope_indent_level;
				this.scope_indent_level += nd.indent_level;
				if( nd.c ) {
					for(ama::Node*+! ndi = nd.c.s; ndi; ndi = ndi.s) {
						this->Generate(ndi);
						if( ndi.s ) {
							this->code.push_back(',');
							this.GenerateSpaceBefore(ndi.s);
						}
					}
				}
				this.scope_indent_level = bk_indent;
				if( nd.node_class == ama::N_CALL_CUDA_KERNEL ) {
					this->code.push('>>>');
				} else if( nd.node_class == ama::N_CALL_TEMPLATE ) {
					this->code.push_back('>');
				} else if( nd.node_class == ama::N_ITEM ) {
					this->code.push_back(']');
				} else {
					if( nd.flags & ama::CALL_IS_UNARY_OPERATOR ) {
						//do nothing
					} else {
						this->code.push_back(')');
					}
				}
				break;
			}
			case ama::N_PARAMETER_LIST: {
				this->code.push_back('(');
				intptr_t! bk_indent = this.scope_indent_level;
				this.scope_indent_level += nd.indent_level;
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					this->Generate(ndi);
					if( ndi.s ) {
						this->code.push_back(',');
						this.GenerateSpaceBefore(ndi.s);
					}
				}
				this.scope_indent_level = bk_indent;
				this->code.push_back(')');
				break;
			}
			//case ama::N_RAW_DECLARATION: {
			//	for(ama::Node*+! ndi : nd) {
			//		this->Generate(ndi);
			//	}
			//	break;
			//}
			case ama::N_DEPENDENCY: {
				if( (nd.flags & ama::DEP_TYPE_MASK) == ama::DEP_C_INCLUDE ) {
					this.code.push('#include');
					this.GenerateSpaceBefore(nd.c);
					if( nd.flags & ama::DEPF_C_INCLUDE_NONSTR ) {
						this.GenerateComment(0, this.scope_indent_level + intptr_t(nd.c.indent_level), nd.c.comments_before);
						this.code.push(nd.c.GetStringValue());
						this.GenerateComment(1, this.scope_indent_level + (nd.s ? intptr_t(nd.s.indent_level) : 0L), nd.c.comments_after);
					} else {
						this->Generate(nd.c);
					}
					if( this.auto_space && nd.comments_after.indexOf('\n') < 0 && !(nd.s && nd.s.comments_before.indexOf('\n') >= 0) ) {
						this.code.push('\n');
					}
				} else if( (nd.flags & ama::DEP_TYPE_MASK) == ama::DEP_JS_REQUIRE ) {
					this.code.push('require(');
					this->Generate(nd.c);
					this.code.push(')');
				}
				break;
			}
			case ama::N_BINOP: {
				this->Generate(nd.c);
				this.GenerateSpaceAfter(nd.c);
				this.code.push(nd.data);
				this.GenerateSpaceBefore(nd.c.s);
				this->Generate(nd.c.s);
				break;
			}
			case ama::N_UNARY: {
				if( nd.flags & ama::UNARY_POSTFIX ) {
					this->Generate(nd.c);
					this.code.push(nd.data);
				} else {
					this.code.push(nd.data);
					this->Generate(nd.c);
				}
				break;
			}
			case ama::N_ASSIGNMENT: {
				this->Generate(nd.c);
				if( nd.c.s.node_class == ama::N_AIR ) {
					//do nothing
				} else {
					this.GenerateSpaceAfter(nd.c);
					if( nd.data != NULL ) {
						this.code.push(nd.data);
					}
					this.code.push('=');
					this.GenerateSpaceBefore(nd.c.s);
					this->Generate(nd.c.s);
				}
				break;
			}
			case ama::N_CLASS: case ama::N_KEYWORD_STATEMENT: case ama::N_SCOPED_STATEMENT: case ama::N_EXTENSION_CLAUSE: {
				this.code.push(nd.data);
				if( nd.c && !(nd.c.node_class == ama::N_EXTENSION_CLAUSE || nd.c.node_class == ama::N_SCOPE || nd.c.node_class == ama::N_AIR) ) {
					this.GenerateSpaceBefore(nd.c);
				}
				//*** PASS THROUGH ***
			}
			case ama::N_FUNCTION: {
				//N_CLASS: before, name, after, body
				//N_FUNCTION: before, paramlist, after, body
				//N_SCOPED_STATEMENT, N_EXTENSION_CLAUSE: arg, body
				for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
					if( ndi.node_class == ama::N_EXTENSION_CLAUSE || ndi.node_class == ama::N_SCOPE ) {
						this.GenerateSpaceBefore(ndi);
					}
					this->Generate(ndi);
				}
				break;
			}
			case ama::N_NODEOF: {
				this.code.push('.');
				this->Generate(nd.c);
				break;
			}
			case ama::N_CONDITIONAL: {
				this->Generate(nd.c);
				this.GenerateSpaceAfter(nd.c);
				this.code.push('?');
				this.GenerateSpaceBefore(nd.c.s);
				this->Generate(nd.c.s);
				this.GenerateSpaceAfter(nd.c.s);
				this.code.push(':');
				this.GenerateSpaceBefore(nd.c.s.s);
				this->Generate(nd.c.s.s);
				break;
			}
			case ama::N_LABELED: {
				this->Generate(nd.c);
				this.code.push(':');
				this.GenerateSpaceBefore(nd.c.s);
				this->Generate(nd.c.s);
				break;
			}
			case ama::N_AIR: {
				//nothing
				break;
			}
			case ama::N_SEMICOLON: {
				this->Generate(nd.c);
				this.code.push(';');
				break;
			}
			case ama::N_PAREN: {
				this.code.push('(');
				intptr_t! bk_indent = this.scope_indent_level;
				this.scope_indent_level += nd.indent_level;
				this->Generate(nd.c);
				this.scope_indent_level = bk_indent;
				this.code.push(')');
				break;
			}
		}
		//case N_ITEM:
	}
	void! ama::CodeGenerator::GenerateIndent(ama::CodeGenerator*+! this, intptr_t! expected_indent_level) {
		intptr_t! current_indent_level = 0L;
		if( current_indent_level >= expected_indent_level ) {
			this.p_last_indent = this.code.lastIndexOf('\n') + 1L;
			return;
		}
		intptr_t! p_last_line = this.p_last_indent;
		int! end_last_indent = p_last_line;
		while( end_last_indent < this.code.length && (this.code[end_last_indent] == ' ' || this.code[end_last_indent] == '\t') ) {
			end_last_indent += 1;
		}
		while( current_indent_level < expected_indent_level ) {
			if( (current_indent_level % this.tab_width) == 0 && (current_indent_level + this.tab_width) <= expected_indent_level && 
			!(p_last_line < end_last_indent && this.code[p_last_line] == ' ') && this.tab_indent ) {
				if( p_last_line < end_last_indent ) {
					assert(this.code[p_last_line] == '\t');
					p_last_line += 1;
				}
				this.code.push_back('\t');
				current_indent_level /= this.tab_width;
				current_indent_level += 1;
				current_indent_level *= this.tab_width;
			} else {
				if( p_last_line < end_last_indent ) {
					p_last_line += 1;
				}
				this.code.push_back(' ');
				current_indent_level += 1L;
			}
		}
		this.p_last_indent = this.code.lastIndexOf('\n') + 1L;
	}
	void! ama::CodeGenerator::GenerateCommentDefault(ama::CodeGenerator*+! this, int! is_after, intptr_t! expected_indent_level, char[...]! comment) {
		//if( comment.indexOf('\n') < 0 ) {
		//	this.code.push(comment);
		//	return;
		//}
		for(intptr_t! i = 0; i < comment.length; i++) {
			char! ch = comment[i];
			if( ch == '\n' ) {
				this.code.push(ch);
				//unify in-comment indent
				intptr_t! indent_level = expected_indent_level;
				i += 1;
				while( i < comment.length ) {
					if( comment[i] == ' ' ) {
						indent_level += 1;
					} else if( comment[i] == '\t' ) {
						indent_level /= this.tab_width;
						indent_level += 1;
						indent_level *= this.tab_width;
					} else {
						break;
					}
					i += 1;
				}
				i -= 1;
				this.GenerateIndent(indent_level);
				continue;
			}
			this.code.push(ch);
		}
	}
	void! ama::CodeGenerator::GenerateComment(ama::CodeGenerator*+! this, int! is_after, intptr_t! expected_indent_level, char[...]! comment) {
		if( this.hook_comment != NULL ) {
			if( this.hook_comment(this, comment.data(), comment.length, is_after, expected_indent_level) != 0 ) { return; }
		}
		this.GenerateCommentDefault(is_after, expected_indent_level, comment);
	}
	void! ama::CodeGenerator::Generate(ama::CodeGenerator*+! this, ama::Node*+! nd) {
		if( !nd ) {
			this.code.push('/*NULL*/');
			return;
		}
		ama::Node*+! bk = this.nd_current;
		this.nd_current = nd;
		intptr_t! expected_indent_level = this.scope_indent_level + intptr_t(nd.indent_level);
		//expected_indent_level should be normally redundant
		this.GenerateComment(0, expected_indent_level, nd.comments_before);
		if( this.hook != NULL && this.hook(this, nd) != 0 ) {
			//the hook generated it
		} else {
			this.GenerateDefault(nd);
		}
		//if( nd.p && (nd.p.node_class == ama::N_SCOPE || nd.p.node_class == ama::N_FILE) && 
		//nd.NeedTrailingSemicolon() ) {
		//	this->code.push_back(';');
		//}
		//the "normal" content of a node should not contain newline
		this.GenerateComment(1, this.scope_indent_level + (nd.s ? intptr_t(nd.s.indent_level) : 0L), nd.comments_after);
		this.nd_current = bk;
	}
	//this is exposed to JS with a non-standard wrapper, so make it a non-method
	char[+]! GenerateCode(ama::Node*+! nd, JSValueConst! options) {
		options = ama::InheritOptions(options);
		ama::CodeGenerator! ctx = new ama::CodeGenerator!();
		ctx.tab_width = ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'tab_width'), 4);
		ctx.auto_space = ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'auto_space'), 1);
		ctx.tab_indent = ama::UnwrapInt32(JS_GetPropertyStr(ama::jsctx, options, 'tab_indent'), 1);
		ctx.Generate(nd);
		return <<ctx.code;
	}
	char[+]! ama::Node::toSource(ama::Node*! this) {
		return GenerateCode((ama::Node*+)(this), JS_NULL);
	}
};
