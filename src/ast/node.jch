// //// JC version: 3
#pragma add("jc_files", "./node.jc");

namespace ama {
	const uint8_t! N_NONE = 0;
	/////////////////
	//raw nodes
	const uint8_t! N_RAW = 1;
	const uint8_t! N_SYMBOL = 2;
	const uint8_t! N_REF = 3;
	const uint8_t! N_NUMBER = 4;
	const uint8_t! N_STRING = 5;
	/////////////////
	//structured nodes
	const uint8_t! N_NODEOF = 6;
	const uint8_t! N_SCOPE = 7;
	const uint8_t! N_FUNCTION = 8;
	const uint8_t! N_CLASS = 9;
	const uint8_t! N_TYPED_VAR = 10;
	const uint8_t! N_DOT = 11;
	const uint8_t! N_ITEM = 12;
	const uint8_t! N_CALL = 13;
	const uint8_t! N_CALL_TEMPLATE = 14;
	const uint8_t! N_CALL_CUDA_KERNEL = 15;
	const uint8_t! N_DEPENDENCY = 16;
	const uint8_t! N_BINOP = 17;
	const uint8_t! N_UNARY = 18;
	const uint8_t! N_ASSIGNMENT = 19;
	const uint8_t! N_SCOPED_STATEMENT = 20;
	const uint8_t! N_EXTENSION_CLAUSE = 21;
	const uint8_t! N_PARAMETER_LIST = 22;
	//const uint8_t! N_RAW_DECLARATION = 8;
	//don't start any other constant with N_
	/////////////////
	const uint16_t! TMPF_IS_NODE = 32768u;
	/////////////////
	const uint32_t! REF_WRITTEN = 1u;
	//REF_RW is only set for REF_WRITTEN nodes: non-written nodes are trivially read 
	const uint32_t! REF_RW = 2u;
	const uint32_t! LITERAL_PARSED = 1u;
	const uint32_t! STRING_SINGLE_QUOTED = 2u;
	const uint32_t! DOT_PTR = 1u;
	const uint32_t! DOT_CLASS = 2u;
	const uint32_t! UNARY_POSTFIX = 1u;
	const uint32_t! DEP_C_INCLUDE = 0u;
	const uint32_t! DEP_JS_REQUIRE = 1u;
	const uint32_t! DEP_TYPE_MASK = 31u;
	const uint32_t! DEPF_C_INCLUDE_NONSTR = 32u;
	/////////////////
	class TCloneResult {
		Node*+! nd;
		std::unordered_map<Node*, Node*+>! mapping;
	};
	const int! POS_BEFORE = 0;
	const int! POS_AFTER = 1;
	const int! POS_FRONT = 2;
	const int! POS_BACK = 3;
	const int! POS_REPLACE = 4;
	/////////////////
	const int32_t! BOUNDARY_FUNCTION = 1;
	const int32_t! BOUNDARY_CLASS = 2;
	const int32_t! BOUNDARY_LOOP = 4;
	const int32_t! BOUNDARY_SWITCH = 8;
	//we no longer have macro decls
	//const int32_t! BOUNDARY_MACRO_DECL = 16;
	const int32_t! BOUNDARY_NODEOF = 32;
	const int32_t! BOUNDARY_SCOPE = 64;
	const int32_t! BOUNDARY_MATCH = 128;
	const int32_t! BOUNDARY_ONE_LEVEL = 256;
	const int32_t! BOUNDARY_PROTOTYPE = 512;
	const int32_t! BOUNDARY_ANY = 0x7fffffff;
	const int32_t! BOUNDARY_DEFAULT = BOUNDARY_NODEOF;
	//we don't track original code locations, just report errors into the generated code using #error and stuff
	//try to fit into a 64 byte cacheline
	class Node {
		uint8_t! node_class;
		//store delta w.r.t. parent N_RAW
		int8_t! indent_level;
		uint16_t! tmp_flags;
		uint32_t! flags;
		char[|]! data;
		/////////////
		char[|]! comments_before;
		char[|]! comments_after;
		/////////////
		//child
		Node*+! @nojson c;
		//sibling
		Node*+! @nojson s;
		//parent
		Node*+! @nojson p;
		/////////////
		inline! auto forEach(Node*! this, any loop_body) {
			for(ama::Node*+! ndi = this->c; ndi; ndi = ndi.s) {
				loop_body(ndi);
			}
		}
		inline ama::Node*+! setData(ama::Node*+! this, char[|]! data) {
			this->data = data;
			return this;
		}
		inline ama::Node*+! setFlags(ama::Node*+! this, int! flags) {
			this->flags = flags;
			return this;
		}
		inline ama::Node*+! setCommentsBefore(ama::Node*+! this, char[|]! comments) {
			this.comments_before = comments;
			return this;
		}
		inline ama::Node*+! setCommentsAfter(ama::Node*+! this, char[|]! comments) {
			this.comments_after = comments;
			return this;
		}
		inline ama::Node*+! setIndent(ama::Node*+! this, int! indent_level) {
			this->indent_level = indent_level;
			return this;
		}
		/////////////
		ama::TCloneResult! CloneEx(ama::Node*! this);
		ama::Node*+! Clone(ama::Node*! this);
		ama::Node*+! CloneList(ama::Node*! this);
		auto ReplaceLinkToThis(ama::Node*+! this, ama::Node*+! nd_new);
		ama::Node*+! ReplaceWith(ama::Node*+! this, ama::Node*+! nd_new);
		auto Delete(ama::Node*+! this);
		ama::Node*+! Insert(ama::Node*+! this, int! pos, ama::Node*+! nd_new);
		ama::Node*+! Root(ama::Node*! this);
		ama::Node*+! RootStatement(ama::Node*! this);
		int! isAncestorOf(ama::Node*! this, ama::Node*! nd);
		ama::Node*+! Owning(ama::Node*! this, int! nc);
		ama::Node*+! Owner(ama::Node*! this);
		ama::Node*+! LastChild(ama::Node*! this);
		ama::Node*+! CommonAncestor(ama::Node*! this, ama::Node*! b);
		char[|]! GetStringValue(ama::Node*! this);
		ama::Node*+! dot(ama::Node*+! this, char[|]! name);
		void! FreeASTStorage(ama::Node*+! this);
		ama::Node*+! Find(ama::Node*! this, int! node_class, char[|]! data);
		ama::Node*+[+]! FindAll(ama::Node*! this, int! node_class, char[|]! data);
		ama::Node*+[+]! FindAllWithin(ama::Node*! this, int32_t! boundary, int! node_class, char[|]! data);
		ama::Node*+[+]! FindAllBefore(ama::Node*! this, ama::Node*! nd_before, int32_t! boundary, int! node_class, char[|]! data);
		int! isRawNode(ama::Node*! this, char! ch_open, char! ch_close);
		char[|]! GetName(ama::Node*! this);
		int! hasBrackets(ama::Node*! this);
		/////////////
		//src/codegen/gen.jc
		char[+]! toSource(ama::Node*! this);
		int! isMethodCall(ama::Node*! this, char[|]! name);
		ama::Node*+! InsertDependency(ama::Node*+! this, uint32_t! flags, char[|]! name);
		ama::Node*+! InsertCommentBefore(ama::Node*+! this, char[...]! s);
		ama::Node*! Save(ama::Node*! this, char[|]! change_ext);
		ama::Node*+! MergeCommentsAfter(ama::Node*+! this, ama::Node*+! nd_after);
		ama::Node*+! MergeCommentsBefore(ama::Node*+! this, ama::Node*+! nd_before);
		char[|]! DestroyForSymbol(ama::Node*+! this);
		int! isExpr(ama::Node*! this);
		int! isSymbol(ama::Node*! this, char[...]! name);
		int! isAir(ama::Node*! this);
	};
	ama::Node*+! AllocNode();
	extern ama::Node*+! g_placeholder;
	int! isValidNodePointer(ama::Node*! nd_tentative);
	ama::Node*+! CreateNode(uint8_t! node_class, ama::Node*+! child);
	ama::Node*+! FillParents(ama::Node*+! nd_parent, ama::Node*+! nd);
	inline ama::Node*+! cons(ama::Node*+! a, ama::Node*+! b) {
		assert(a != b);
		a.s = b;
		return a;
	}
	inline ama::Node*+! InsertMany(ama::Node*+[...]! children) {
		ama::Node*+! nd = NULL;
		for(intptr_t! I = children.length - 1L; I >= 0L; I -= 1L) {
			nd = cons(children[I], nd);
		}
		return nd;
	}
	inline ama::Node*+! nString(char[|]! s) {
		return ama::CreateNode(N_STRING, NULL).setFlags(ama::LITERAL_PARSED).setData(s);
	}
	inline ama::Node*+! nRef(char[|]! s) {
		return ama::CreateNode(N_REF, NULL).setData(s);
	}
	inline ama::Node*+! nSymbol(char[|]! s) {
		return ama::CreateNode(N_SYMBOL, NULL).setData(s);
	}
	inline ama::Node*+! nNumber(char[|]! s) {
		return ama::CreateNode(N_NUMBER, NULL).setData(s);
	}
	inline ama::Node*+! nNodeof(Node*+! nd) {
		nd.s = NULL;
		return ama::CreateNode(N_NODEOF, nd);
	}
	inline ama::Node*+! nUnary(char[|]! s, Node*+! nd) {
		nd.s = NULL;
		return ama::CreateNode(N_UNARY, nd).setData(s);
	}
	inline ama::Node*+! nUnaryPostfix(Node*+! nd, char[|]! s) {
		nd.s = NULL;
		return ama::CreateNode(N_UNARY, nd).setData(s).setFlags(UNARY_POSTFIX);
	}
	inline ama::Node*+! nAssignment(Node*+! nd_def, Node*+! nd_value) {
		return ama::CreateNode(N_ASSIGNMENT, cons(nd_def, cons(nd_value, NULL)));
	}
	inline ama::Node*+! nBinop(Node*+! nd_a, char[|]! op, Node*+! nd_b) {
		return ama::CreateNode(N_BINOP, cons(nd_a, cons(nd_b, NULL))).setData(op);
	}
	inline ama::Node*+! nExtensionClause(char[|]! keyword, Node*+! nd_arg, Node*+! nd_scope) {
		return ama::CreateNode(N_EXTENSION_CLAUSE, cons(nd_arg, nd_scope)).setData(keyword);
	}
	inline ama::Node*+! nTypedVar(Node*+! nd_type, Node*+! nd_def) {
		return ama::CreateNode(N_TYPED_VAR, cons(nd_type, cons(nd_def, NULL)));
	}
	//the namespace in `::foo`, the initial value in `int bar;`
	inline ama::Node*+! nAir() {
		return ama::CreateNode(N_RAW, NULL);
	}
	///////////////
	inline ama::Node*+! GetPlaceHolder() {
		assert(!g_placeholder.p);
		assert(!g_placeholder.s);
		g_placeholder.comments_before = '';
		g_placeholder.comments_after = '';
		return g_placeholder;
	}
	ama::Node*+! CreateNodeFromChildren(uint8_t! node_class, ama::Node*+[...]! children);
	///////////////
	//macro nRawDeclaration() = function(auto my_call, ...args):auto {
	//	return require("./v3macros.js").ASTConstructor(my_call, args, "N_RAW_DECLARATION");
	//}
	macro nDependency() = function(auto my_call, ...args):auto {
		return require("./v3macros.js").ASTConstructor(my_call, args, "N_DEPENDENCY");
	}
};
ama::Node*+! ReplaceChildRange(ama::Node*+*+! pp0, ama::Node*+! p0, ama::Node*+! p1, ama::Node*+! nd_new);
