// //// JC version: 3
#pragma add("jc_files", "./node.jc");
#pragma add('cflags', '-fno-delete-null-pointer-checks');

namespace ama {
	const uint8_t! N_NONE = 0;
	/////////////////
	//raw nodes
	const uint8_t! N_RAW = 1;
	const uint8_t! N_SYMBOL = 2;
	const uint8_t! N_REF = 3;
	const uint8_t! N_NUMBER = 4;
	const uint8_t! N_STRING = 5;
	/////////////////
	//structured nodes
	const uint8_t! N_NODEOF = 6;
	const uint8_t! N_SCOPE = 7;
	const uint8_t! N_FUNCTION = 8;
	const uint8_t! N_CLASS = 9;
	const uint8_t! N_POSTFIX = 10;
	const uint8_t! N_DOT = 11;
	const uint8_t! N_ITEM = 12;
	const uint8_t! N_CALL = 13;
	const uint8_t! N_CALL_TEMPLATE = 14;
	const uint8_t! N_CALL_CUDA_KERNEL = 15;
	const uint8_t! N_DEPENDENCY = 16;
	const uint8_t! N_BINOP = 17;
	const uint8_t! N_PREFIX = 18;
	const uint8_t! N_ASSIGNMENT = 19;
	const uint8_t! N_SCOPED_STATEMENT = 20;
	const uint8_t! N_EXTENSION_CLAUSE = 21;
	const uint8_t! N_PARAMETER_LIST = 22;
	const uint8_t! N_CONDITIONAL = 23;
	const uint8_t! N_LABELED = 24;
	//we don't want to process N_AIR / N_FILE when finding N_RAW
	const uint8_t! N_AIR = 25;
	const uint8_t! N_FILE = 26;
	const uint8_t! N_SEMICOLON = 27;
	const uint8_t! N_PAREN = 28;
	const uint8_t! N_KEYWORD_STATEMENT = 29;
	/////////////////
	const uint8_t! N_JS_REGEXP = 30;
	//don't start any other constant with N_
	/////////////////
	const uint16_t! TMPF_IS_NODE = 32768u;
	const uint16_t! TMPF_GC_MARKED = 16384u;
	/////////////////
	const uint32_t! FILE_SPACE_INDENT = 1u;
	const uint32_t! REF_WRITTEN = 1u;
	//REF_RW is only set for REF_WRITTEN nodes: non-written nodes are trivially read 
	const uint32_t! REF_RW = 2u;
	//function / class names are declared but not written
	const uint32_t! REF_DECLARED = 4u;
	//const uint32_t! CALL_IS_UNARY_OPERATOR = 1u;
	const uint32_t! LITERAL_PARSED = 1u;
	const uint32_t! STRING_SINGLE_QUOTED = 2u;
	const uint32_t! DOT_PTR = 1u;
	const uint32_t! DOT_CLASS = 2u;
	const uint32_t! DEP_C_INCLUDE = 0u;
	const uint32_t! DEP_JS_REQUIRE = 1u;
	const uint32_t! DEP_TYPE_MASK = 31u;
	const uint32_t! DEPF_C_INCLUDE_NONSTR = 32u;
	//reserve 1 bit
	const intptr_t! MAX_INDENT = 63;
	/////////////////
	class TCloneResult {
		Node*+! nd;
		std::unordered_map<Node*, Node*+>! mapping;
	};
	const int! POS_BEFORE = 0;
	const int! POS_AFTER = 1;
	const int! POS_FRONT = 2;
	const int! POS_BACK = 3;
	const int! POS_REPLACE = 4;
	/////////////////
	const int32_t! BOUNDARY_FUNCTION = 1;
	const int32_t! BOUNDARY_CLASS = 2;
	//const int32_t! BOUNDARY_LOOP = 4;
	//const int32_t! BOUNDARY_SWITCH = 8;
	//we no longer have macro decls
	//const int32_t! BOUNDARY_MACRO_DECL = 16;
	const int32_t! BOUNDARY_NODEOF = 32;
	const int32_t! BOUNDARY_SCOPE = 64;
	const int32_t! BOUNDARY_MATCH = 128;
	const int32_t! BOUNDARY_ONE_LEVEL = 256;
	//const int32_t! BOUNDARY_PROTOTYPE = 512;
	const int32_t! BOUNDARY_ANY = 0x7fffffff;
	const int32_t! BOUNDARY_DEFAULT = BOUNDARY_NODEOF;
	/////////////////
	const uint8_t! CFG_BASIC = 0;
	const uint8_t! CFG_BRANCH = 1;
	const uint8_t! CFG_LOOP = 2;
	const uint8_t! CFG_JUMP = 3;
	//decl is different from basic since we never get into them from the outside
	const uint8_t! CFG_DECL = 4;
	//we don't track original code locations, just report errors into the generated code using #error and stuff
	//try to fit into a 64 byte cacheline
	class Node {
		uint8_t! node_class;
		//store delta w.r.t. parent N_RAW
		int8_t! indent_level;
		uint16_t! tmp_flags;
		uint32_t! flags;
		char[|]! data;
		/////////////
		char[|]! comments_before;
		char[|]! comments_after;
		/////////////
		//child
		Node*+! @nojson c;
		//sibling
		Node*+! @nojson s;
		//parent
		Node*+! @nojson p;
		//last sibling
		Node*+! @nojson v;
		/////////////
		inline! auto forEach(Node*! this, any loop_body) {
			for(ama::Node*+! ndi = this->c; ndi; ndi = ndi.s) {
				loop_body(ndi);
			}
		}
		inline ama::Node*+! setData(ama::Node*+! this, char[|]! data) {
			this->data = data;
			return this;
		}
		inline ama::Node*+! setFlags(ama::Node*+! this, int! flags) {
			this->flags = flags;
			return this;
		}
		inline ama::Node*+! setCommentsBefore(ama::Node*+! this, char[|]! comments) {
			assert(comments != NULL);
			this.comments_before = comments;
			return this;
		}
		inline ama::Node*+! setCommentsAfter(ama::Node*+! this, char[|]! comments) {
			assert(comments != NULL);
			this.comments_after = comments;
			return this;
		}
		inline ama::Node*+! setIndent(ama::Node*+! this, int! indent_level) {
			this->indent_level = indent_level;
			return this;
		}
		/////////////
		ama::TCloneResult! CloneEx(ama::Node*! this);
		ama::Node*+! Clone(ama::Node*! this);
		//auto ReplaceLinkToThis(ama::Node*+! this, ama::Node*+! nd_new);
		ama::Node*+! ReplaceWith(ama::Node*+! this, ama::Node*+! nd_new);
		ama::Node*+! Unlink(ama::Node*+! this);
		ama::Node*+! Insert(ama::Node*+! this, int! pos, ama::Node*+! nd_new);
		ama::Node*+! Root(ama::Node*! this);
		ama::Node*+! RootStatement(ama::Node*! this);
		int! isAncestorOf(ama::Node*! this, ama::Node*! nd);
		ama::Node*+! Owning(ama::Node*! this, int! nc);
		ama::Node*+! Owner(ama::Node*! this);
		//LastChildSP is for internal use only in simppair.jc (SP stands for simppair)
		ama::Node*+! LastChildSP(ama::Node*! this);
		ama::Node*+! LastChild(ama::Node*! this);
		ama::Node*+! CommonAncestor(ama::Node*! this, ama::Node*! b);
		char[|]! GetStringValue(ama::Node*! this);
		ama::Node*+! dot(ama::Node*+! this, char[|]! name);
		void! FreeASTStorage(ama::Node*+! this);
		ama::Node*+! Find(ama::Node*! this, int! node_class, char[|]! data);
		ama::Node*+[+]! FindAll(ama::Node*! this, int! node_class, char[|]! data);
		ama::Node*+[+]! FindAllWithin(ama::Node*! this, int32_t! boundary, int! node_class, char[|]! data);
		ama::Node*+[+]! FindAllBefore(ama::Node*! this, ama::Node*! nd_before, int32_t! boundary, int! node_class, char[|]! data);
		int! isRawNode(ama::Node*! this, char! ch_open, char! ch_close);
		char[|]! GetName(ama::Node*! this);
		/////////////
		//src/codegen/gen.jc
		char[+]! toSource(ama::Node*! this);
		int! isMethodCall(ama::Node*! this, char[|]! name);
		ama::Node*+! InsertDependency(ama::Node*+! this, uint32_t! flags, char[|]! name);
		ama::Node*+! InsertCommentBefore(ama::Node*+! this, char[...]! s);
		//ama::Node*! Save(ama::Node*! this, char[|]! change_ext);
		ama::Node*+! MergeCommentsBefore(ama::Node*+! this, ama::Node*+! nd_before);
		ama::Node*+! MergeCommentsAfter(ama::Node*+! this, ama::Node*+! nd_after);
		ama::Node*+! MergeCommentsAndIndentAfter(ama::Node*+! this, ama::Node*+! nd_after);
		char[|]! DestroyForSymbol(ama::Node*+! this);
		//expr is ill-defined once detached from a base language
		//NeedTrailingSemicolon is more practical
		//int! isExpr(ama::Node*! this);
		int! isSymbol(ama::Node*! this, char[...]! name);
		int! isRef(ama::Node*! this, char[...]! name);
		void! Validate(ama::Node*+! this);
		intptr_t! ValidateEx(ama::Node*+! this, intptr_t! max_depth, int! quiet);
		int! NeedTrailingSemicolon(ama::Node*! this);
		int8_t! GetCommentedIndentLevel(ama::Node*! this, int32_t! tab_width);
		ama::Node*+! ParentStatement(ama::Node*+! this);
		ama::Node*+! Prev(ama::Node*+! this);
		ama::Node*+! BreakSibling(ama::Node*+! this);
		ama::Node*+! BreakChild(ama::Node*+! this);
		ama::Node*+! BreakSelf(ama::Node*+! this);
		///nd_upto is inclusive
		ama::Node*+! ReplaceUpto(ama::Node*+! this, ama::Node*+! nd_upto, ama::Node*+! nd_new);
		int! ValidateChildCount(ama::Node*+! this, int! n_children);
		void! AdjustIndentLevel(ama::Node*+! this, intptr_t! delta);
		ama::Node*+! PreorderNext(ama::Node*+! this, ama::Node*+! nd_root);
		ama::Node*+! PreorderSkipChildren(ama::Node*+! this, ama::Node*+! nd_root);
		ama::Node*+! PreorderLastInside(ama::Node*+! this);
		ama::Node*+! PostorderFirst(ama::Node*+! this);
		ama::Node*+! PostorderNext(ama::Node*+! this, ama::Node*+! nd_root);
		ama::Node*+! toSingleNode(ama::Node*+! this);
		ama::Node*+! Unparse(ama::Node*+! this);
		uint8_t! GetCFGRole(ama::Node*! this);
		int! isChildCFGDependent(ama::Node*! this, ama::Node*! nd_child);
	};
	ama::Node*+! AllocNode();
	extern ama::Node*+! g_placeholder;
	int! isValidNodePointer(ama::Node*! nd_tentative);
	ama::Node*+! CreateNode(uint8_t! node_class, ama::Node*+! child);
	ama::Node*+! FixParents(ama::Node*+! nd_parent, ama::Node*+! nd);
	inline ama::Node*+! cons(ama::Node*+! a, ama::Node*+! b) {
		assert(a != b);
		a.s = b;
		if( b ) { b.v = a; }
		return a;
	}
	inline ama::Node*+! InsertMany(ama::Node*+[...]! children) {
		ama::Node*+! nd = NULL;
		for(intptr_t! I = children.length - 1L; I >= 0L; I -= 1L) {
			nd = cons(children[I], nd);
		}
		return nd;
	}
	inline ama::Node*+! nString(char[|]! s) {
		return ama::CreateNode(N_STRING, NULL).setFlags(ama::LITERAL_PARSED).setData(s);
	}
	inline ama::Node*+! nRef(char[|]! s) {
		return ama::CreateNode(N_REF, NULL).setData(s);
	}
	inline ama::Node*+! nSymbol(char[|]! s) {
		return ama::CreateNode(N_SYMBOL, NULL).setData(s);
	}
	inline ama::Node*+! nNumber(char[|]! s) {
		return ama::CreateNode(N_NUMBER, NULL).setData(s);
	}
	inline ama::Node*+! nNodeof(Node*+! nd) {
		nd.s = NULL;
		return ama::CreateNode(N_NODEOF, nd);
	}
	inline ama::Node*+! nPrefix(char[|]! s, Node*+! nd) {
		nd.s = NULL;
		return ama::CreateNode(N_PREFIX, nd).setData(s);
	}
	inline ama::Node*+! nPostfix(Node*+! nd, char[|]! s) {
		nd.s = NULL;
		return ama::CreateNode(N_POSTFIX, nd).setData(s);
	}
	inline ama::Node*+! nAssignment(Node*+! nd_def, Node*+! nd_value) {
		return ama::CreateNode(N_ASSIGNMENT, cons(nd_def, cons(nd_value, NULL))).setData("");
	}
	inline ama::Node*+! nUpdate(Node*+! nd_def, char[|]! op, Node*+! nd_value) {
		return ama::CreateNode(N_ASSIGNMENT, cons(nd_def, cons(nd_value, NULL))).setData(op);
	}
	inline ama::Node*+! nBinop(Node*+! nd_a, char[|]! op, Node*+! nd_b) {
		return ama::CreateNode(N_BINOP, cons(nd_a, cons(nd_b, NULL))).setData(op);
	}
	inline ama::Node*+! nExtensionClause(char[|]! keyword, Node*+! nd_arg, Node*+! nd_scope) {
		return ama::CreateNode(N_EXTENSION_CLAUSE, cons(nd_arg, nd_scope)).setData(keyword);
	}
	//inline ama::Node*+! nTypedVar(Node*+! nd_type, Node*+! nd_def) {
	//	return ama::CreateNode(N_TYPED_VAR, cons(nd_type, cons(nd_def, NULL)));
	//}
	//the namespace in `::foo`, the initial value in `int bar;`
	inline ama::Node*+! nAir() {
		return ama::CreateNode(N_AIR, NULL);
	}
	inline ama::Node*+! nConditional(Node*+! nd_cond, Node*+! nd_true, Node*+! nd_false) {
		return ama::CreateNode(N_CONDITIONAL, cons(nd_cond, cons(nd_true, cons(nd_false, NULL))));
	}
	inline ama::Node*+! nClass(char[|]! keyword, Node*+! nd_before, Node*+! nd_name, Node*+! nd_after, Node*+! nd_body) {
		assert(nd_name.node_class == N_REF || nd_name.node_class == N_DOT);
		return ama::CreateNode(N_CLASS, cons(nd_before, cons(nd_name, cons(nd_after, cons(nd_body, NULL))))).setData(keyword);
	}
	inline ama::Node*+! nFunction(Node*+! nd_before, Node*+! nd_proto, Node*+! nd_after, Node*+! nd_body) {
		return ama::CreateNode(N_FUNCTION, cons(nd_before, cons(nd_proto, cons(nd_after, cons(nd_body, NULL)))));
	}
	inline ama::Node*+! nLabeled(Node*+! nd_label, Node*+! nd_value) {
		return ama::CreateNode(N_LABELED, cons(nd_label, cons(nd_value, NULL)));
	}
	inline ama::Node*+! nDependency(Node*+! nd) {
		nd.s = NULL;
		return ama::CreateNode(N_DEPENDENCY, nd);
	}
	///////////////
	inline ama::Node*+! GetPlaceHolder() {
		assert(!g_placeholder.p);
		assert(!g_placeholder.s);
		g_placeholder.comments_before = '';
		g_placeholder.comments_after = '';
		g_placeholder.c = NULL;
		return g_placeholder;
	}
	//inline ama::Node*+! BreakLink(Node*+*+! pndi) {
	//	ama::Node*+! ret = *pndi;
	//	*pndi = NULL;
	//	return ret;
	//}
	inline int! isValidPreviousSibling(Node*! v) {
		return v && !(intptr_t(v) & 1);
	}
	inline Node*+! PackTailPointer(Node*+! nd_tail) {
		assert(!(intptr_t(nd_tail) & 1L));
		return (Node*+!)(intptr_t(nd_tail) | 1L);
	}
	inline Node*+! UnpackTailPointer(Node*+! nd_tail) {
		assert(intptr_t(nd_tail) & 1L);
		return (Node*+!)(intptr_t(nd_tail) & ~1L);
	}
	ama::Node*+! CreateNodeFromChildren(uint8_t! node_class, ama::Node*+[...]! children);
	///////////////
	int8_t! ClampIndentLevel(intptr_t! level);
	ama::Node*+! toSingleNode(ama::Node*+! nd_child);
	ama::Node*+! UnparseRaw(ama::Node*+! nd_raw);
	ama::Node*+[+]! GetAllPossibleNodeRanges();
	extern ama::Node*+! g_free_nodes;
	int! ValidateChildRange(ama::Node*+! p0, ama::Node*+! p1);
	void! DeleteChildRange(ama::Node*+! nd0, ama::Node*+! nd1);
	ama::Node*+! ReplaceChildRange(ama::Node*+! nd0, ama::Node*+! nd1, ama::Node*+! nd_new);
	//it's in JSAPI
	void! DumpASTAsJSON(ama::Node*+! nd);
};
