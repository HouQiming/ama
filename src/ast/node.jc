// //// JC version: 3
#include <fs.jch>
#include <console.jch>
#include <stdlib.h>
#include <unordered_map>
#include '../parser/literal.jch'
#include './node.jch'

namespace ama {
	///////////////////
	//the node pool
	private const intptr_t! BLOCK_SIZE = (1L << 21) - 64L;
	private class TBlockHeader {
		TBlockHeader*+! next;
		intptr_t! size;
	};
	//a zeroed TMemoryPool is an empty pool
	private class TMemoryPool {
		TBlockHeader*+! block;
		intptr_t! block_size;
		char*+! front;
		intptr_t! sz_free;
	};
	private void*! poolAlloc(TMemoryPool*+! ppool, intptr_t! sz) {
		intptr_t! align = sz & -sz;
		if( align > 16 ) { align = 16; } else if( align < 1 ) { align = 1; }
		intptr_t! align_offset = -intptr_t(ppool->front) & (align - 1);
		if( ppool->sz_free < (align_offset + sz) ) {
			if( !ppool->block_size ) {
				ppool->block_size = BLOCK_SIZE;
			}
			intptr_t! sz_alloc = (ppool->block_size > (sz + align) ? ppool->block_size : sz + align) + sizeof(TBlockHeader);
			TBlockHeader*+! new_block = (TBlockHeader*+)(calloc(1, sz_alloc));
			new_block->next = ppool->block;
			new_block->size = sz_alloc - sizeof(TBlockHeader);
			ppool->front = (char*+)(new_block) + sizeof(TBlockHeader);
			ppool->sz_free = sz_alloc - sizeof(TBlockHeader);
			ppool->block = new_block;
			align_offset = -intptr_t(ppool->front) & (align - 1);
		}
		char*+! ret = ppool->front + align_offset;
		ppool->front = ret + sz;
		ppool->sz_free -= align_offset + sz;
		return (void*)(ret);
	}
	private void! poolRelease(TMemoryPool*+! ppool) {
		for(TBlockHeader*+! i = ppool->block; i;) {
			TBlockHeader*+! next = i->next;
			free(i);
			i = next;
		}
		memset(ppool, 0, sizeof(TMemoryPool));
	}
	private TMemoryPool! g_node_pool = new TMemoryPool!();
	private ama::Node*+! g_free_nodes = NULL;
	private char[|]! g_empty_comment = "";
	ama::Node*+! AllocNode() {
		ama::Node*+! ret = NULL;
		if( g_free_nodes ) {
			ret = g_free_nodes;
			//we could have leftover data from a freed node, set to NULL to release RC
			ret.data = NULL;
			ret.comments_before = NULL;
			ret.comments_after = NULL;
			g_free_nodes = ret.s;
			memset((void*+)(ret), 0, sizeof(ama::Node));
		} else {
			ret = (ama::Node*+)(poolAlloc(&g_node_pool, sizeof(ama::Node)));
		}
		ret.tmp_flags = ama::TMPF_IS_NODE;
		//non-NULL guarantee for comments
		ret.comments_before = g_empty_comment;
		ret.comments_after = g_empty_comment;
		return ret;
	}
	ama::Node*+! g_placeholder = AllocNode();
	int! isValidNodePointer(ama::Node*! nd_tentative) {
		int! in_block = 0;
		for(TBlockHeader*! block = g_node_pool.block; block; block = block.next) {
			uintptr_t! ofs = uintptr_t(nd_tentative) - (uintptr_t(block) + sizeof(TBlockHeader));
			if( ofs < uintptr_t(block.size) && (ofs + uintptr_t(sizeof(ama::Node))) < uintptr_t(block.size) && (ofs % uintptr_t(sizeof(ama::Node))) == 0 ) {
				in_block = 1;
				break;
			}
		}
		return in_block && (nd_tentative.tmp_flags & ama::TMPF_IS_NODE);
	}
	///////////////////
	ama::Node*+! CreateNode(uint8_t! node_class, ama::Node*+! child) {
		ama::Node*+! ret = ama::AllocNode();
		ret.node_class = node_class;
		ret.c = child;
		for(ama::Node*+! ndi = child; ndi; ndi = ndi.s) {
			assert(ndi != ret);
			ndi.p = ret;
		}
		return ret;
	}
	ama::Node*+! CreateNodeFromChildren(uint8_t! node_class, ama::Node*+[...]! children) {
		ama::Node*+! nd = AllocNode();
		nd.node_class = node_class;
		for(intptr_t! I = children.length - 1L; I >= 0L; I -= 1L) {
			nd.c = ama::cons(children[I], nd.c);
			children[I].p = nd;
		}
		return nd;
	}
	ama::Node*+! FillParents(ama::Node*+! nd_parent, ama::Node*+! nd) {
		nd.p = nd_parent;
		for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
			FillParents(nd, ndi);
		}
		return nd;
	}
	int8_t! ClampIndentLevel(intptr_t! level) {
		if( level > ama::MAX_INDENT ) {
			level = ama::MAX_INDENT;
		} else if( level < -ama::MAX_INDENT ) {
			level = -ama::MAX_INDENT;
		}
		return int8_t(level);
	}
	ama::Node*+! toSingleNode(ama::Node*+! nd_child) {
		if( !nd_child || nd_child.s ) {
			ama::Node*+! ret = CreateNode(ama::N_RAW, nd_child);
			if( nd_child ) {
				ret.indent_level = nd_child.indent_level;
				std::swap(ret.comments_before, nd_child.comments_before);
				if( !ret.LastChild().hasBrackets() ) {
					std::swap(ret.comments_after, ret.LastChild().comments_after);
				}
			}
			return ret;
		} else {
			return nd_child;
		}
	}
	void! AdjustIndentLevel(ama::Node*+! nd_stmt, intptr_t! delta) {
		nd_stmt.indent_level = ama::ClampIndentLevel(nd_stmt.indent_level + delta);
		if( !(nd_stmt.node_class == ama::N_RAW && (nd_stmt.flags & 0xffff)) ) {
			for(ama::Node*+! ndi : nd_stmt) {
				AdjustIndentLevel(ndi, delta);
			}
		}
	}
	ama::Node*+! UnparseRaw(ama::Node*+! nd_raw) {
		assert(nd_raw.isRawNode(0, 0));
		ama::Node*+! nd_ret = nd_raw.ReplaceWith(nd_raw.c);
		nd_raw.c = NULL;
		nd_raw.FreeASTStorage();
		return nd_ret;
	}
	///////////////////////////////////////
	private int! ValidateChildRange(ama::Node*+! p0, ama::Node*+! p1) {
		if( p0 == p1 ) { return 1; }
		for(ama::Node*+! ndi = p0.s; ndi; ndi = ndi.s) {
			if( ndi == p1 ) { return 1; }
			if( ndi == p0 ) { return 0; }
		}
		return 0;
	}
	//p1 is inclusive
	ama::Node*+! ReplaceChildRange(ama::Node*+*+! pp0, ama::Node*+! p0, ama::Node*+! p1, ama::Node*+! nd_new) {
		assert(ValidateChildRange(p0, p1));
		if( pp0 ) { assert(*pp0 == p0); }
		if( !pp0 ) {
			pp0 = &p0.p.c;
			for(ama::Node*+! ndi = p0.p.c; ndi != p0; ndi = ndi.s) {
				pp0 = &ndi.s;
			}
			assert(*pp0 == p0);
		}
		ama::Node*+! nd_parent = p0.p;
		if( nd_new ) {
			*pp0 = nd_new;
			nd_new.p = nd_parent;
			nd_new.s = p1.s;
		} else {
			*pp0 = p1.s;
		}
		for(ama::Node*+! ndi = p0; ndi != p1; ndi = ndi.s) {
			ndi.p = NULL;
		}
		return nd_new;
	}
};

///////////////////
//basic tree operations
private ama::Node*+! dfsClone(std::unordered_map<ama::Node*, ama::Node*+>&+! mapping, ama::Node*! nd, int! is_root) {
	ama::Node*+! ret = mapping[nd];
	if( ret ) {
		return ret;
	}
	ret = ama::AllocNode();
	mapping[nd] = ret;
	ret.node_class = nd.node_class;
	ret.flags = nd.flags;
	//ret.tmp_flags |= nd.tmp_flags & (SYSF_OPT_OUT_NEWLINE_BEFORE | SYSF_NONJC_UNTOUCHED | SYSF_MULTIVAR_DECL);
	ret.data = nd.data;
	//ret.opaque = nd.opaque;
	ret.comments_before = nd.comments_before;
	ret.comments_after = nd.comments_after;
	//ret.file = nd.file;
	//ret.ofs0 = nd.ofs0;
	//ret.ofs1 = nd.ofs1;
	//ret.type = nd.type;
	//ret.def = nd.def;
	if( nd.c ) {
		ret.c = dfsClone(mapping, nd.c, 0);
		for(ama::Node*+! ndi = ret.c; ndi; ndi = ndi.s) {
			ndi.p = ret;
		}
	}
	if( nd.s != NULL && !is_root ) {
		ret.s = dfsClone(mapping, nd.s, 0);
	}
	return ret;
}

ama::TCloneResult! ama::Node::CloneEx(ama::Node*! this) {
	std::unordered_map<ama::Node*, ama::Node*+>! mapping = new std::unordered_map<ama::Node*, ama::Node*+>!();
	ama::Node*+! nd = dfsClone(mapping, this, 1);
	return new ama::TCloneResult!{
		mapping: <<mapping,
		nd: nd
	};
}

ama::Node*+! ama::Node::Clone(ama::Node*! this) {
	if( !intptr_t(this) ) {
		return NULL;
	}
	std::unordered_map<ama::Node*, ama::Node*+>! mapping = new std::unordered_map<ama::Node*, ama::Node*+>!();
	return dfsClone(mapping, this, 1);
}

ama::Node*+! ama::Node::CloneList(ama::Node*! this) {
	if( !intptr_t(this) ) {
		return NULL;
	}
	std::unordered_map<ama::Node*, ama::Node*+>! mapping = new std::unordered_map<ama::Node*, ama::Node*+>!();
	return dfsClone(mapping, this, 0);
}

//Node*+! Node::CloneCB(Node*! this,Node*+!(*)(Node*+,std::unordered_map<Node*, Node*+>&+!) callback){
//	std::unordered_map<Node*, Node*+>! mapping = new (std::unordered_map<Node*, Node*+>!)();
//	nd=NULL;
//	if( intptr_t(this) ) {
//		nd=dfsClone(mapping, this, 1);
//	}
//	return callback(nd,mapping)
//}
auto ama::Node::ReplaceLinkToThis(ama::Node*+! this, ama::Node*+! nd_new) {
	if( !this->p ) {
		return;
	}
	ama::Node*! nd = this;
	ama::Node*+! nd_prev = this->p.c;
	if( nd_prev == nd ) {
		this->p.c = nd_new;
		return;
	}
	//if anything is broken, we end up accessing NULL
	while( nd_prev.s != nd ) {
		nd_prev = nd_prev.s;
	}
	nd_prev.s = nd_new;
}

ama::Node*+! ama::Node::ReplaceWith(ama::Node*+! this, ama::Node*+! nd_new) {
	if( !nd_new ) {
		this->Delete();
		return NULL;
	} else {
		this->Insert(ama::POS_REPLACE, nd_new);
		return nd_new;
	}
}

auto ama::Node::Delete(ama::Node*+! this) {
	this->ReplaceLinkToThis(this->s);
	//break links for safety
	this->p = NULL;
	this->s = NULL;
}

//namespace jcc {
//	private auto FillErrorInfo(ama::Node*+! nd_tar, ama::Node*! nd_src) {
//		if( nd_tar.file == NULL ) {
//			nd_tar.file = nd_src.file;
//			nd_tar.ofs0 = nd_src.ofs0;
//			nd_tar.ofs1 = nd_src.ofs1;
//		}
//		for(ama::Node*+! ndi : nd_tar) {
//			FillErrorInfo(ndi, nd_src);
//		}
//	}
//};
ama::Node*+! ama::Node::Insert(ama::Node*+! this, int! pos, ama::Node*+! nd_new) {
	ama::Node*+! nd_new_parent = pos == ama::POS_FRONT || pos == ama::POS_BACK ? this : this->p;
	ama::Node*+! nd_tail = nd_new;
	for(;;) {
		assert(nd_tail != nd_new_parent);
		nd_tail.p = nd_new_parent;
		//jcc::FillErrorInfo(nd_tail, this);
		if( !nd_tail.s ) {
			break;
		}
		nd_tail = nd_tail.s;
	}
	if( pos == ama::POS_REPLACE ) {
		if( this.comments_before != '' && nd_new.comments_before == '' ) {
			nd_new.comments_before = this.comments_before;
			this.comments_before = '';
		}
		if( this.comments_after != '' && nd_new.comments_after == '' ) {
			nd_new.comments_after = this.comments_after;
			this.comments_after = '';
		}
		nd_new.indent_level = this.indent_level;
	}
	//if( nd_new_parent ) {
	//	nd_new_parent.tmp_flags &= ~SYSF_NONJC_UNTOUCHED;
	//}
	switch( pos ) {
		case ama::POS_BEFORE: {
			nd_tail.s = this;
			this->ReplaceLinkToThis(nd_new);
			break;
		}
		case ama::POS_AFTER: {
			nd_tail.s = this->s;
			this->s = nd_new;
			break;
		}
		case ama::POS_FRONT: {
			nd_tail.s = this->c;
			this->c = nd_new;
			break;
		}
		case ama::POS_BACK: {
			ama::Node*+! nd_my_tail = this->c;
			if( nd_my_tail ) {
				while( nd_my_tail.s ) {
					nd_my_tail = nd_my_tail.s;
				}
			}
			if( nd_my_tail ) {
				nd_my_tail.s = nd_new;
			} else {
				this->c = nd_new;
			}
			break;
		}
		case ama::POS_REPLACE: {
			nd_tail.s = this->s;
			this->ReplaceLinkToThis(nd_new);
			//break links for safety
			this->p = NULL;
			this->s = NULL;
			break;
		}
	}
	//if int(nd_new.node_class) == builder.N_DECLARATION && int(nd_new.p.node_class) == builder.N_VIRTUAL_FUNCTION_DECL: {
	//	assert(0);
	//}
	return nd_new;
}

ama::Node*+! ama::Node::Root(ama::Node*! this) {
	ama::Node*+! ndi = (ama::Node*+)(this);
	while( ndi.p ) {
		ndi = ndi.p;
	}
	return ndi;
}

ama::Node*+! ama::Node::RootStatement(ama::Node*! this) {
	ama::Node*+! ndi = (ama::Node*+)(this);
	while( ndi.p && ndi.p.p ) {
		ndi = ndi.p;
	}
	return ndi;
}

int! ama::Node::isAncestorOf(ama::Node*! this, ama::Node*! nd) {
	ama::Node*! nd_this = this;
	for(ama::Node*! ndi = nd; ndi; ndi = ndi.p) {
		if( ndi == nd_this ) {
			return 1;
		}
	}
	return 0;
}

ama::Node*+! ama::Node::Owning(ama::Node*! this, int! nc) {
	for(ama::Node*+! ndi = (ama::Node*+)(this); ndi; ndi = ndi.p) {
		if( int(ndi.node_class) == nc ) {
			return ndi;
		}
	}
	return NULL;
}

ama::Node*+! ama::Node::Owner(ama::Node*! this) {
	//|| int(ndi.node_class) == ama::N_RAW_DECLARATION
	for(ama::Node*+! ndi = this->p; ndi; ndi = ndi.p) {
		if( int(ndi.node_class) == ama::N_FUNCTION || int(ndi.node_class) == ama::N_CLASS || !ndi.p ) {
			return ndi;
		}
	}
	return NULL;
}

ama::Node*+! ama::Node::LastChild(ama::Node*! this) {
	ama::Node*+! ndi = this->c;
	if( ndi ) {
		while( ndi.s ) {
			ndi = ndi.s;
		}
		return ndi;
	} else {
		return NULL;
	}
}

ama::Node*+! ama::Node::CommonAncestor(ama::Node*! this, ama::Node*! b) {
	ama::Node*+! a = (ama::Node*+)(this);
	const ama::Node*+[+]! ancestors_a = new ama::Node*+[+]!();
	for(ama::Node*+! ndi = a; ndi; ndi = ndi.p) {
		ancestors_a.push(ndi);
	}
	const ama::Node*+[+]! ancestors_b = new ama::Node*+[+]!();
	for(ama::Node*+! ndi = (ama::Node*+)(b); ndi; ndi = ndi.p) {
		ancestors_b.push(ndi);
	}
	ama::Node*+! ret = NULL;
	while( ancestors_a.length && ancestors_b.length ) {
		const ama::Node*+! nda = ancestors_a.pop();
		const ama::Node*+! ndb = ancestors_b.pop();
		if( nda != ndb ) {
			break;
		}
		ret = nda;
	}
	return ret;
}

char[|]! ama::Node::GetStringValue(ama::Node*! this) {
	ama::Node*+! nd_this = (ama::Node*+)(this);
	assert(int(nd_this->node_class) == ama::N_STRING);
	if( int(nd_this->node_class) != ama::N_STRING || nd_this->data == NULL || (nd_this->flags & ama::LITERAL_PARSED) ) {
		return nd_this->data;
	} else {
		//process on demand
		assert(int(nd_this->node_class) == ama::N_STRING);
		if( nd_this->data.length && nd_this->data[0L] == '\'' ) {
			nd_this->flags |= ama::STRING_SINGLE_QUOTED;
		}
		nd_this->data = new char[|]!(ama::ParseJCString(nd_this->data));
		nd_this->flags |= ama::LITERAL_PARSED;
		return nd_this->data;
	}
}

ama::Node*+! ama::Node::dot(ama::Node*+! this, char[|]! name) {
	ama::Node*+! nd_ret = ama::CreateNode(ama::N_DOT, this);
	nd_ret.data = name;
	nd_ret.indent_level = this.indent_level;
	nd_ret.comments_before = this.comments_before;
	this.comments_before = '';
	return nd_ret;
}

private void! dfsFreeChildrenStorage(ama::Node*+! nd) {
	ama::Node*+! ndi_last = NULL;
	ama::Node*+! ndi0 = nd.c;
	intptr_t! n_steps = 0L;
	for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
		if( n_steps > 0 ) {
			assert(ndi != ndi0);
		}
		ndi_last = ndi;
		dfsFreeChildrenStorage(ndi);
		ndi.tmp_flags &= ~ama::TMPF_IS_NODE;
		ndi.p = NULL;
		if( n_steps & 1 ) {
			ndi0 = ndi0.s;
		}
		n_steps += 1;
	}
	if( ndi_last != NULL ) {
		ama::Node*+! g_free_nodes;
		ndi_last.s = g_free_nodes;
		g_free_nodes = nd.c;
		nd.c = NULL;
	}
}

void! ama::Node::FreeASTStorage(ama::Node*+! this) {
	ama::Node*+! g_free_nodes;
	//do not wipe .data and stuff, we could use them again in a C++ expr
	assert(!this.p);
	dfsFreeChildrenStorage(this);
	this.tmp_flags &= ~ama::TMPF_IS_NODE;
	this.s = g_free_nodes;
	g_free_nodes = this;
}

/////////////////////////
char[|]! ama::Node::GetName(ama::Node*! this) {
	mutable ama::Node*! nd = this;
	if( !nd ) {
		return NULL;
	}
	//} else if( int(this.node_class) == ama::N_FUNCTION ) {
	//	if( this.p != NULL && this == this.p.c.s && int(this.p.node_class) == ama::N_DECLARATION ) {
	//		return this.p.c.data;
	//	}
	//	if( this.p != NULL && this == this.p.c.s && int(this.p.node_class) == ama::N_ASSIGNMENT && this.p.c.node_class == ama::N_DOT ) {
	//		return this.p.c.data;
	//	}
	//} else if( int(this.node_class) == ama::N_CLASS || int(this.node_class) == ama::N_SET_FIELD || 
	//int(this.node_class) == ama::N_PRAGMA || int(this.node_class) == ama::N_DECLARATION || 
	//int(this.node_class) == ama::N_EXTERN || int(this.node_class) == ama::N_EXTERN_VAR ) {
	//	return this.c.data;
	//} else if( int(this.node_class) == ama::N_INCLUDE ) {
	//	return this.c.GetStringValue();
	if( this.node_class == ama::N_CALL || this.node_class == ama::N_CALL_TEMPLATE || this.node_class == ama::N_CALL_CUDA_KERNEL ) {
		if( this.c && this.c.node_class != this.node_class && this.c.node_class != ama::N_CALL ) {
			return this.c.GetName();
		} else {
			return NULL;
		}
	} else if( this.node_class == ama::N_ASSIGNMENT || this.node_class == ama::N_DEPENDENCY ) /*||int(this.node_class) == ama::N_YIELD || int(this.node_class) == ama::N_NO_INFER_TYPE */ {
		return this.c.GetName();
	} else if( this.node_class == ama::N_CLASS ) {
		return this.c.s.GetName();
	} else if( this.node_class == ama::N_STRING ) {
		ama::Node*+! nd_hack = (ama::Node*+)(this);
		return nd_hack.GetStringValue();
	} else {
		return this.data;
	}
}

private const int32_t! ROOT_FLAG = 0x80000000;

private ama::Node*+! dfsFind(ama::Node*+! nd, ama::Node*+! nd_before, int32_t! boundary, int! node_class, char[|]! data, ama::Node*+[+]&+! ret, int! first_only) {
	if( nd == nd_before ) {
		//returning non-NULL terminates the search
		return nd_before;
	}
	int32_t! my_boundary = ama::BOUNDARY_ONE_LEVEL;
	if( int(nd.node_class) == node_class || node_class == ama::N_NONE ) {
		int! matched = 1;
		if( data != NULL ) {
			matched = nd.GetName() == data;
		}
		//matched
		if( matched ) {
			if( !first_only ) {
				ret.push_back(nd);
				my_boundary |= ama::BOUNDARY_MATCH;
			} else {
				return nd;
			}
		}
	}
	//don't test boundary on root
	//allow the boundary itself to match
	//tests for ROOT_FLAG
	if( boundary > 0 ) {
		//if( int(nd.node_class) == ama::N_FUNCTION ) {
		//	my_boundary |= ama::BOUNDARY_FUNCTION;
		//} else if( int(nd.node_class) == ama::N_CLASS ) {
		//	my_boundary |= ama::BOUNDARY_CLASS;
		//} else if( int(nd.node_class) == ama::N_C_FOR || int(nd.node_class) == ama::N_JC_FOR_IN || int(nd.node_class) == ama::N_DO || int(nd.node_class) == ama::N_WHILE || int(nd.node_class) == ama::N_JC_RANGE_FOR ) {
		//	my_boundary |= ama::BOUNDARY_LOOP;
		//} else if( int(nd.node_class) == ama::N_SWITCH ) {
		//	my_boundary |= ama::BOUNDARY_SWITCH;
		//} else if( int(nd.node_class) == ama::N_MACRO_DECL ) {
		//	my_boundary |= ama::BOUNDARY_MACRO_DECL;
		//} else 
		// && !(nd.p && int(nd.p.node_class) == ama::N_STATIC_IF)
		if( int(nd.node_class) == ama::N_NODEOF ) {
			my_boundary |= ama::BOUNDARY_NODEOF;
		} else if( int(nd.node_class) == ama::N_SCOPE ) {
			my_boundary |= ama::BOUNDARY_SCOPE;
		}
		//} else if( int(nd.node_class) == ama::N_CALL && nd.p && nd.p.node_class == ama::N_RAW_DECLARATION ) {
		//	my_boundary |= ama::BOUNDARY_PROTOTYPE;
		//TODO: dedicated prototype node class
		if( boundary & my_boundary ) {
			return NULL;
		}
	}
	for(ama::Node*+! ndi = nd.c; ndi; ndi = ndi.s) {
		assert(ndi != nd);
		//console.log(nd.node_class, ndi.node_class);
		//if ndi.s == ndi: {
		//	for (Node* ndii = ndi; ndii; ndii = ndii.p) {
		//		console.log(ndii.node_class);
		//	}
		//	assert(0);
		//}
		const ama::Node*+! nd_found = dfsFind(ndi, nd_before, boundary & ~ROOT_FLAG, node_class, data, ret, first_only);
		if( nd_found ) {
			return nd_found;
		}
	}
	return NULL;
}

ama::Node*+! ama::Node::Find(ama::Node*! this, int! node_class, char[|]! data) {
	const ama::Node*+[+]! ret = new ama::Node*+[+]!();
	return dfsFind((ama::Node*+)(this), NULL, 0, node_class, data, ret, 1);
}

ama::Node*+[+]! ama::Node::FindAll(ama::Node*! this, int! node_class, char[|]! data) {
	const ama::Node*+[+]! ret = new ama::Node*+[+]!();
	dfsFind((ama::Node*+)(this), NULL, ama::BOUNDARY_DEFAULT | ROOT_FLAG, node_class, data, ret, 0);
	return <<ret;
}

ama::Node*+[+]! ama::Node::FindAllWithin(ama::Node*! this, int32_t! boundary, int! node_class, char[|]! data) {
	const ama::Node*+[+]! ret = new ama::Node*+[+]!();
	dfsFind((ama::Node*+)(this), NULL, boundary | ROOT_FLAG, node_class, data, ret, 0);
	return <<ret;
}

ama::Node*+[+]! ama::Node::FindAllBefore(ama::Node*! this, ama::Node*! nd_before, int32_t! boundary, int! node_class, char[|]! data) {
	const ama::Node*+[+]! ret = new ama::Node*+[+]!();
	dfsFind((ama::Node*+)(this), (ama::Node*+)(nd_before), boundary | ROOT_FLAG, node_class, data, ret, 0);
	return <<ret;
}

int! ama::Node::isRawNode(ama::Node*! this, char! ch_open, char! ch_close) {
	return this.node_class == ama::N_RAW && (this.flags & 0xffff) == (int32_t(ch_open) | int32_t(ch_close) << 8);
}

int! ama::Node::isSymbol(ama::Node*! this, char[...]! name) {
	return this.node_class == ama::N_SYMBOL && this.data == name;
}

int! ama::Node::hasBrackets(ama::Node*! this) {
	return (
		this.node_class == ama::N_RAW || this.node_class == ama::N_SCOPE || 
		this.node_class == ama::N_CALL || this.node_class == ama::N_CALL_TEMPLATE || 
		this.node_class == ama::N_CALL_CUDA_KERNEL || this.node_class == ama::N_PARAMETER_LIST
	);
}

int! ama::Node::isMethodCall(ama::Node*! this, char[|]! name) {
	return this.node_class == ama::N_CALL && this.c.node_class == ama::N_DOT && this.c.data == name;
}

///dependency is global: have to re-ParseDependency after you InsertDependency
ama::Node*+! ama::Node::InsertDependency(ama::Node*+! this, uint32_t! flags, char[|]! name) {
	for(ama::Node*+! ndi : this.FindAll(ama::N_DEPENDENCY, name)) {
		if( ndi.flags == flags ) { return ndi; }
	}
	return this.Insert(ama::POS_FRONT, ama::nDependency(ama::nString(name)).setFlags(flags));
}

ama::Node*+! ama::Node::InsertCommentBefore(ama::Node*+! this, char[...]! s) {
	this.comments_before = new char[|]!(s + this.comments_before);
	return this;
}

ama::Node*! ama::Node::Save(ama::Node*! this, char[|]! change_ext) {
	ama::Node*! nd_root = this;
	char[|]! fn = NULL;
	if( nd_root.node_class == ama::N_RAW && !nd_root.p ) {
		fn = nd_root.data;
		if( change_ext != NULL ) {
			size_t! p_dot = fn.lastIndexOf('.');
			if( p_dot < 0 ) {
				p_dot = fn.length;
			}
			fn = new char[|]!(fn.subarray(0, p_dot) + (change_ext.startsWith('.') ? "" : ".") + change_ext);
		}
	} else {
		if( change_ext == NULL ) {
			console.log('file name expected for Node::Save');
			return NULL;
		}
		fn = change_ext;
	}
	fs.writeFileSync(fn, this.toSource());
	return nd_root;
}

int! ama::Node::isExpr(ama::Node*! this) {
	switch( this.node_class ) {
		//case N_RAW:
		//case N_SYMBOL:
		case ama::N_REF: case ama::N_NUMBER: case ama::N_STRING: case ama::N_NODEOF: case ama::N_SCOPE: //case N_RAW_DECLARATION:
		//case N_FUNCTION:
		//case N_CLASS:
		case ama::N_DOT: case ama::N_ITEM: case ama::N_CALL: //case N_DEPENDENCY:
		case ama::N_BINOP: case ama::N_UNARY: case ama::N_ASSIGNMENT: {
			return 1;
		}
	}
	return 0;
}

///////////////////////////////////////
ama::Node*+! ama::Node::MergeCommentsAfter(ama::Node*+! this, ama::Node*+! nd_after) {
	this.comments_after = new char[|]!(this.comments_after + nd_after.comments_before);
	nd_after.comments_before = "";
	return this;
}

ama::Node*+! ama::Node::MergeCommentsBefore(ama::Node*+! this, ama::Node*+! nd_before) {
	this.comments_before = new char[|]!(nd_before.comments_after + this.comments_before);
	nd_before.comments_after = "";
	return this;
}

char[|]! ama::Node::DestroyForSymbol(ama::Node*+! this) {
	char[|]! ret = this.data;
	this.p = NULL;
	this.FreeASTStorage();
	return ret;
}

int! ama::Node::isAir(ama::Node*! this) {
	return this.node_class == ama::N_AIR;
}
