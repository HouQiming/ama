'use strict';
const fs = require('fs');
const path = require('path');
const depends = require('depends');
let cmake = module.exports;

let cmake_options = {
	enable_hash_comment: 1,
	parse_indent_as_scope: 0,
	parse_c_forward_declarations: 0,
	struct_can_be_type_prefix: 0,
}

cmake.LoadCMakeFile = function(fn, template) {
	let nd_root = ParseCode((fs.readFileSync(fn) || (typeof(template) == 'function' ? template() : template) || '').toString(), cmake_options);
	//if-endif pairing
	while (nd_root.c && !nd_root.c.s && nd_root.c.node_class === N_RAW && !(nd_root.c.flags & 0xffff) && nd_root.c.c) {
		nd_root.c.ReplaceWith(nd_root.c.c)
	}
	let if_stk = [];
	for (let ndi = nd_root.c; ndi; ndi = ndi.s) {
		if (ndi.node_class === N_CALL) {
			let name = ndi.GetName();
			if (name === 'if') {
				if_stk.push(ndi);
			} else if(name === 'endif' && if_stk.length > 0) {
				let nd0 = if_stk.pop();
				let nd_body = nd0.s;
				nd0.s = ndi.s;
				ndi.s = null;
				let nd_tmp = Node.GetPlaceHolder();
				nd0.ReplaceWith(nd_tmp);
				nd0.s = nd_body;
				ndi = nd_tmp.ReplaceWith(CreateNode(N_RAW, nd0));
			} else {
				//do nothing
			}
		}
	}
	return nd_root;
}

cmake.TokenizeCMakeArgs = function(nd_call) {
	let ret = [];
	if (!nd_call.c.s) {return ret;}
	function dfsTokenizeCMakeArgs(nd) {
		if (nd.node_class === N_RAW) {
			for (let ndi = nd.c; ndi; ndi = ndi.s) {
				dfsTokenizeCMakeArgs(ndi);
			}
		} else if(nd.node_class === N_STRING || nd.node_class === N_REF || nd.node_class === N_NUMBER || nd.node_class === N_SYMBOL) {
			ret.push(nd)
		} else {
			console.error('unrecognized cmake arg:', nd);
			ret.push(nd)
		}
	}
	dfsTokenizeCMakeArgs(nd_call.c.s);
	return ret;
}

cmake.FindTarget = function(nd_root, name) {
	for (let nd_target of nd_root.FindAll(N_CALL, 'add_executable').concat(nd_root.FindAll(N_CALL, 'add_library'))) {
		if (!nd_target.c.s) {continue;}
		let args = cmake.TokenizeCMakeArgs(nd_target);
		if (args.length && args[0].node_class === N_REF && args[0].data === name) {
			//found
			return nd_target;
		}
	}
	return null;
}

cmake.CreateTarget = function(nd_root, name, options) {
	if (!options) {
		options = {};
	}
	let nd_target = cmake.FindTarget(nd_root, name);
	if (nd_target) {return nd_target;}
	//create a new target
	let new_target = ['\n'];
	let output_format = options.format || 'exe';
	if (output_format === 'exe') {
		new_target.push('add_executable(', target);
	} else if(output_format === 'dll') {
		new_target.push('add_library(', target, ' SHARED');
	} else if(output_format === 'lib') {
		new_target.push('add_library(', target)
	} else {
		throw new Error('invalid output format ' + output_format)
	}
	let files = options.files || [];
	for (let fn: files) {
		new_target.push('\n  ', fn)
	}
	new_target.push('\n)')
	return nd_root.Insert(POS_BACK, ParseCode(new_target.join(''), cmake_options).Find(N_CALL, null))
}

//let nd_output_format_template = ParseCode('#pragma add("output_format",.(N_STRING(format)))\n').Find(N_KEYWORD_STATEMENT, '#pragma')
let nd_output_format_template = .{#pragma add("output_format", .(Node.MatchAny(N_STRING, 'format')))};
cmake.UpdateTargetWithSourceRoot = function(nd_root, nd_src_root) {
	let name = path.parse(nd_src_root.data).name;
	let nd_target = cmake.FindTarget(nd_root, name);
	if (nd_target) {
		//TODO: add files
		return nd_target;
	}
	let format = undefined;
	for (let nd_format of nd_src_root.FindAll(N_KEYWORD_STATEMENT, '#pragma')) {
		let match = nd_format.Match(nd_output_format_template)
		if (match) {
			format = match.format.GetStringValue();
			break;
		}
	}
	return cmake.CreateTarget(nd_root, name, {
		format: format,
		files: depends.ListAllDependency(nd_src_root, false)
	})
}

Node.UpdateCMakeLists = function(fn_cmake) {
	let nd_root = this;
	if (!fn_cmake) {
		let dir = path.dirname(fn_cmake);
		let dir_git = undefined;
		for (; ;) {
			let fn_test = path.join(dir, 'CMakeLists.txt');
			if (fs.existsSync(path.join(dir, '.git'))) {
				dir_git = dir;
			}
			if (fs.existsSync(fn_test)) {
				fn_cmake = fn_test;
				break;
			}
			if (dir_git) {break;}
		}
		if (dir_git && !fn_cmake) {
			fn_cmake=path.join(dir_git, 'CMakeLists.txt')
		}
	}
	let nd_cmake = cmake.LoadCMakeFile(fn_cmake, ()=>[
		'cmake_minimum_required (VERSION 3.0)\n',
		'project(',path.basename(path.dirname(path.resolve(fn_cmake))).replace(new(RegExp('[^0-9a-zA-Z]+', 'g')), '_'),')\n',
		'if(NOT AMA)\n',
		'  find_program(AMA ama)\n',
		'endif()\n'
	].join(''))
	//TODO: insert files
	//TODO: use ama to transform
	//TODO: insert the ama command
	nd_cmake.Save()
}
