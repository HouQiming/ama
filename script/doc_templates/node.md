# AST API Reference

Our AST (Abstract Syntax Tree) is a tree formed by homogeneously-typed `Node` objects. The AST is language neutral: the same `Node` constructs are used for every language, be it C, Python, or Javascript. We also use one unified parser, with minor customizations, to parse every language.

Not all language constructs are supported, though. Unrecognized language constructs will be parsed into *raw* nodes, which packs node or token sequences verbatim. We always interpret parenthesis so even raw nodes can still form a tree more useful than raw code strings.

## Creating an AST

The AST is usually parsed from strings or files in Javascript with one of the following APIs:

`ParseCode(code, [options])` parses the provided code string into an AST. This function is also available in C++.

`ParseCurrentFile([options])` parses the current file and returns an AST. The `.data` field of the returned root node stores the file path.

`require('depends').LoadFile(name)` loads a file and returns its AST, or `undefined` if the loading failed. The `.data` field of the returned root node stores the file path. Once a file is successfully loaded, the result is cached and later calls will return the same AST even if it were modified. This is useful for maintaining a partially-edited state.

Alternatively, we can also create an in-line AST by wrapping raw code with `@()` in an ama script.

### Parsing Options

The default parser options are listed by the `__global.default_options` assignment in `module/_init.js`:

```Javascript
【default_options】
```

## The Node Class

The `Node` class represents an AST node. It's available in C++ as `ama::Node` and available in Javascript as `Node`.

The Javascript `Node` global name refers to a prototype object and cannot be used directly for construction. Nodes have to be constructed with `node_class`-specific `nFoo` global functions, or created with the parsing functions.

The AST makes extensive use of doubly-linked lists. The links are exposed as mutable fields of `Node` with one-letter names: `.c .s .p .v`. Modifying those fields is not memory-safe, even in Javascript. We recommend mutating trees with methods like `Insert` and `Unlink` instead of modifying the fields directly, unless the task is really creative, 

### Fields

【fields】
**children** is a Javascript-only property which returns an array with all child nodes.

### Common Methods

Unless otherwise specified, the following methods are supported in both C++ and Javascript:

【apis_cpp】
--------------
- `nd.NodeofToASTExpression()`

Translate `@()` to Javascript node construction expression. Useful if we eventually run the AST in our own scripting context.

--------------
- `nd.AutoFormat()`

Format the AST with sane indentations. Useful on generated code before dumping.

--------------
- `Node.GetPlaceHolder()` (Javascript)
- `ama::GetPlaceHolder()` (C++)

Get a placeholder node required when adding code around an existing node, see `nd.ReplaceWith` for details.

### Javascript Methods

The following methods are only supported in Javascript:

【apis_js】
## Node Classes

Here is a list of all node classes, i.e., possible `node_class` values. The AST stores each node's children in the same order as the constructor parameters listed here.

【ctor】
## Notes

`doc/api_node.md` is automatically generated by `script/docgen.ama.js`. If we want to edit this document, edit `script/doc_templates/node.md` instead.
